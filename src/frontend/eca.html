<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ëã±ÊñáÂ∞çË©±Âä©Êâã - English Conversation Assistant</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent-blue: #00d4ff;
            --accent-green: #00ff88;
            --accent-red: #ff4444;
            --accent-yellow: #ffaa00;
            --border-color: #333;
        }

        body {
            font-family: 'Noto Sans TC', 'Microsoft JhengHei', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 500;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            background: var(--bg-tertiary);
        }

        .status-badge.connected {
            background: rgba(0, 255, 136, 0.15);
            color: var(--accent-green);
        }

        .status-badge.disconnected {
            background: rgba(255, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .status-badge.connecting {
            background: rgba(255, 170, 0, 0.15);
            color: var(--accent-yellow);
        }

        .status-badge.paused {
            background: rgba(255, 170, 0, 0.15);
            color: var(--accent-yellow);
        }

        .status-badge.ptt {
            background: rgba(0, 212, 255, 0.15);
            color: var(--accent-blue);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        /* Focus states for accessibility */
        button:focus-visible,
        .preset-btn:focus-visible,
        .control-btn:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            overflow-y: auto;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            font-size: 14px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            font-weight: 500;
            color: var(--accent-blue);
        }

        /* Transcript Panel */
        .transcript-panel {
            flex: 1;
            min-height: 0;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .transcript-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .transcript-header h3 {
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .transcript-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .transcript-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            text-align: center;
            gap: 12px;
        }

        /* Script Generator Section */
        .script-section {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 16px;
        }

        .script-input-row {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .script-input-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .script-input-label {
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .script-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 15px;
            font-family: inherit;
            resize: none;
            min-height: 48px;
        }

        .script-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .script-input::placeholder {
            color: var(--text-secondary);
        }

        .script-generate-btn {
            padding: 12px 24px;
            min-height: 48px;
            border: none;
            border-radius: 8px;
            background: var(--accent-blue);
            color: #000;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .script-generate-btn:hover:not(:disabled) {
            background: #00b8e0;
            transform: translateY(-1px);
        }

        .script-generate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Quick Prompt Buttons */
        .quick-prompts-container {
            margin-top: 12px;
        }

        .quick-prompts-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .quick-prompts-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .quick-prompt-btn {
            padding: 8px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .quick-prompt-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: var(--bg-primary);
        }

        .quick-prompt-btn:active {
            transform: scale(0.97);
        }

        /* Teleprompter Display */
        .teleprompter {
            margin-top: 16px;
            display: none;
        }

        .teleprompter.visible {
            display: block;
        }

        .teleprompter-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px 24px;
        }

        .teleprompter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .teleprompter-title {
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .teleprompter-actions {
            display: flex;
            gap: 8px;
        }

        .teleprompter-action-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .teleprompter-action-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .teleprompter-script {
            font-size: 22px;
            line-height: 1.6;
            color: var(--text-primary);
            font-weight: 500;
            padding: 16px 0;
        }

        .teleprompter-alternatives {
            border-top: 1px solid var(--border-color);
            padding-top: 12px;
            margin-top: 12px;
        }

        .alternatives-title {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .alternative-item {
            font-size: 14px;
            color: var(--text-secondary);
            padding: 8px 0;
            cursor: pointer;
            transition: color 0.2s;
        }

        .alternative-item:hover {
            color: var(--accent-blue);
        }

        .alternative-item::before {
            content: "‚Ä¢ ";
            color: var(--accent-blue);
        }

        /* Streaming cursor */
        .streaming-cursor {
            display: inline-block;
            width: 2px;
            height: 1em;
            background: var(--accent-blue);
            margin-left: 2px;
            animation: cursor-blink 1s infinite;
        }

        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Spin animation for loading */
        .animate-spin {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Flash animation for ready indicator */
        @keyframes flash-ready {
            0%, 100% {
                transform: scale(1);
                box-shadow: none;
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 12px var(--accent-green);
            }
        }

        /* Control Bar */
        .control-bar {
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        .control-btn {
            padding: 14px 28px;
            min-height: 48px;  /* Ëß∏ÊéßÁõÆÊ®ô 44px+ */
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        /* Realtime Preview (Web Speech) - Karaoke Style */
        .realtime-preview {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.05), rgba(0, 255, 136, 0.03));
            border-bottom: 1px solid var(--border-color);
            padding: 12px 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            flex-shrink: 0;
        }

        .preview-label {
            font-size: 12px;
            color: var(--accent-blue);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
            cursor: pointer;
            white-space: nowrap;
            padding-top: 4px;
        }

        .preview-label:hover {
            opacity: 0.8;
        }

        .preview-text {
            font-size: 18px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            direction: rtl;
            text-align: left;
            line-height: 1.4;
        }

        /* ÂÖßÈÉ®ÊñáÂ≠ó‰øùÊåÅ LTR Ê≠£Â∏∏Èñ±ËÆÄÈ†ÜÂ∫è */
        .preview-text-inner {
            direction: ltr;
            unicode-bidi: embed;
        }

        /* Â∑≤Á¢∫Ë™çÁöÑÊñáÂ≠ó - ËºÉÊöó */
        .preview-text .final-text {
            color: rgba(255, 255, 255, 0.5);
        }

        /* Ê≠£Âú®Ë™™ÁöÑÊñáÂ≠ó - Karaoke È´ò‰∫ÆÊïàÊûú */
        .preview-text .interim {
            color: #00ffcc;
            text-shadow: 0 0 8px rgba(0, 255, 204, 0.6), 0 0 16px rgba(0, 255, 204, 0.3);
            animation: karaoke-glow 1.5s ease-in-out infinite;
        }

        @keyframes karaoke-glow {
            0%, 100% {
                text-shadow: 0 0 8px rgba(0, 255, 204, 0.6), 0 0 16px rgba(0, 255, 204, 0.3);
            }
            50% {
                text-shadow: 0 0 12px rgba(0, 255, 204, 0.8), 0 0 24px rgba(0, 255, 204, 0.5);
            }
        }

        /* Toggle button for realtime preview */
        .preview-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .preview-toggle .toggle-icon {
            transition: transform 0.2s;
            font-size: 10px;
        }

        /* Â±ïÈñãÁãÄÊÖãÔºöÈ°ØÁ§∫ÂÆåÊï¥Â§öË°åÊñáÂ≠ó */
        .realtime-preview.expanded .preview-toggle .toggle-icon {
            transform: rotate(0deg);
        }

        .realtime-preview.expanded .preview-text {
            font-size: 20px;
            white-space: pre-wrap;
            word-break: break-word;
            direction: ltr;
            text-align: left;
            max-height: 180px;
            overflow-y: auto;
            line-height: 1.6;
            padding: 8px 0;
        }

        .realtime-preview.expanded .preview-text-inner {
            unicode-bidi: normal;
        }

        /* Êî∂ÂêàÁãÄÊÖãÔºöÂñÆË°åÈ°ØÁ§∫ÊúÄÂæåÊñáÂ≠ó */
        .realtime-preview:not(.expanded) .preview-toggle .toggle-icon {
            transform: rotate(-90deg);
        }

        .realtime-preview.stopped {
            background: var(--bg-tertiary);
        }

        .realtime-preview.stopped .preview-label {
            color: var(--text-secondary);
        }

        .realtime-preview.stopped .preview-text {
            color: var(--text-secondary);
        }

        .realtime-preview.stopped .preview-text .interim {
            color: var(--text-secondary);
            text-shadow: none;
            animation: none;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-start {
            background: var(--accent-blue);
            color: #000;
        }

        .btn-stop {
            background: var(--accent-red);
            color: #fff;
        }

        .btn-clear {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Log Panel (ÂèØÊî∂Âêà) */
        .log-panel-wrapper {
            margin-top: auto;
        }

        .log-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .log-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .log-toggle .chevron {
            margin-left: auto;
            transition: transform 0.2s;
        }

        .log-toggle.expanded .chevron {
            transform: rotate(180deg);
        }

        .log-panel {
            max-height: 150px;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 0 0 8px 8px;
            border: 1px solid var(--border-color);
            border-top: none;
            font-family: monospace;
            font-size: 12px;
            margin-top: -1px;
        }

        .log-panel.collapsed {
            display: none;
        }

        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .log-entry.event { color: var(--accent-blue); }
        .log-entry.success { color: var(--accent-green); }
        .log-entry.warn { color: var(--accent-yellow); }
        .log-entry.error { color: var(--accent-red); }

        /* Preset Selector */
        /* Accent Selector */
        .accent-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* Footer Credit */
        .footer-credit {
            text-align: center;
            padding: 16px;
            font-size: 11px;
            color: var(--text-secondary);
            opacity: 0.6;
            letter-spacing: 0.3px;
        }

        .footer-credit a {
            color: var(--text-secondary);
            text-decoration: none;
        }

        .footer-credit a:hover {
            color: var(--accent-blue);
        }

        .accent-row {
            display: flex;
            align-items: center;
        }

        .accent-label {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .accent-selects {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .accent-select-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 120px;
        }

        .accent-select-label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .accent-select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
        }

        .accent-select:hover {
            border-color: var(--accent-blue);
        }

        .accent-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .accent-hint {
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
        }

        .accent-hint-inline {
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
            margin-left: 8px;
            opacity: 0.7;
        }

        /* API Key Settings */
        .api-key-section {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .api-key-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
            padding: 4px 0;
        }

        .api-key-section.collapsed .api-key-header {
            margin-bottom: 0;
        }

        .api-key-section:not(.collapsed) .api-key-header {
            margin-bottom: 10px;
        }

        #apiKeyDetails {
            transition: all 0.2s ease;
        }

        .api-key-section.collapsed #apiKeyDetails {
            display: none;
        }

        .api-key-section.collapsed #apiKeyToggleIcon {
            transform: rotate(-90deg);
        }

        .api-key-desc {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .api-key-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }

        .api-key-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            font-family: monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .api-key-btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .api-key-btn.save {
            background: var(--accent-green);
            color: #000;
        }

        .api-key-btn.clear {
            background: var(--accent-red);
            color: #fff;
        }

        .api-key-btn:hover {
            opacity: 0.8;
        }

        .api-key-status-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .api-key-status {
            font-weight: 500;
        }

        .api-key-status.set {
            color: var(--accent-green);
        }

        .api-key-status.not-set {
            color: var(--accent-red);
        }

        .api-key-security-note {
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.4;
            padding: 8px;
            background: rgba(0, 212, 255, 0.05);
            border-radius: 4px;
            border-left: 2px solid var(--accent-blue);
        }

        /* Language Selector in Header */
        .header-lang-select {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
        }

        .header-lang-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .preset-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .preset-label {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .preset-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 8px 14px;
            min-height: 36px;  /* Ëß∏ÊéßÂèãÂ•Ω */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .preset-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-blue);
        }

        .preset-btn.active {
            background: var(--accent-blue);
            color: #000;
            border-color: var(--accent-blue);
            font-weight: 500;
        }

        /* ÈüøÊáâÂºèÔºöÊâãÊ©ü‰∏äÂè™È°ØÁ§∫3ÂÄã‰∏ªË¶ÅÈÅ∏È†Ö */
        @media (max-width: 480px) {
            .preset-btn[data-preset="ultra-fast"],
            .preset-btn[data-preset="conservative"] {
                display: none;
            }

            /* Mobile: API Key section more compact */
            .api-key-section {
                padding: 10px 12px;
            }

            .api-key-desc {
                font-size: 11px;
            }

            /* Mobile: Script input row stacks vertically */
            .script-input-row {
                flex-direction: column;
                align-items: stretch;
            }

            .script-input-wrapper {
                width: 100%;
            }

            .script-input-label {
                text-align: center;
                justify-content: center;
            }

            .script-generate-btn {
                width: 100%;
                justify-content: center;
                margin-top: 4px;
            }

            /* Mobile: Quick prompts scroll horizontally */
            .quick-prompts-grid {
                flex-wrap: nowrap;
                overflow-x: auto;
                padding-bottom: 8px;
                -webkit-overflow-scrolling: touch;
            }

            .quick-prompt-btn {
                flex-shrink: 0;
            }

            /* Mobile: Footer smaller */
            .footer-credit {
                padding: 12px;
                font-size: 10px;
            }
        }

        /* ============================================
         * Phase 1: Pre-Call Preparation Mode
         * ============================================ */

        .preparation-mode {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .preparation-mode.hidden {
            display: none;
        }

        /* Call mode container (transcript + quick bar shown during call) */
        .call-mode {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            gap: 20px;
        }

        .call-mode.active {
            display: flex;
        }

        /* Scenario Cards Grid */
        .scenario-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
        }

        .scenario-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 44px;
        }

        .scenario-card:hover {
            border-color: var(--accent-blue);
            background: var(--bg-tertiary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.15);
        }

        .scenario-card:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .scenario-card.selected {
            border-color: var(--accent-blue);
            background: rgba(0, 212, 255, 0.1);
        }

        .scenario-card-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: var(--bg-tertiary);
        }

        .scenario-card.selected .scenario-card-icon {
            background: rgba(0, 212, 255, 0.2);
        }

        .scenario-card-name {
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .scenario-card-vocab {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            word-break: break-word;
        }

        /* Section headers in preparation mode */
        .prep-section-title {
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        /* Saved Scripts List */
        .saved-scripts-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .saved-script-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .saved-script-item:hover {
            border-color: var(--accent-blue);
        }

        .saved-script-body {
            flex: 1;
            min-width: 0;
        }

        .saved-script-english {
            font-size: 14px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-script-chinese {
            font-size: 13px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }

        .saved-script-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
            display: flex;
            gap: 8px;
        }

        .saved-script-delete {
            padding: 8px;
            min-width: 36px;
            min-height: 36px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .saved-script-delete:hover {
            background: rgba(255, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .saved-script-delete:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .saved-scripts-empty {
            text-align: center;
            padding: 16px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Save as Quick Card button (in prep teleprompter) */
        .btn-save-card {
            padding: 10px 20px;
            min-height: 44px;
            border: 1px solid var(--accent-green);
            border-radius: 8px;
            background: rgba(0, 255, 136, 0.1);
            color: var(--accent-green);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-save-card:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .btn-save-card:focus-visible {
            outline: 2px solid var(--accent-green);
            outline-offset: 2px;
        }

        .btn-save-card:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Start Listening Button (in preparation mode) */
        .btn-start-listening {
            padding: 16px 32px;
            min-height: 52px;
            border: none;
            border-radius: 12px;
            background: var(--accent-blue);
            color: #000;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        .btn-start-listening:hover:not(:disabled) {
            background: #00b8e0;
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
        }

        .btn-start-listening:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .btn-start-listening:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ============================================
         * Phase 1: Quick Response Bar (during call) - Single Row
         * ============================================ */

        .quick-response-bar {
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 10px 16px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            overflow-x: auto;
        }

        .quick-response-divider {
            width: 1px;
            height: 28px;
            background: var(--border-color);
            flex-shrink: 0;
        }

        /* Prepared script card (compact) */
        .prepared-card {
            padding: 8px 12px;
            min-height: 40px;
            border: 1px solid var(--accent-blue);
            border-radius: 6px;
            background: rgba(0, 212, 255, 0.08);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            max-width: 160px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }

        .prepared-card:hover {
            background: rgba(0, 212, 255, 0.15);
        }

        .prepared-card:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .prepared-card-icon {
            flex-shrink: 0;
            color: var(--accent-blue);
        }

        /* Quick phrase buttons */
        .quick-phrase-btn {
            padding: 8px 12px;
            min-height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .quick-phrase-btn:hover {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.08);
        }

        .quick-phrase-btn:focus-visible {
            outline: 2px solid var(--accent-green);
            outline-offset: 2px;
        }

        /* Panic Button - Compact */
        .panic-btn {
            padding: 8px 14px;
            min-height: 40px;
            border: 2px solid var(--accent-red);
            border-radius: 6px;
            background: rgba(255, 68, 68, 0.1);
            color: var(--accent-red);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .panic-btn:hover {
            background: rgba(255, 68, 68, 0.2);
        }

        .panic-btn:focus-visible {
            outline: 2px solid var(--accent-red);
            outline-offset: 2px;
        }

        .panic-btn:active {
            transform: scale(0.98);
        }

        /* ============================================
         * Phase 1: Teleprompter Overlay
         * ============================================ */

        .teleprompter-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 24px;
        }

        .teleprompter-overlay.visible {
            display: flex;
        }

        .teleprompter-overlay-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .teleprompter-overlay-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .teleprompter-overlay-close:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .teleprompter-overlay-close:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .teleprompter-overlay-english {
            font-size: 24px;
            font-weight: 500;
            color: var(--text-primary);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .teleprompter-overlay-chinese {
            font-size: 18px;
            color: var(--accent-blue);
            line-height: 1.6;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .teleprompter-overlay-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Panic mode: show prepared scripts below stalling phrase */
        .teleprompter-overlay-scripts {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .teleprompter-overlay-scripts-title {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .teleprompter-overlay-script-item {
            padding: 10px 14px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-tertiary);
        }

        .teleprompter-overlay-script-item:hover {
            border-color: var(--accent-blue);
        }

        .teleprompter-overlay-script-item:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .teleprompter-overlay-script-item-en {
            font-size: 16px;
            color: var(--text-primary);
        }

        .teleprompter-overlay-script-item-zh {
            font-size: 14px;
            color: var(--accent-blue);
            margin-top: 4px;
        }

        /* Call Control Buttons (during call) */
        .btn-call-control {
            padding: 10px 18px;
            min-height: 44px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-call-control:hover {
            background: var(--bg-primary);
            border-color: var(--accent-blue);
        }

        .btn-call-control:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .btn-call-control.pause {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .btn-call-control.pause:hover {
            background: rgba(255, 170, 0, 0.1);
        }

        .btn-call-control.resume {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .btn-call-control.resume:hover {
            background: rgba(0, 255, 136, 0.1);
        }

        .btn-call-control.home {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }

        .btn-call-control.home:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        .btn-call-control.export {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .btn-call-control.export:hover {
            background: rgba(0, 170, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .btn-call-control.ptt {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .btn-call-control.ptt:hover {
            background: rgba(255, 170, 0, 0.1);
        }

        .btn-call-control.ptt:active,
        .btn-call-control.ptt.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: var(--accent-yellow);
            color: #fff;
        }

        /* Call header bar (during call) */
        .call-header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .call-header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .call-header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .call-timer {
            font-size: 14px;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        /* ============================================
         * Responsive: Mobile
         * ============================================ */

        @media (max-width: 480px) {
            .scenario-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .scenario-card {
                padding: 12px;
            }

            .scenario-card-vocab {
                display: none;
            }

            /* Call header compact on mobile */
            .call-header-bar {
                padding: 8px 12px;
            }

            .call-header-left {
                gap: 10px;
            }

            .call-header-right {
                gap: 6px;
            }

            .btn-call-control {
                padding: 8px 12px;
                min-height: 38px;
                font-size: 12px;
            }

            .btn-call-control svg {
                width: 12px;
                height: 12px;
            }

            /* Realtime preview compact */
            .realtime-preview {
                padding: 10px 12px;
            }

            .preview-label {
                font-size: 11px;
            }

            .preview-text {
                font-size: 16px;
            }

            .realtime-preview.expanded .preview-text {
                font-size: 18px;
                max-height: 120px;
            }

            /* Quick response bar compact */
            .quick-response-bar {
                padding: 8px 10px;
                gap: 6px;
            }

            .quick-phrase-btn {
                font-size: 11px;
                padding: 6px 8px;
                min-height: 36px;
            }

            .panic-btn {
                padding: 6px 10px;
                font-size: 12px;
                min-height: 36px;
            }

            .prepared-card {
                max-width: 120px;
                font-size: 11px;
                padding: 6px 10px;
                min-height: 36px;
            }

            .teleprompter-overlay {
                padding: 12px;
            }

            .teleprompter-overlay-content {
                padding: 20px;
            }

            .teleprompter-overlay-english {
                font-size: 20px;
            }

            .teleprompter-overlay-chinese {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-title">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" x2="12" y1="19" y2="22"></line>
            </svg>
            <span data-i18n="appTitle">Ëã±ÊñáÂ∞çË©±Âä©Êâã</span>
        </div>
        <div class="header-status">
            <select id="languageSelect" class="header-lang-select" onchange="changeLanguage(this.value)">
                <option value="zh-HK">ÁπÅÈ´î</option>
                <option value="zh-CN">ÁÆÄ‰Ωì</option>
                <option value="en">ENG</option>
            </select>
            <div class="status-badge disconnected" id="statusBadge">
                <span class="status-dot"></span>
                <span id="statusText" data-i18n="statusDisconnected">Êú™ÈÄ£Á∑ö</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <!-- ============================================
             PREPARATION MODE (shown when NOT connected)
             ============================================ -->
        <div class="preparation-mode" id="preparationMode">

            <!-- 0. API Key Settings (collapsible when set) -->
            <div class="api-key-section" id="apiKeySection">
                <div class="api-key-header" onclick="toggleApiKeyDetails()" style="cursor: pointer;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>
                    </svg>
                    <span data-i18n="apiKeySettings">OpenAI API Key</span>
                    <span id="apiKeyStatusText" class="api-key-status not-set" data-i18n="apiKeyNotSet">Êú™Ë®≠ÂÆö</span>
                    <svg id="apiKeyToggleIcon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: auto; transition: transform 0.2s;">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div id="apiKeyDetails">
                    <div class="api-key-desc" data-i18n="apiKeyDesc">
                        ÁøªË≠ØÂäüËÉΩÈúÄË¶Å OpenAI API KeyÔºàÂèØÂú® platform.openai.com ÂèñÂæóÔºâ
                    </div>
                    <div class="api-key-row">
                        <input type="password" id="apiKeyInput" class="api-key-input" data-i18n-placeholder="apiKeyPlaceholder" placeholder="sk-...">
                        <button id="apiKeySaveBtn" class="api-key-btn save" onclick="saveApiKey()" data-i18n="apiKeySave">ÂÑ≤Â≠ò</button>
                        <button id="apiKeyClearBtn" class="api-key-btn clear" onclick="clearApiKey()" style="display:none" data-i18n="apiKeyClear">Ê∏ÖÈô§</button>
                    </div>
                    <div class="api-key-security-note" data-i18n="apiKeySecurityNote">
                        üîí ÂÆâÂÖ®ÊèêÁ§∫ÔºöAPI Key Âè™ÊúÉÂÑ≤Â≠òÂú®‰Ω†ÁöÑÁÄèË¶ΩÂô®Êú¨Ê©ü (localStorage)ÔºåÊàëÂÄë‰∏çÊúÉÊî∂ÈõÜÊàñÂÑ≤Â≠ò‰Ω†ÁöÑ API Key„ÄÇ
                    </div>
                </div>
            </div>

            <!-- 1. Scenario Selector -->
            <div>
                <div class="prep-section-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect>
                        <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>
                    </svg>
                    <span data-i18n="selectScenario">ÈÅ∏ÊìáÂ†¥ÊôØ</span>
                </div>
                <div class="scenario-grid" id="scenarioGrid">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- 2. Script Generator (reused, moved into prep) -->
            <div>
                <div class="prep-section-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"></path>
                    </svg>
                    <span data-i18n="prepareScript">Ê∫ñÂÇôË¨õÁ®ø</span>
                </div>
                <div class="script-input-row">
                    <div class="script-input-wrapper">
                        <label class="script-input-label" data-i18n="scriptInputLabel">
                            ÊàëÊÉ≥Ë™™...Ôºà‰∏≠ÊñáÔºâ
                        </label>
                        <textarea
                            class="script-input"
                            id="scriptInput"
                            data-i18n-placeholder="scriptInputPlaceholder"
                            placeholder="Ëº∏ÂÖ•‰Ω†ÊÉ≥Ë™™ÁöÑË©±Ôºå‰æãÂ¶ÇÔºöÊàëÊÉ≥Âïè‰∏Ä‰∏ãÈÄôÁ≠ÜË≤ªÁî®ÊòØ‰ªÄÈ∫º"
                            rows="1"
                            onkeydown="handleScriptInputKeydown(event)"
                        ></textarea>
                    </div>
                    <button class="script-generate-btn" id="btnGenerate" onclick="generateScript()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m5 12 7-7 7 7"></path>
                            <path d="M12 19V5"></path>
                        </svg>
                        <span data-i18n="generateScript">ÁîüÊàêË¨õÁ®ø</span>
                    </button>
                </div>

                <!-- Quick Prompt Buttons -->
                <div class="quick-prompts-container" id="quickPromptsContainer">
                    <div class="quick-prompts-label">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                        </svg>
                        <span data-i18n="quickPrompts">Âø´ÈÄüÈÅ∏ÊìáÂ∏∏Áî®ÁõÆÁöÑÔºö</span>
                    </div>
                    <div class="quick-prompts-grid" id="quickPromptsGrid">
                        <!-- Populated by JavaScript based on selected scenario -->
                    </div>
                </div>

                <!-- Teleprompter Display (in prep mode) -->
                <div class="teleprompter" id="teleprompter">
                    <div class="teleprompter-card">
                        <div class="teleprompter-header">
                            <span class="teleprompter-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                                <span data-i18n="yourScript">‰Ω†ÁöÑË¨õÁ®ø</span>
                            </span>
                            <div class="teleprompter-actions">
                                <button class="teleprompter-action-btn" onclick="copyScript()">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect>
                                        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path>
                                    </svg>
                                    <span data-i18n="copy">Ë§áË£Ω</span>
                                </button>
                                <button class="teleprompter-action-btn" onclick="regenerateScript()">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                                        <path d="M3 3v5h5"></path>
                                        <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
                                        <path d="M16 16h5v5"></path>
                                    </svg>
                                    <span data-i18n="regenerate">ÈáçÊñ∞ÁîüÊàê</span>
                                </button>
                                <button class="btn-save-card" id="btnSaveCard" onclick="saveAsQuickCard()">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                        <polyline points="7 3 7 8 15 8"></polyline>
                                    </svg>
                                    <span data-i18n="saveAsCard">ÂÑ≤Â≠òÁÇ∫Âø´Êç∑Âç°Áâá</span>
                                </button>
                            </div>
                        </div>
                        <div class="teleprompter-script" id="scriptOutput">
                            <!-- Generated script will appear here -->
                        </div>
                        <div class="teleprompter-alternatives" id="alternativesSection" style="display:none;">
                            <div class="alternatives-title" data-i18n="otherWays">ÂÖ∂‰ªñË™™Ê≥ïÔºö</div>
                            <div id="alternativesList">
                                <!-- Alternatives will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3. Saved Scripts List -->
            <div>
                <div class="prep-section-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    <span data-i18n="savedScripts">Â∑≤ÂÑ≤Â≠òÁöÑË¨õÁ®ø</span>
                </div>
                <div class="saved-scripts-list" id="savedScriptsList">
                    <div class="saved-scripts-empty" id="savedScriptsEmpty" data-i18n="noSavedScripts">Â∞öÊú™ÂÑ≤Â≠ò‰ªª‰ΩïË¨õÁ®ø</div>
                </div>
            </div>

            <!-- Accent Selector (English recognition accent) -->
            <div class="accent-selector">
                <div class="accent-row">
                    <span class="accent-label">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" x2="12" y1="19" y2="22"></line>
                        </svg>
                        <span data-i18n="accentRecognition">Ëã±Ë™ûÂè£Èü≥Ë≠òÂà•Ôºö</span>
                        <span class="accent-hint-inline" data-i18n="accentHint">Êåâ‰Ωè„ÄåÊàëÂú®Ë™™Ë©±„ÄçÊôÇÊúÉËá™ÂãïÂàáÊèõ</span>
                    </span>
                </div>
                <div class="accent-selects">
                    <div class="accent-select-group">
                        <label class="accent-select-label" data-i18n="otherPartyAccent">Â∞çÊñπÂè£Èü≥</label>
                        <select id="accentThem" class="accent-select" onchange="saveAccentSettings()">
                            <!-- Options populated by JS -->
                        </select>
                    </div>
                    <div class="accent-select-group">
                        <label class="accent-select-label" data-i18n="myAccent">ÊàëÁöÑÂè£Èü≥</label>
                        <select id="accentMe" class="accent-select" onchange="saveAccentSettings()">
                            <!-- Options populated by JS -->
                        </select>
                    </div>
                </div>
            </div>

            <!-- Preset Selector (in prep mode) -->
            <div class="preset-selector">
                <span class="preset-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                    <span data-i18n="translationSpeed">ÁøªË≠ØÈÄüÂ∫¶Ôºö</span>
                </span>
                <div class="preset-buttons" id="presetButtons">
                    <button class="preset-btn" data-preset="ultra-fast" data-i18n="speedUltraFast">Ê•µÈÄü</button>
                    <button class="preset-btn active" data-preset="fast" data-i18n="speedFast">Âø´ÈÄü</button>
                    <button class="preset-btn" data-preset="balanced" data-i18n="speedBalanced">Âπ≥Ë°°</button>
                    <button class="preset-btn" data-preset="stable" data-i18n="speedStable">Á©©ÂÆö</button>
                    <button class="preset-btn" data-preset="conservative" data-i18n="speedConservative">‰øùÂÆà</button>
                </div>
            </div>

            <!-- 4. Start Listening Button -->
            <button class="btn-start-listening" id="btnStartListening" onclick="startListening()">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" x2="12" y1="19" y2="22"></line>
                </svg>
                <span data-i18n="startListening">ÈñãÂßãËÅÜËÅΩ</span>
            </button>
        </div>

        <!-- ============================================
             CALL MODE (shown when connected)
             ============================================ -->
        <div class="call-mode" id="callMode">

            <!-- Call header: stats + timer + controls -->
            <div class="call-header-bar">
                <div class="call-header-left">
                    <div class="stat-item">
                        <span class="stat-label">Â∑≤ÁøªË≠Ø:</span>
                        <span class="stat-value" id="doneCount">0</span>
                        <span class="stat-label">ÊÆµ</span>
                    </div>
                    <div class="call-timer" id="callTimer">00:00</div>
                </div>
                <div class="call-header-right">
                    <button class="btn-call-control ptt" id="btnPTT"
                            onmousedown="pttStart()" onmouseup="pttEnd()" onmouseleave="pttEnd()"
                            ontouchstart="pttStart()" ontouchend="pttEnd()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" x2="12" y1="19" y2="22"></line>
                        </svg>
                        <span data-i18n="iAmSpeaking">ÊàëË¨õÁ∑äÂò¢</span>
                    </button>
                    <button class="btn-call-control pause" id="btnPause" onclick="pauseListening()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <rect x="6" y="4" width="4" height="16" rx="1"></rect>
                            <rect x="14" y="4" width="4" height="16" rx="1"></rect>
                        </svg>
                        <span data-i18n="pause">Êö´ÂÅú</span>
                    </button>
                    <button class="btn-call-control resume" id="btnResume" onclick="resumeListening()" style="display:none;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        <span data-i18n="resume">ÁπºÁ∫å</span>
                    </button>
                    <button class="btn-call-control home" id="btnHome" onclick="goToHome()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                            <polyline points="9 22 9 12 15 12 15 22"></polyline>
                        </svg>
                        È¶ñÈ†Å
                    </button>
                    <button class="btn-call-control export" id="btnExport" onclick="exportTranscript()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" x2="12" y1="15" y2="3"></line>
                        </svg>
                        ÂåØÂá∫
                    </button>
                </div>
            </div>

            <!-- Hidden stats -->
            <div style="display:none;">
                <span id="segmentCount">0</span>
                <span id="activeCount">0</span>
                <span id="queueCount">0</span>
            </div>

            <!-- Realtime English Preview Container (single line, inserted dynamically) -->
            <div id="realtimePreviewContainer"></div>

            <!-- Transcript Panel -->
            <div class="transcript-panel">
                <div class="transcript-header">
                    <h3>
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        <span>Âç≥ÊôÇÁøªË≠Ø</span>
                    </h3>
                </div>
                <div class="transcript-content" id="transcriptContent">
                    <div class="transcript-empty" id="transcriptEmpty">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity:0.4;">
                            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" x2="12" y1="19" y2="22"></line>
                        </svg>
                        <div style="font-size:16px;font-weight:500;margin-top:12px;">ËÅÜËÅΩ‰∏≠...</div>
                        <div style="font-size:14px;color:var(--text-secondary);max-width:300px;line-height:1.6;">
                            Â∞áÊâãÊ©üÈÄöË©±ÈñãÂïüÊì¥Èü≥Ôºå<br>Â∞çÊñπË™™ÁöÑËã±ÊñáÊúÉÂç≥ÊôÇÁøªË≠ØÊàê‰∏≠Êñá
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hidden Log Panel for debugging (not visible in call mode) -->
            <div class="log-panel collapsed" id="logPanel" style="display:none;">
                <div style="color:var(--text-secondary);">Á≠âÂæÖÊó•Ë™å...</div>
            </div>
        </div>
    </main>

    <!-- Quick Response Bar (shown DURING call) - Single Row Layout -->
    <div class="quick-response-bar" id="quickResponseBar" style="display:none;">
        <!-- Prepared script cards (from localStorage) -->
        <div id="preparedCardsRow" style="display:contents;"></div>
        <!-- Divider between cards and phrases (hidden if no cards) -->
        <div class="quick-response-divider" id="quickResponseDivider" style="display:none;"></div>
        <!-- Quick phrases -->
        <button class="quick-phrase-btn" onclick="showQuickPhrase(0)" title="Ë´ãÂÜçË™™‰∏ÄÊ¨°">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                <path d="M3 3v5h5"></path>
            </svg>
            ÂÜçË™™‰∏ÄÊ¨°
        </button>
        <button class="quick-phrase-btn" onclick="showQuickPhrase(1)" title="Ë´ãÊÖ¢ÈªûË™™">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            ÊÖ¢ÈªûË™™
        </button>
        <button class="quick-phrase-btn" onclick="showQuickPhrase(2)" title="ÊàëÁ¢∫Ë™ç‰∏Ä‰∏ã">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            Á¢∫Ë™ç‰∏Ä‰∏ã
        </button>
        <button class="quick-phrase-btn" onclick="showQuickPhrase(3)" title="Ë¨ùË¨ùÂÜçË¶ã">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4.5 21.5l6-6M9 10.5L4.5 15m0 0l6 6"></path>
            </svg>
            Ë¨ùË¨ù
        </button>
        <!-- Panic Button -->
        <button class="panic-btn" id="panicBtn" onclick="triggerPanic()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                <line x1="12" y1="9" x2="12" y2="13"></line>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            Ê±ÇÂä©
        </button>
    </div>

    <!-- Teleprompter Overlay (for quick phrases, panic, prepared cards) -->
    <div class="teleprompter-overlay" id="teleprompterOverlay" onclick="closeTeleprompterOverlay(event)">
        <div class="teleprompter-overlay-content" onclick="event.stopPropagation()">
            <button class="teleprompter-overlay-close" onclick="closeTeleprompterOverlay()" aria-label="ÈóúÈñâ">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <div>
                <div class="teleprompter-overlay-label" id="overlayLabel">English</div>
                <div class="teleprompter-overlay-english" id="overlayEnglish"></div>
            </div>
            <div class="teleprompter-overlay-chinese" id="overlayChinese"></div>
            <!-- Prepared scripts shown in panic mode -->
            <div class="teleprompter-overlay-scripts" id="overlayScripts" style="display:none;">
                <div class="teleprompter-overlay-scripts-title">‰Ω†Ê∫ñÂÇôÂ•ΩÁöÑË¨õÁ®øÔºö</div>
                <div id="overlayScriptsList"></div>
            </div>
        </div>
    </div>

    <!-- Load modules -->
    <script src="/static/segment_store.js"></script>
    <script src="/static/realtime_event_handler.js"></script>
    <script src="/static/segment_renderer.js"></script>
    <script src="/static/audio_capture.js"></script>
    <script src="/static/webspeech_realtime.js"></script>
    <script src="/static/smart_segmenter.js"></script>
    <script src="/static/translation_validator.js"></script>

    <script>
        // ============================================
        // ECA - English Conversation Assistant
        // Ëã±ÊñáÂ∞çË©±Âä©Êâã - Âç≥ÊôÇÁøªË≠ØÂ∑•ÂÖ∑
        // ============================================

        // ============================================
        // Localization System (Âú∞ÂçÄÂåñÁ≥ªÁµ±)
        // Supports: zh-HK (ÁπÅÈ´î), zh-CN (ÁÆÄ‰Ωì), en
        // ============================================

        const TRANSLATIONS = {
            'zh-HK': {
                appTitle: 'Ëã±ÊñáÂ∞çË©±Âä©Êâã',
                appSubtitle: 'Âç≥ÊôÇËã±Ë≠Ø‰∏≠ÁøªË≠Ø',
                statusConnected: 'ÁøªË≠Ø‰∏≠',
                statusDisconnected: 'Êú™ÈÄ£Á∑ö',
                statusConnecting: 'ÈÄ£Á∑ö‰∏≠...',
                statusPaused: 'Â∑≤Êö´ÂÅú',
                statusSpeaking: 'ÊàëÂú®Ë™™Ë©±',
                selectScenario: 'ÈÅ∏ÊìáÂ†¥ÊôØ',
                prepareScript: 'Ê∫ñÂÇôË¨õÁ®ø',
                savedScripts: 'Â∑≤ÂÑ≤Â≠òÁöÑË¨õÁ®ø',
                noSavedScripts: 'Â∞öÊú™ÂÑ≤Â≠ò‰ªª‰ΩïË¨õÁ®ø',
                scriptInputLabel: 'ÊàëÊÉ≥Ë™™...Ôºà‰∏≠ÊñáÔºâ',
                scriptInputPlaceholder: 'Ëº∏ÂÖ•‰Ω†ÊÉ≥Ë™™ÁöÑË©±Ôºå‰æãÂ¶ÇÔºöÊàëÊÉ≥Ë©¢ÂïèÈÄôÁ≠ÜË≤ªÁî®ÊòØ‰ªÄÈ∫º',
                generateScript: 'ÁîüÊàêË¨õÁ®ø',
                quickPrompts: 'Âø´ÈÄüÈÅ∏ÊìáÂ∏∏Áî®ÁõÆÁöÑÔºö',
                yourScript: '‰Ω†ÁöÑË¨õÁ®ø',
                copy: 'Ë§áË£Ω',
                regenerate: 'ÈáçÊñ∞ÁîüÊàê',
                saveAsCard: 'ÂÑ≤Â≠òÁÇ∫Âø´Êç∑Âç°Áâá',
                otherWays: 'ÂÖ∂‰ªñË™™Ê≥ïÔºö',
                accentRecognition: 'Ëã±Ë™ûÂè£Èü≥Ë≠òÂà•Ôºö',
                otherPartyAccent: 'Â∞çÊñπÂè£Èü≥',
                myAccent: 'ÊàëÁöÑÂè£Èü≥',
                accentHint: 'ÔºàÊåâ‰Ωè Spacebar ÊôÇËá™ÂãïÂàáÊèõÔºâ',
                translationSpeed: 'ÁøªË≠ØÈÄüÂ∫¶Ôºö',
                accentUS: 'ÁæéÂºè (US)',
                accentUK: 'Ëã±Âºè (UK)',
                accentAU: 'Êæ≥Ê¥≤ (AU)',
                accentIN: 'Âç∞Â∫¶ (IN)',
                accentAsia: '‰∫ûÊ¥≤Âè£Èü≥ (Á≤µ/ÊôÆ)',
                accentNZ: 'Á¥êË•øËò≠ (NZ)',
                accentCA: 'Âä†ÊãøÂ§ß (CA)',
                accentZA: 'ÂçóÈùû (ZA)',
                accentPH: 'Ëè≤ÂæãË≥ì (PH)',
                speedUltraFast: 'Ê•µÈÄü',
                speedFast: 'Âø´ÈÄü',
                speedBalanced: 'Âπ≥Ë°°',
                speedStable: 'Á©©ÂÆö',
                speedConservative: '‰øùÂÆà',
                startListening: 'ÈñãÂßãËÅÜËÅΩ',
                stopListening: 'ÁµêÊùüÈÄöË©±',
                iAmSpeaking: 'ÊàëÂú®Ë™™Ë©±',
                pause: 'Êö´ÂÅú',
                resume: 'ÁπºÁ∫å',
                translated: 'Â∑≤ÁøªË≠ØÔºö',
                segments: 'ÊÆµ',
                quickResponse: 'Âø´ÈÄüÂõûÊáâ',
                endCall: 'ÁµêÊùüÈÄöË©±',
                emptyTranscript: 'Â∞çË©±ÂÖßÂÆπÂ∞áÊúÉÂú®Ê≠§È°ØÁ§∫',
                speakerThem: 'Â∞çÊñπ',
                speakerMe: 'Êàë',
                apiKeySettings: 'OpenAI API Key',
                apiKeyDesc: 'ÁøªË≠ØÂäüËÉΩÈúÄË¶Å OpenAI API KeyÔºàÂèØÂú® platform.openai.com ÂèñÂæóÔºâ',
                apiKeyPlaceholder: 'sk-...',
                apiKeySave: 'ÂÑ≤Â≠ò',
                apiKeyClear: 'Ê∏ÖÈô§',
                apiKeyStatus: 'ÁãÄÊÖãÔºö',
                apiKeySet: 'Â∑≤Ë®≠ÂÆö ‚úì',
                apiKeyNotSet: 'Êú™Ë®≠ÂÆö',
                apiKeySecurityNote: 'üîí ÂÆâÂÖ®ÊèêÁ§∫ÔºöAPI Key Âè™ÊúÉÂÑ≤Â≠òÂú®‰Ω†ÁöÑÁÄèË¶ΩÂô®Êú¨Ê©ü (localStorage)ÔºåÊàëÂÄë‰∏çÊúÉÊî∂ÈõÜÊàñÂÑ≤Â≠ò‰Ω†ÁöÑ API Key„ÄÇ',
                apiKeyRequired: '‚ö†Ô∏è ÈúÄË¶ÅÊèê‰æõ OpenAI API Key ÊâçËÉΩ‰ΩøÁî®ÁøªË≠ØÂäüËÉΩ',
                apiKeyInvalidFormat: 'API Key Ê†ºÂºèÈåØË™§ÔºåÈúÄ‰ª•„Äåsk-„ÄçÈñãÈ†≠',
                apiKeySaveFailed: 'API Key ÂÑ≤Â≠òÂ§±Êïó',
                noExportData: 'ÁõÆÂâçÊ≤íÊúâÁøªË≠ØË®òÈåÑÂèØ‰ª•ÂåØÂá∫',
                language: 'Ë™ûË®Ä',
                langZhHK: 'ÁπÅÈ´î',
                langZhCN: 'ÁÆÄ‰Ωì',
                langEn: 'ENG',
                scenarioGeneral: '‰∏ÄËà¨Â∞çË©±',
                scenarioBank: 'ÈäÄË°å/ÈáëËûç',
                scenarioNHS: 'ÈÜ´ÁôÇ/NHS',
                scenarioUtilities: 'Ê∞¥ÈõªÁÖ§',
                scenarioInsurance: '‰øùÈö™',
                scenarioGovernment: 'ÊîøÂ∫úÈÉ®ÈñÄ',
                loading: 'ËºâÂÖ•‰∏≠...',
                error: 'ÈåØË™§',
                success: 'ÊàêÂäü',
                warning: 'Ë≠¶Âëä'
            },
            'zh-CN': {
                appTitle: 'Ëã±ÊñáÂØπËØùÂä©Êâã',
                appSubtitle: 'ÂÆûÊó∂Ëã±ËØë‰∏≠ÁøªËØë',
                statusConnected: 'ÁøªËØë‰∏≠',
                statusDisconnected: 'Êú™ËøûÊé•',
                statusConnecting: 'ËøûÊé•‰∏≠...',
                statusPaused: 'Â∑≤ÊöÇÂÅú',
                statusSpeaking: 'ÊàëÂú®ËØ¥ËØù',
                selectScenario: 'ÈÄâÊã©Âú∫ÊôØ',
                prepareScript: 'ÂáÜÂ§áËÆ≤Á®ø',
                savedScripts: 'Â∑≤‰øùÂ≠òÁöÑËÆ≤Á®ø',
                noSavedScripts: 'Â∞öÊú™‰øùÂ≠ò‰ªª‰ΩïËÆ≤Á®ø',
                scriptInputLabel: 'ÊàëÊÉ≥ËØ¥...Ôºà‰∏≠ÊñáÔºâ',
                scriptInputPlaceholder: 'ËæìÂÖ•‰Ω†ÊÉ≥ËØ¥ÁöÑËØùÔºå‰æãÂ¶ÇÔºöÊàëÊÉ≥ÈóÆ‰∏Ä‰∏ãËøôÁ¨îË¥πÁî®ÊòØ‰ªÄ‰πà',
                generateScript: 'ÁîüÊàêËÆ≤Á®ø',
                quickPrompts: 'Âø´ÈÄüÈÄâÊã©Â∏∏Áî®ÁõÆÁöÑÔºö',
                yourScript: '‰Ω†ÁöÑËÆ≤Á®ø',
                copy: 'Â§çÂà∂',
                regenerate: 'ÈáçÊñ∞ÁîüÊàê',
                saveAsCard: '‰øùÂ≠ò‰∏∫Âø´Êç∑Âç°Áâá',
                otherWays: 'ÂÖ∂‰ªñËØ¥Ê≥ïÔºö',
                accentRecognition: 'Ëã±ËØ≠Âè£Èü≥ËØÜÂà´Ôºö',
                otherPartyAccent: 'ÂØπÊñπÂè£Èü≥',
                myAccent: 'ÊàëÁöÑÂè£Èü≥',
                accentHint: 'ÔºàÊåâ‰Ωè Spacebar Êó∂Ëá™Âä®ÂàáÊç¢Ôºâ',
                translationSpeed: 'ÁøªËØëÈÄüÂ∫¶Ôºö',
                accentUS: 'ÁæéÂºè (US)',
                accentUK: 'Ëã±Âºè (UK)',
                accentAU: 'Êæ≥Ê¥≤ (AU)',
                accentIN: 'Âç∞Â∫¶ (IN)',
                accentAsia: '‰∫öÊ¥≤Âè£Èü≥ (Á≤§/ÊôÆ)',
                accentNZ: 'Êñ∞Ë•øÂÖ∞ (NZ)',
                accentCA: 'Âä†ÊãøÂ§ß (CA)',
                accentZA: 'ÂçóÈùû (ZA)',
                accentPH: 'Ëè≤ÂæãÂÆæ (PH)',
                speedUltraFast: 'ÊûÅÈÄü',
                speedFast: 'Âø´ÈÄü',
                speedBalanced: 'Âπ≥Ë°°',
                speedStable: 'Á®≥ÂÆö',
                speedConservative: '‰øùÂÆà',
                startListening: 'ÂºÄÂßãËÅÜÂê¨',
                stopListening: 'ÁªìÊùüÈÄöËØù',
                iAmSpeaking: 'ÊàëÂú®ËØ¥ËØù',
                pause: 'ÊöÇÂÅú',
                resume: 'ÁªßÁª≠',
                translated: 'Â∑≤ÁøªËØëÔºö',
                segments: 'ÊÆµ',
                quickResponse: 'Âø´ÈÄüÂõûÂ∫î',
                endCall: 'ÁªìÊùüÈÄöËØù',
                emptyTranscript: 'ÂØπËØùÂÜÖÂÆπÂ∞Ü‰ºöÂú®ËøôÈáåÊòæÁ§∫',
                speakerThem: 'ÂØπÊñπ',
                speakerMe: 'Êàë',
                apiKeySettings: 'OpenAI API Key',
                apiKeyDesc: 'ÁøªËØëÂäüËÉΩÈúÄË¶Å OpenAI API KeyÔºàÂèØÂú® platform.openai.com Ëé∑ÂèñÔºâ',
                apiKeyPlaceholder: 'sk-...',
                apiKeySave: '‰øùÂ≠ò',
                apiKeyClear: 'Ê∏ÖÈô§',
                apiKeyStatus: 'Áä∂ÊÄÅÔºö',
                apiKeySet: 'Â∑≤ËÆæÁΩÆ ‚úì',
                apiKeyNotSet: 'Êú™ËÆæÁΩÆ',
                apiKeySecurityNote: 'üîí ÂÆâÂÖ®ÊèêÁ§∫ÔºöAPI Key Âè™‰ºöÂ≠òÂÇ®Âú®ÊÇ®ÁöÑÊµèËßàÂô®Êú¨Âú∞ (localStorage)ÔºåÊàë‰ª¨‰∏ç‰ºöÊî∂ÈõÜÊàñÂ≠òÂÇ®ÊÇ®ÁöÑ API Key„ÄÇ',
                apiKeyRequired: '‚ö†Ô∏è ÈúÄË¶ÅÊèê‰æõ OpenAI API Key ÊâçËÉΩ‰ΩøÁî®ÁøªËØëÂäüËÉΩ',
                apiKeyInvalidFormat: 'API Key Ê†ºÂºèÈîôËØØÔºåÈúÄ‰ª•„Äåsk-„ÄçÂºÄÂ§¥',
                apiKeySaveFailed: 'API Key ‰øùÂ≠òÂ§±Ë¥•',
                noExportData: 'ÁõÆÂâçÊ≤°ÊúâÁøªËØëËÆ∞ÂΩïÂèØ‰ª•ÂØºÂá∫',
                language: 'ËØ≠Ë®Ä',
                langZhHK: 'ÁπÅÈ´î',
                langZhCN: 'ÁÆÄ‰Ωì',
                langEn: 'ENG',
                scenarioGeneral: '‰∏ÄËà¨ÂØπËØù',
                scenarioBank: 'Èì∂Ë°å/ÈáëËûç',
                scenarioNHS: 'ÂåªÁñó/NHS',
                scenarioUtilities: 'Ê∞¥ÁîµÁáÉÊ∞î',
                scenarioInsurance: '‰øùÈô©',
                scenarioGovernment: 'ÊîøÂ∫úÈÉ®Èó®',
                loading: 'Âä†ËΩΩ‰∏≠...',
                error: 'ÈîôËØØ',
                success: 'ÊàêÂäü',
                warning: 'Ë≠¶Âëä'
            },
            'en': {
                appTitle: 'English Conversation Assistant',
                appSubtitle: 'Real-time English to Chinese Translation',
                statusConnected: 'Translating',
                statusDisconnected: 'Disconnected',
                statusConnecting: 'Connecting...',
                statusPaused: 'Paused',
                statusSpeaking: 'I am speaking',
                selectScenario: 'Select Scenario',
                prepareScript: 'Prepare Script',
                savedScripts: 'Saved Scripts',
                noSavedScripts: 'No saved scripts yet',
                scriptInputLabel: 'I want to say... (Chinese)',
                scriptInputPlaceholder: 'Enter what you want to say',
                generateScript: 'Generate Script',
                quickPrompts: 'Quick select common purposes:',
                yourScript: 'Your Script',
                copy: 'Copy',
                regenerate: 'Regenerate',
                saveAsCard: 'Save as Quick Card',
                otherWays: 'Alternative phrases:',
                accentRecognition: 'English Accent Recognition:',
                otherPartyAccent: "Other Party's Accent",
                myAccent: 'My Accent',
                accentHint: '(Spacebar toggles accent)',
                translationSpeed: 'Translation Speed:',
                accentUS: 'American (US)',
                accentUK: 'British (UK)',
                accentAU: 'Australian (AU)',
                accentIN: 'Indian (IN)',
                accentAsia: 'Asian Accent (Canto/Mando)',
                accentNZ: 'New Zealand (NZ)',
                accentCA: 'Canadian (CA)',
                accentZA: 'South African (ZA)',
                accentPH: 'Filipino (PH)',
                speedUltraFast: 'Ultra Fast',
                speedFast: 'Fast',
                speedBalanced: 'Balanced',
                speedStable: 'Stable',
                speedConservative: 'Conservative',
                startListening: 'Start Listening',
                stopListening: 'End Call',
                iAmSpeaking: 'I am speaking',
                pause: 'Pause',
                resume: 'Resume',
                translated: 'Translated:',
                segments: 'segments',
                quickResponse: 'Quick Response',
                endCall: 'End Call',
                emptyTranscript: 'Conversation will appear here',
                speakerThem: 'Them',
                speakerMe: 'Me',
                apiKeySettings: 'OpenAI API Key',
                apiKeyDesc: 'Translation requires an OpenAI API Key (get one at platform.openai.com)',
                apiKeyPlaceholder: 'sk-...',
                apiKeySave: 'Save',
                apiKeyClear: 'Clear',
                apiKeyStatus: 'Status:',
                apiKeySet: 'Set ‚úì',
                apiKeyNotSet: 'Not set',
                apiKeySecurityNote: "üîí Security: API Key is stored only in your browser's localStorage. We do not collect or store your API Key.",
                apiKeyRequired: '‚ö†Ô∏è OpenAI API Key required for translation',
                apiKeyInvalidFormat: 'Invalid API Key format. Should start with "sk-"',
                apiKeySaveFailed: 'Failed to save API Key',
                noExportData: 'No translation records to export',
                language: 'Language',
                langZhHK: 'ÁπÅÈ´î',
                langZhCN: 'ÁÆÄ‰Ωì',
                langEn: 'ENG',
                scenarioGeneral: 'General',
                scenarioBank: 'Banking',
                scenarioNHS: 'Healthcare/NHS',
                scenarioUtilities: 'Utilities',
                scenarioInsurance: 'Insurance',
                scenarioGovernment: 'Government',
                loading: 'Loading...',
                error: 'Error',
                success: 'Success',
                warning: 'Warning'
            }
        };

        let currentLanguage = 'zh-HK';
        const LANGUAGE_STORAGE_KEY = 'eca_language';
        const API_KEY_STORAGE_KEY = 'eca_openai_api_key';

        function t(key) {
            return (TRANSLATIONS[currentLanguage] || TRANSLATIONS['zh-HK'])[key] || key;
        }

        function loadLanguagePreference() {
            try {
                const saved = localStorage.getItem(LANGUAGE_STORAGE_KEY);
                if (saved && TRANSLATIONS[saved]) currentLanguage = saved;
            } catch (e) {}
            console.log(`[i18n] Language: ${currentLanguage}`);
        }

        function saveLanguagePreference(lang) {
            if (!TRANSLATIONS[lang]) return;
            currentLanguage = lang;
            try { localStorage.setItem(LANGUAGE_STORAGE_KEY, lang); } catch (e) {}
        }

        function updateUILanguage() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (key) el.textContent = t(key);
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (key) el.placeholder = t(key);
            });
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                if (key) el.title = t(key);
            });
            updateAccentSelectOptions();
            const langSelect = document.getElementById('languageSelect');
            if (langSelect) langSelect.value = currentLanguage;
            document.title = `${t('appTitle')} - English Conversation Assistant`;
        }

        function updateAccentSelectOptions() {
            // ‰ΩøÁî®Èô£ÂàóÂÖÅË®±Â§öÂÄãÈÅ∏È†ÖÊò†Â∞ÑÂà∞Áõ∏ÂêåÁöÑË™ûË®Ä‰ª£Á¢º
            const opts = [
                { value: 'en-GB', labelKey: 'accentUK' },
                { value: 'en-US', labelKey: 'accentUS' },
                { value: 'en-AU', labelKey: 'accentAU' },
                { value: 'en-IN', labelKey: 'accentAsia' },  // ‰∫ûÊ¥≤Âè£Èü≥ÊîæÂâçÈù¢ÔºàÊé®Ëñ¶Ôºâ
                { value: 'en-IN', labelKey: 'accentIN' },    // ‰øùÁïôÂç∞Â∫¶ÈÅ∏È†Ö
                { value: 'en-NZ', labelKey: 'accentNZ' },
                { value: 'en-CA', labelKey: 'accentCA' },
                { value: 'en-ZA', labelKey: 'accentZA' },
                { value: 'en-PH', labelKey: 'accentPH' }
            ];
            ['accentThem', 'accentMe'].forEach(id => {
                const sel = document.getElementById(id);
                if (!sel) return;
                const val = sel.value;
                sel.innerHTML = '';
                opts.forEach(({ value, labelKey }) => {
                    const opt = document.createElement('option');
                    opt.value = value;
                    opt.textContent = t(labelKey);
                    sel.appendChild(opt);
                });
                sel.value = val;
            });
        }

        function changeLanguage(lang) {
            saveLanguagePreference(lang);
            updateUILanguage();
            // üêõ Bug fix: Ë™ûË®ÄÂàáÊèõÂæåË¶ÅÈáçÊñ∞Ë®≠ÂÆö API Key ÁãÄÊÖãÔºåÂê¶ÂâáÊúÉË¢´ data-i18n Ë¶ÜËìã
            updateApiKeyStatus(userApiKey !== null);
            if (typeof renderScenarioGrid === 'function') renderScenarioGrid();
            if (typeof renderQuickPrompts === 'function') renderQuickPrompts(selectedScenario);
            if (typeof renderSavedScripts === 'function') renderSavedScripts();
        }

        // ============================================
        // API Key Management
        // ============================================

        let userApiKey = null;

        function loadApiKey() {
            try {
                const saved = localStorage.getItem(API_KEY_STORAGE_KEY);
                if (saved) { userApiKey = saved; updateApiKeyStatus(true); return true; }
            } catch (e) {}
            updateApiKeyStatus(false);
            return false;
        }

        function saveApiKey() {
            const input = document.getElementById('apiKeyInput');
            if (!input) return;
            const key = input.value.trim();
            if (!key || !key.startsWith('sk-')) {
                alert(t('apiKeyInvalidFormat'));
                return;
            }
            try {
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                userApiKey = key;
                input.value = '';
                updateApiKeyStatus(true);
            } catch (e) { alert(t('apiKeySaveFailed')); }
        }

        function clearApiKey() {
            try {
                localStorage.removeItem(API_KEY_STORAGE_KEY);
                userApiKey = null;
                updateApiKeyStatus(false);
            } catch (e) {}
        }

        function updateApiKeyStatus(isSet) {
            const sectionEl = document.getElementById('apiKeySection');
            const statusEl = document.getElementById('apiKeyStatusText');
            const inputEl = document.getElementById('apiKeyInput');
            const saveBtn = document.getElementById('apiKeySaveBtn');
            const clearBtn = document.getElementById('apiKeyClearBtn');
            if (statusEl) {
                statusEl.textContent = isSet ? t('apiKeySet') : t('apiKeyNotSet');
                statusEl.className = isSet ? 'api-key-status set' : 'api-key-status not-set';
            }
            if (inputEl) inputEl.placeholder = isSet ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : t('apiKeyPlaceholder');
            if (saveBtn) saveBtn.style.display = isSet ? 'none' : '';
            if (clearBtn) clearBtn.style.display = isSet ? '' : 'none';
            // Auto-collapse when API key is set
            if (sectionEl) {
                if (isSet) {
                    sectionEl.classList.add('collapsed');
                } else {
                    sectionEl.classList.remove('collapsed');
                }
            }
        }

        function toggleApiKeyDetails() {
            const sectionEl = document.getElementById('apiKeySection');
            if (sectionEl) {
                sectionEl.classList.toggle('collapsed');
            }
        }

        function getApiKey() { return userApiKey; }

        // ============================================
        // Scenario Data (from script_generator.py)
        // ============================================

        const SCENARIOS = {
            bank: {
                name: 'ÈäÄË°å',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>`,
                vocab: ['account', 'balance', 'transaction', 'statement', 'charge', 'fee', 'transfer'],
                placeholder: '‰æãÂ¶ÇÔºöÊàëÊÉ≥Êü•Ë©¢Â∏≥Êà∂È§òÈ°ç',
                defaultPrompts: [
                    { label: 'Êü•Ë©¢È§òÈ°ç', prompt: 'ÊàëÊÉ≥Êü•Ë©¢Â∏≥Êà∂È§òÈ°çÂíåÊúÄËøëÁöÑ‰∫§ÊòìË®òÈåÑ' },
                    { label: '‰∏çÊòéÊî∂Ë≤ª', prompt: 'ÊàëÊÉ≥Ë©¢ÂïèÂ∏≥Êà∂‰∏ä‰∏ÄÁ≠Ü‰∏çÊòéÁöÑÊî∂Ë≤ªÊòØ‰ªÄÈ∫º' },
                    { label: 'Êõ¥Êñ∞Ë≥áÊñô', prompt: 'ÊàëÊÉ≥Êõ¥Êñ∞ÊàëÁöÑÂú∞ÂùÄÂíåÈõªË©±ËôüÁ¢º' },
                    { label: 'ÈñãÊà∂Âí®Ë©¢', prompt: 'ÊàëÊÉ≥‰∫ÜËß£ÈñãÁ´ãÊñ∞Â∏≥Êà∂ÈúÄË¶Å‰ªÄÈ∫ºÊñá‰ª∂' },
                    { label: 'ËΩâÂ∏≥ÂïèÈ°å', prompt: 'ÊàëÊÉ≥Êü•Ë©¢‰∏ÄÁ≠ÜËΩâÂ∏≥ÁÇ∫‰ªÄÈ∫ºÈÇÑÊ≤íÂà∞Â∏≥' }
                ]
            },
            nhs: {
                name: 'ÈÜ´ÁôÇ',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg>`,
                vocab: ['appointment', 'prescription', 'symptoms', 'referral', 'doctor', 'surgery'],
                placeholder: '‰æãÂ¶ÇÔºöÊàëÊÉ≥È†êÁ¥ÑÁúã GP',
                defaultPrompts: [
                    { label: 'È†êÁ¥Ñ GP', prompt: 'ÊàëÊÉ≥È†êÁ¥ÑÁúã GP ÁöÑÊôÇÈñì' },
                    { label: 'È†òËôïÊñπÁ∞Ω', prompt: 'ÊàëÊÉ≥Ë©¢ÂïèÊàëÁöÑËôïÊñπÁ∞ΩÊòØÂê¶ÂèØ‰ª•È†òÂèñ' },
                    { label: 'ËΩâË®∫ÈÄ≤Â∫¶', prompt: 'ÊàëÊÉ≥Êü•Ë©¢Â∞àÁßëËΩâË®∫ÁöÑÈÄ≤Â∫¶' },
                    { label: 'Ê™¢È©óÁµêÊûú', prompt: 'ÊàëÊÉ≥Ë©¢Âïè‰∏äÊ¨°Ê™¢È©óÁöÑÁµêÊûúÂá∫‰æÜ‰∫ÜÂóé' },
                    { label: 'ÂèñÊ∂àÈ†êÁ¥Ñ', prompt: 'ÊàëÊÉ≥ÂèñÊ∂àÊàñÊõ¥ÊîπÊàëÁöÑÈ†êÁ¥ÑÊôÇÈñì' }
                ]
            },
            utilities: {
                name: 'Ê∞¥Èõª',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path></svg>`,
                vocab: ['bill', 'meter reading', 'tariff', 'direct debit', 'account number'],
                placeholder: '‰æãÂ¶ÇÔºöÊàëÊÉ≥Êü•Ë©¢Â∏≥ÂñÆ',
                defaultPrompts: [
                    { label: 'Êü•Â∏≥ÂñÆ', prompt: 'ÊàëÊÉ≥Êü•Ë©¢ÊúÄÊñ∞ÁöÑÂ∏≥ÂñÆÈáëÈ°ç' },
                    { label: 'Êõ¥Êñ∞‰ªòÊ¨æ', prompt: 'ÊàëÊÉ≥Êõ¥Êñ∞ Direct Debit ÁöÑÈäÄË°åË≥áÊñô' },
                    { label: 'Â†±ËÆÄÊï∏', prompt: 'ÊàëÊÉ≥Â†±ÂëäÈõªÈå∂/Áì¶ÊñØË°®ÁöÑËÆÄÊï∏' },
                    { label: 'ÊèõÊñπÊ°à', prompt: 'ÊàëÊÉ≥‰∫ÜËß£ÊúâÊ≤íÊúâÊõ¥ÂÑ™ÊÉ†ÁöÑÊñπÊ°à' },
                    { label: 'Êê¨ÂÆ∂ÈÄöÁü•', prompt: 'Êàë‰∏ãÂÄãÊúàË¶ÅÊê¨ÂÆ∂ÔºåÊÉ≥ÈÄöÁü•Êõ¥Êñ∞Âú∞ÂùÄ' }
                ]
            },
            insurance: {
                name: '‰øùÈö™',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>`,
                vocab: ['policy', 'claim', 'excess', 'cover', 'premium', 'renewal'],
                placeholder: '‰æãÂ¶ÇÔºöÊàëÊÉ≥‰∫ÜËß£‰øùÂñÆÂÖßÂÆπ',
                defaultPrompts: [
                    { label: '‰øùÈöúÁØÑÂúç', prompt: 'ÊàëÊÉ≥‰∫ÜËß£ÊàëÁöÑ‰øùÂñÆÊ∂µËìãÁØÑÂúç' },
                    { label: 'ÊèêÂá∫ÁêÜË≥†', prompt: 'ÊàëÊÉ≥ÊèêÂá∫‰∏ÄÂÄãÁêÜË≥†Áî≥Ë´ã' },
                    { label: 'Á∫åÁ¥Ñ‰øùË≤ª', prompt: 'ÊàëÊÉ≥Ë©¢Âïè‰øùË≤ªÁ∫åÁ¥ÑÁöÑÈáëÈ°ç' },
                    { label: 'Êõ¥ÊîπË≥áÊñô', prompt: 'ÊàëÊÉ≥Êõ¥Êîπ‰øùÂñÆ‰∏äÁöÑÂÄã‰∫∫Ë≥áÊñô' },
                    { label: 'ÂèñÊ∂à‰øùÂñÆ', prompt: 'ÊàëÊÉ≥‰∫ÜËß£ÂèñÊ∂à‰øùÂñÆÁöÑÊµÅÁ®ã' }
                ]
            },
            general: {
                name: '‰∏ÄËà¨',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`,
                vocab: ['enquiry', 'confirm', 'reference number', 'information', 'details'],
                placeholder: '‰æãÂ¶ÇÔºöÊÇ®Â•ΩÔºåÊàëÊÉ≥Ë©¢Âïè‰∏Ä‰∫õ‰∫ãÊÉÖ',
                defaultPrompts: [
                    { label: '‰∏ÄËà¨Ë©¢Âïè', prompt: 'ÊÇ®Â•ΩÔºåÊàëÊÉ≥Ë©¢Âïè‰∏Ä‰∫õ‰∫ãÊÉÖ' },
                    { label: 'Á¢∫Ë™çÁãÄÊÖã', prompt: 'ÊàëÊÉ≥Á¢∫Ë™çÊàëÁöÑÈ†êÁ¥Ñ/Ë®ÇÂñÆÁãÄÊÖã' },
                    { label: 'ÂÆ¢ÊúçËΩâÊé•', prompt: 'Ë´ãÂïèÂèØ‰ª•Âπ´ÊàëËΩâÊé•ÂÆ¢ÊúçÈÉ®ÈñÄÂóé' },
                    { label: 'ÊäïË®¥ÂèçÊò†', prompt: 'ÊàëÊÉ≥ÂèçÊò†‰∏ÄÂÄãÂïèÈ°å' },
                    { label: 'ÊÑüË¨ùÁµêÊùü', prompt: 'Â•ΩÁöÑÔºåË¨ùË¨ù‰Ω†ÁöÑÂπ´ÂøôÔºåÂÜçË¶ã' }
                ]
            }
        };

        // Quick Phrases (hardcoded, no API call)
        const QUICK_PHRASES = [
            { english: "Could you repeat that, please?", chinese: "Ë´ãÂÜçË™™‰∏ÄÊ¨°" },
            { english: "Could you speak more slowly?", chinese: "Ë´ãÊÖ¢ÈªûË™™" },
            { english: "Let me confirm that...", chinese: "ÊàëÁ¢∫Ë™ç‰∏Ä‰∏ã" },
            { english: "Thank you. Goodbye.", chinese: "Ë¨ùË¨ùÂÜçË¶ã" }
        ];

        // Panic Button stalling phrases (rotate randomly)
        const STALLING_PHRASES = [
            { english: "Let me think about that for a moment...", chinese: "ËÆìÊàëÊÉ≥‰∏Ä‰∏ã..." },
            { english: "That's a good question. Give me a second...", chinese: "Â•ΩÂïèÈ°åÔºåË´ãÁµ¶Êàë‰∏ÄÁßí..." },
            { english: "Could you hold on for just a second?", chinese: "Ë´ãÁ®çÁ≠â‰∏Ä‰∏ãÂ•ΩÂóéÔºü" },
            { english: "I want to make sure I understand correctly...", chinese: "ÊàëÊÉ≥Á¢∫Ë™çÊàëÁêÜËß£Ê≠£Á¢∫..." },
            { english: "Let me just check something quickly...", chinese: "ËÆìÊàëÂø´ÈÄüÁ¢∫Ë™ç‰∏Ä‰∏ã..." },
            { english: "Hmm, let me consider that...", chinese: "ÂóØÔºåËÆìÊàëËÄÉÊÖÆ‰∏Ä‰∏ã..." },
            { english: "I need a moment to think about this...", chinese: "ÊàëÈúÄË¶Å‰∏ÄÈªûÊôÇÈñìÊÉ≥ÊÉ≥..." },
            { english: "That's interesting. Let me think...", chinese: "ÈÄôÂæàÊúâË∂£ÔºåËÆìÊàëÊÉ≥ÊÉ≥..." }
        ];

        let lastStallingIndex = -1;

        // ============================================
        // localStorage key for saved scripts
        // ============================================

        const STORAGE_KEY = 'eca_prepared_scripts';

        // ============================================
        // Selected scenario state
        // ============================================

        let selectedScenario = 'general';

        // ============================================
        // Call timer
        // ============================================

        let callTimerInterval = null;
        let callStartTime = null;

        // State
        let audioCapture = null;
        let peerConnection = null;
        let dataChannel = null;
        let isConnected = false;

        // New modules
        let eventHandler = null;
        let renderer = null;

        // Web Speech for real-time English subtitles (ÈõôËªåÁ≠ñÁï•)
        let webSpeech = null;
        let currentRealtimeEnglish = '';  // Áï∂ÂâçÂØ¶ÊôÇËã±ÊñáÈ†êË¶Ω

        // Smart Segmenter for intelligent segmentation (600ms vs 2-3s)
        let smartSegmenter = null;

        // ============================================
        // Segmenter Presets Configuration
        // ============================================

        const SEGMENTER_PRESETS = {
            'ultra-fast': {
                name: 'Ê•µÈÄü',
                pauseThreshold: 400,    // Êõ¥Áü≠ÁöÑÊö´ÂÅúÂÅµÊ∏¨
                stabilityDelay: 80,     // Êõ¥Áü≠ÁöÑÁ©©ÂÆöÁ≠âÂæÖ
                softLimit: 12,          // Êõ¥Áü≠ÁöÑËªüÊÄßÈôêÂà∂
                hardLimit: 20,          // Êõ¥Áü≠ÁöÑÁ°¨ÊÄßÈôêÂà∂
                minSegmentWords: 2,     // Êõ¥Â∞ëÁöÑÊúÄÂ∞èÂ≠óÊï∏
                description: 'ÊúÄÂø´ÂèçÊáâÔºåÂèØËÉΩÂàáÊñ∑ÂñÆË©û'
            },
            'fast': {
                name: 'Âø´ÈÄü',
                pauseThreshold: 500,
                stabilityDelay: 100,
                softLimit: 14,
                hardLimit: 22,
                minSegmentWords: 3,
                description: 'Âø´ÈÄüÂèçÊáâÔºåËºïÂæÆÈ¢®Èö™'
            },
            'balanced': {
                name: 'Âπ≥Ë°°',
                pauseThreshold: 600,
                stabilityDelay: 150,
                softLimit: 15,
                hardLimit: 25,
                minSegmentWords: 3,
                description: 'Âπ≥Ë°°ÈÄüÂ∫¶ËàáÁ©©ÂÆöÊÄßÔºàÈ†êË®≠Ôºâ'
            },
            'stable': {
                name: 'Á©©ÂÆö',
                pauseThreshold: 750,
                stabilityDelay: 200,
                softLimit: 18,
                hardLimit: 28,
                minSegmentWords: 4,
                description: 'Êõ¥Á©©ÂÆöÔºåËºÉÊÖ¢'
            },
            'conservative': {
                name: '‰øùÂÆà',
                pauseThreshold: 900,
                stabilityDelay: 250,
                softLimit: 20,
                hardLimit: 30,
                minSegmentWords: 4,
                description: 'ÊúÄÁ©©ÂÆöÔºåÊúÄÊÖ¢'
            }
        };

        let currentPreset = 'fast';

        function applyPreset(presetKey) {
            const preset = SEGMENTER_PRESETS[presetKey];
            if (!preset) {
                log(`Unknown preset: ${presetKey}`, 'error');
                return;
            }

            currentPreset = presetKey;

            // Update UI
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === presetKey);
            });

            // Apply to SmartSegmenter if it exists
            if (smartSegmenter) {
                smartSegmenter.pauseThreshold = preset.pauseThreshold;
                smartSegmenter.stabilityDelay = preset.stabilityDelay;
                smartSegmenter.softLimit = preset.softLimit;
                smartSegmenter.hardLimit = preset.hardLimit;
                smartSegmenter.minSegmentWords = preset.minSegmentWords;
                log(`Preset: ${preset.name}`, 'success');
            }
        }

        // Toggle log panel visibility
        function toggleLogPanel() {
            const logPanel = document.getElementById('logPanel');
            const logToggle = document.getElementById('logToggle');
            const isCollapsed = logPanel.classList.contains('collapsed');

            logPanel.classList.toggle('collapsed');
            logToggle.classList.toggle('expanded');

            // Update button text
            const textSpan = logToggle.querySelector('span');
            textSpan.textContent = isCollapsed ? 'Èö±ËóèÊó•Ë™å' : 'È°ØÁ§∫Êó•Ë™å';
        }

        // =============================================
        // Phase 1: Scenario Selector
        // =============================================

        function renderScenarioGrid() {
            const grid = document.getElementById('scenarioGrid');
            grid.innerHTML = '';
            for (const [key, scenario] of Object.entries(SCENARIOS)) {
                const card = document.createElement('button');
                card.className = 'scenario-card' + (key === selectedScenario ? ' selected' : '');
                card.setAttribute('tabindex', '0');
                card.setAttribute('aria-label', scenario.name);
                card.onclick = () => selectScenario(key);
                card.innerHTML = `
                    <div class="scenario-card-icon">${scenario.icon}</div>
                    <div class="scenario-card-name">${scenario.name}</div>
                    <div class="scenario-card-vocab">${scenario.vocab.join(', ')}</div>
                `;
                grid.appendChild(card);
            }
        }

        function selectScenario(key) {
            selectedScenario = key;
            document.querySelectorAll('.scenario-card').forEach(card => {
                card.classList.remove('selected');
            });
            // Find the clicked card via scenario-card-name text matching
            document.querySelectorAll('.scenario-card').forEach(card => {
                const nameEl = card.querySelector('.scenario-card-name');
                if (nameEl && nameEl.textContent === SCENARIOS[key].name) {
                    card.classList.add('selected');
                }
            });

            // Update input placeholder and quick prompts
            const scenario = SCENARIOS[key];
            const scriptInput = document.getElementById('scriptInput');
            if (scriptInput && scenario.placeholder) {
                scriptInput.placeholder = scenario.placeholder;
            }
            renderQuickPrompts(key);
        }

        /**
         * Render quick prompt buttons for the selected scenario
         */
        function renderQuickPrompts(scenarioKey) {
            const grid = document.getElementById('quickPromptsGrid');
            if (!grid) return;

            const scenario = SCENARIOS[scenarioKey];
            if (!scenario || !scenario.defaultPrompts) {
                grid.innerHTML = '';
                return;
            }

            grid.innerHTML = scenario.defaultPrompts.map(item => `
                <button class="quick-prompt-btn" onclick="useQuickPrompt('${escapeHtmlForAttr(item.prompt)}')">
                    ${item.label}
                </button>
            `).join('');
        }

        /**
         * Use a quick prompt - fill the input and generate script
         */
        function useQuickPrompt(prompt) {
            const scriptInput = document.getElementById('scriptInput');
            if (scriptInput) {
                scriptInput.value = prompt;
            }
            generateScript();
        }

        // =============================================
        // Phase 1: Saved Scripts (localStorage)
        // =============================================

        function getSavedScripts() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                console.error('Error reading saved scripts:', e);
                return [];
            }
        }

        function saveSavedScripts(scripts) {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(scripts));
            } catch (e) {
                console.error('Error saving scripts:', e);
            }
        }

        function saveAsQuickCard() {
            if (!currentScript) return;

            const scripts = getSavedScripts();
            const newCard = {
                id: 'prep-' + Date.now(),
                chinese: document.getElementById('scriptInput').value.trim(),
                english: currentScript,
                scenario: selectedScenario,
                createdAt: Date.now()
            };
            scripts.push(newCard);
            saveSavedScripts(scripts);
            renderSavedScripts();

            // Visual feedback on button
            const btn = document.getElementById('btnSaveCard');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                Â∑≤ÂÑ≤Â≠ò
            `;
            btn.disabled = true;
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.disabled = false;
            }, 1500);

            log(`[Ë¨õÁ®ø] Â∑≤ÂÑ≤Â≠òÁÇ∫Âø´Êç∑Âç°Áâá: "${currentScript.substring(0, 30)}..."`, 'success');
        }

        function deleteSavedScript(id) {
            let scripts = getSavedScripts();
            scripts = scripts.filter(s => s.id !== id);
            saveSavedScripts(scripts);
            renderSavedScripts();
        }

        function renderSavedScripts() {
            const container = document.getElementById('savedScriptsList');
            const emptyEl = document.getElementById('savedScriptsEmpty');
            const scripts = getSavedScripts();

            // Clear existing items (but keep empty state el)
            const existingItems = container.querySelectorAll('.saved-script-item');
            existingItems.forEach(el => el.remove());

            if (scripts.length === 0) {
                emptyEl.style.display = 'block';
                return;
            }

            emptyEl.style.display = 'none';

            // ÊúÄÊñ∞ÁΩÆÈ†ÇÔºöÂèçËΩâÈ†ÜÂ∫èÈ°ØÁ§∫
            scripts.slice().reverse().forEach(script => {
                const item = document.createElement('div');
                item.className = 'saved-script-item';
                const scenarioName = SCENARIOS[script.scenario]?.name || script.scenario;
                const date = new Date(script.createdAt).toLocaleDateString('zh-TW');
                item.innerHTML = `
                    <div class="saved-script-body">
                        <div class="saved-script-english">${escapeHtml(script.english)}</div>
                        <div class="saved-script-chinese">${escapeHtml(script.chinese)}</div>
                        <div class="saved-script-meta">
                            <span>${scenarioName}</span>
                            <span>${date}</span>
                        </div>
                    </div>
                    <button class="saved-script-delete" onclick="deleteSavedScript('${script.id}')" aria-label="Âà™Èô§" title="Âà™Èô§">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                        </svg>
                    </button>
                `;
                container.appendChild(item);
            });
        }

        // =============================================
        // Phase 1: Mode Switching (Preparation <-> Call)
        // =============================================

        function switchToCallMode() {
            document.getElementById('preparationMode').classList.add('hidden');
            document.getElementById('callMode').classList.add('active');
            document.getElementById('quickResponseBar').style.display = '';
            renderPreparedCards();
            startCallTimer();
        }

        function switchToPreparationMode() {
            document.getElementById('preparationMode').classList.remove('hidden');
            document.getElementById('callMode').classList.remove('active');
            document.getElementById('quickResponseBar').style.display = 'none';
            stopCallTimer();
        }

        // =============================================
        // Phase 1: PTT (Push-to-Talk / ËßíËâ≤Ê®ôË®òÊ®°Âºè)
        // Áî®ÈÄîÔºöÂçÄÂàÜ„ÄåÂ∞çÊñπË™™Ë©±„ÄçÂíå„ÄåÊàëÂú®Ë™™Ë©±„Äç
        // Spacebar HOLD Ê®°ÂºèÔºöÊåâ‰Ωè=ÊàëÔºåÊîæÈñã=Â∞çÊñπ
        // =============================================

        let isPTTActive = false;
        let currentSpeaker = 'them';  // 'them' (È†êË®≠) Êàñ 'me' (Êåâ‰Ωè Spacebar ÊôÇ)

        // =============================================
        // Âè£Èü≥Ë®≠ÂÆöÔºàlocalStorage ÊåÅ‰πÖÂåñÔºâ
        // =============================================

        const ACCENT_STORAGE_KEY = 'eca_accent_settings';
        let accentThem = 'en-GB';  // Â∞çÊñπÁöÑËã±Ë™ûÂè£Èü≥ÔºàÈ†êË®≠ÔºöËã±ÂºèÔºâ
        let accentMe = 'en-IN';    // ÊàëÁöÑËã±Ë™ûÂè£Èü≥ÔºàÈ†êË®≠Ôºö‰∫ûÊ¥≤Âè£Èü≥Ôºâ

        /**
         * ËºâÂÖ•Âè£Èü≥Ë®≠ÂÆöÔºàÂæû localStorageÔºâ
         */
        function loadAccentSettings() {
            try {
                const saved = localStorage.getItem(ACCENT_STORAGE_KEY);
                if (saved) {
                    const settings = JSON.parse(saved);
                    accentThem = settings.them || 'en-GB';
                    accentMe = settings.me || 'en-IN';
                }
            } catch (e) {
                console.warn('[Accent] Failed to load settings:', e);
            }

            // Êõ¥Êñ∞ UI
            const selectThem = document.getElementById('accentThem');
            const selectMe = document.getElementById('accentMe');
            if (selectThem) selectThem.value = accentThem;
            if (selectMe) selectMe.value = accentMe;

            console.log(`[Accent] Loaded: them=${accentThem}, me=${accentMe}`);
        }

        /**
         * ÂÑ≤Â≠òÂè£Èü≥Ë®≠ÂÆöÔºàÂà∞ localStorageÔºâ
         */
        function saveAccentSettings() {
            const selectThem = document.getElementById('accentThem');
            const selectMe = document.getElementById('accentMe');

            if (selectThem) accentThem = selectThem.value;
            if (selectMe) accentMe = selectMe.value;

            try {
                localStorage.setItem(ACCENT_STORAGE_KEY, JSON.stringify({
                    them: accentThem,
                    me: accentMe
                }));
                console.log(`[Accent] Saved: them=${accentThem}, me=${accentMe}`);
            } catch (e) {
                console.warn('[Accent] Failed to save settings:', e);
            }
        }

        /**
         * ÂàáÊèõ Web Speech Ë™ûË®ÄÔºàÁî®Êñº PTT ÂàáÊèõÔºâ
         * @param {string} speaker - 'them' Êàñ 'me'
         */
        function switchAccent(speaker) {
            if (!webSpeech || !webSpeech.isSupported()) return;

            const targetLang = speaker === 'me' ? accentMe : accentThem;
            const currentLang = webSpeech.getLanguage();

            if (currentLang !== targetLang) {
                webSpeech.setLanguage(targetLang);
                log(`[Accent] Switched to ${targetLang} (${speaker})`, 'info');
            }
        }

        /**
         * PTT ÈñãÂßã - ÂàáÊèõÁÇ∫„ÄåÊàëÂú®Ë™™Ë©±„ÄçÊ®°Âºè
         * üîß ËßíËâ≤Ê®ôË®òÊ©üÂà∂ÔºàÈùûÈùúÈü≥ÔºâÔºö
         * 1. Âº∑Âà∂Ëº∏Âá∫ buffer ‰∏≠ÁöÑÂÖßÂÆπÔºàÊ®ôË®òÁÇ∫„ÄåÂ∞çÊñπ„ÄçÔºâ
         * 2. ÂàáÊèõ currentSpeaker = 'me'
         * 3. Web Speech Âíå SmartSegmenter ÁπºÁ∫åÈÅãË°å
         */
        function pttStart() {
            if (isPTTActive || isPaused || !isConnected) return;
            isPTTActive = true;

            // üîß ÂÖàÂº∑Âà∂Ëº∏Âá∫ SmartSegmenter buffer ‰∏≠ÁöÑÊâÄÊúâÂÖßÂÆπÔºàÊ®ôË®òÁÇ∫„ÄåÂ∞çÊñπ„ÄçÔºâ
            // ÈÄôÁ¢∫‰øùÂàáÊèõÂâçÁöÑÂ∞çÊñπË™™Ë©±ÂÖßÂÆπ‰∏çÊúÉ‰∏üÂ§±
            if (smartSegmenter && smartSegmenter.buffer && smartSegmenter.buffer.trim()) {
                smartSegmenter._emitSegment('speaker_change');
                console.log('[PTT] Force emitted buffer before speaker change');
            }

            // üîß ÈóúÈçµÔºöÂàáÊèõË™™Ë©±ËÄÖÁÇ∫„ÄåÊàë„Äç
            currentSpeaker = 'me';

            // üîß ÂàáÊèõÂè£Èü≥Ë≠òÂà•ÔºàÊàëÁöÑÂè£Èü≥Ôºâ
            switchAccent('me');

            // Ê≥®ÊÑèÔºö‰∏ç mute„ÄÅ‰∏ç stop - Web Speech Âíå SmartSegmenter ÁπºÁ∫åÈÅãË°å
            // ÂæåÁ∫åÁöÑ segment ÊúÉË¢´Ê®ôË®òÁÇ∫ speaker='me'

            // Êõ¥Êñ∞ÊåâÈàï UI
            const btn = document.getElementById('btnPTT');
            if (btn) {
                btn.classList.add('active');
            }

            // Êõ¥Êñ∞Ë™™Ë©±ËÄÖÊåáÁ§∫Âô®ÔºàÂèñ‰ª£ÂÖ®Ëû¢ÂπïË¶ÜËìãÂ±§Ôºâ
            updateSpeakerIndicator('me');

            // Êõ¥Êñ∞ÁãÄÊÖãÊåáÁ§∫Âô®
            updateStatus('ptt', 'ÊàëÂú®Ë™™Ë©±');

            log('PTT: ÊàëÂú®Ë™™Ë©±Ê®°Âºè', 'info');
        }

        /**
         * PTT ÁµêÊùü - ÂàáÊèõÂõû„ÄåÂ∞çÊñπË™™Ë©±„ÄçÊ®°Âºè
         * üîß ËßíËâ≤Ê®ôË®òÊ©üÂà∂Ôºö
         * 1. Âº∑Âà∂Ëº∏Âá∫ buffer ‰∏≠ÁöÑÂÖßÂÆπÔºàÊ®ôË®òÁÇ∫„ÄåÊàë„ÄçÔºâ
         * 2. ÂàáÊèõ currentSpeaker = 'them'
         */
        function pttEnd() {
            if (!isPTTActive || isPaused) return;
            isPTTActive = false;

            // üîß ÂÖàÂº∑Âà∂Ëº∏Âá∫ SmartSegmenter buffer ‰∏≠ÁöÑÊâÄÊúâÂÖßÂÆπÔºàÊ®ôË®òÁÇ∫„ÄåÊàë„ÄçÔºâ
            if (smartSegmenter && smartSegmenter.buffer && smartSegmenter.buffer.trim()) {
                smartSegmenter._emitSegment('speaker_change');
                console.log('[PTT] Force emitted buffer before speaker change back');
            }

            // üîß ÈóúÈçµÔºöÂàáÊèõË™™Ë©±ËÄÖÂõû„ÄåÂ∞çÊñπ„Äç
            currentSpeaker = 'them';

            // üîß ÂàáÊèõÂè£Èü≥Ë≠òÂà•ÔºàÂ∞çÊñπÂè£Èü≥Ôºâ
            switchAccent('them');

            // Êõ¥Êñ∞ÊåâÈàï UI
            const btn = document.getElementById('btnPTT');
            if (btn) {
                btn.classList.remove('active');
            }

            // Êõ¥Êñ∞Ë™™Ë©±ËÄÖÊåáÁ§∫Âô®
            updateSpeakerIndicator('them');

            // ÊÅ¢Âæ©ÁãÄÊÖãÊåáÁ§∫Âô®
            updateStatus('connected', 'ÁøªË≠Ø‰∏≠');

            log('PTT: Â∞çÊñπË™™Ë©±Ê®°Âºè', 'info');
        }

        /**
         * Êõ¥Êñ∞Ë™™Ë©±ËÄÖÊåáÁ§∫Âô®ÔºàÂ∫ïÈÉ®Â∞è badgeÔºåÂèñ‰ª£ÂÖ®Ëû¢ÂπïË¶ÜËìãÂ±§Ôºâ
         */
        function updateSpeakerIndicator(speaker) {
            let indicator = document.getElementById('speakerIndicator');

            if (!indicator) {
                // ÂâµÂª∫ÊåáÁ§∫Âô®ÂÖÉÁ¥†
                indicator = document.createElement('div');
                indicator.id = 'speakerIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 10px 20px;
                    border-radius: 25px;
                    font-size: 14px;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    z-index: 100;
                    transition: all 0.2s ease;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                `;
                document.body.appendChild(indicator);
            }

            if (speaker === 'me') {
                indicator.innerHTML = 'üôã ÊàëÂú®Ë™™Ë©±';
                indicator.style.background = 'rgba(0, 212, 255, 0.95)';
                indicator.style.color = '#000';
            } else {
                indicator.innerHTML = 'üë§ Â∞çÊñπË™™Ë©±';
                indicator.style.background = 'rgba(0, 255, 136, 0.25)';
                indicator.style.color = 'var(--accent-green)';
                indicator.style.border = '1px solid var(--accent-green)';
            }
        }

        /**
         * Èö±ËóèË™™Ë©±ËÄÖÊåáÁ§∫Âô®ÔºàÈõ¢ÈñãÈÄöË©±ÊôÇÔºâ
         */
        function hideSpeakerIndicator() {
            const indicator = document.getElementById('speakerIndicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // Spacebar ÊéßÂà∂ PTTÔºàHOLD Ê®°ÂºèÔºöÊåâ‰Ωè=ÊàëÔºåÊîæÈñã=Â∞çÊñπÔºâ
        document.addEventListener('keydown', function(e) {
            // Âè™Âú®ÈÄöË©±Ê®°Âºè‰∏ãÁîüÊïàÔºå‰∏î‰∏çÊòØÂú®Ëº∏ÂÖ•Ê°Ü‰∏≠
            if (!isConnected || isPaused) return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            if (e.code === 'Space' && !e.repeat) {
                e.preventDefault();
                pttStart();  // HOLD Ê®°ÂºèÔºökeydown ÈñãÂßã
            }
        });

        document.addEventListener('keyup', function(e) {
            // Âè™Âú®ÈÄöË©±Ê®°Âºè‰∏ãÁîüÊïàÔºå‰∏î‰∏çÊòØÂú®Ëº∏ÂÖ•Ê°Ü‰∏≠
            if (!isConnected || isPaused) return;
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            if (e.code === 'Space') {
                e.preventDefault();
                pttEnd();  // HOLD Ê®°ÂºèÔºökeyup ÁµêÊùü
            }
        });

        // =============================================
        // Phase 1: Pause / Resume / Go Home
        // =============================================

        let isPaused = false;

        /**
         * Êö´ÂÅúËÅÜËÅΩ - ÂÅúÊ≠¢È∫•ÂÖãÈ¢®‰ΩÜ‰øùÁïôÂú®ÈÄöË©±È†ÅÈù¢
         */
        function pauseListening() {
            if (isPaused) return;
            isPaused = true;

            // ÈáçÁΩÆ PTT ÁãÄÊÖã
            isPTTActive = false;
            const pttBtn = document.getElementById('btnPTT');
            if (pttBtn) {
                pttBtn.classList.remove('active');
            }

            // Stop Web Speech
            if (webSpeech) {
                webSpeech.isRunning = false;
                webSpeech.stop();
                log('WebSpeech paused', 'info');
            }

            // Stop Smart Segmenter
            if (smartSegmenter) {
                smartSegmenter.stop();
                log('SmartSegmenter paused', 'info');
            }

            // Mark realtime preview as stopped
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.classList.add('stopped');
                const labelEl = previewEl.querySelector('.preview-label span:last-child');
                if (labelEl) {
                    labelEl.textContent = 'Ëã±ÊñáÂéüÊñáÔºàÂ∑≤Êö´ÂÅúÔºâ';
                }
            }

            // Pause timer
            pauseCallTimer();

            // Update UI: show resume, hide pause
            document.getElementById('btnPause').style.display = 'none';
            document.getElementById('btnResume').style.display = '';

            // Update status
            updateStatus('paused', 'Â∑≤Êö´ÂÅú');
            // Èö±ËóèË™™Ë©±ËÄÖÊåáÁ§∫Âô®
            hideSpeakerIndicator();
            log('Listening paused', 'success');
        }

        /**
         * ÁπºÁ∫åËÅÜËÅΩ - ÊÅ¢Âæ©È∫•ÂÖãÈ¢®Êî∂Èü≥
         */
        function resumeListening() {
            if (!isPaused) return;
            isPaused = false;

            // Restart Web Speech with current speaker's accent
            if (webSpeech && webSpeech.isSupported()) {
                const resumeAccent = currentSpeaker === 'me' ? accentMe : accentThem;
                webSpeech.setLanguage(resumeAccent, false);
                webSpeech.start();
                log(`WebSpeech resumed (${resumeAccent})`, 'success');
            }

            // Restart Smart Segmenter
            if (smartSegmenter) {
                smartSegmenter.start();
                log('SmartSegmenter resumed', 'success');
            }

            // Remove stopped state from preview
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.classList.remove('stopped');
                const labelEl = previewEl.querySelector('.preview-label span:last-child');
                if (labelEl) {
                    labelEl.textContent = 'Ëã±ÊñáÂéüÊñá';
                }
            }

            // Resume timer
            resumeCallTimer();

            // Update UI: show pause, hide resume
            document.getElementById('btnPause').style.display = '';
            document.getElementById('btnResume').style.display = 'none';

            // Update status
            updateStatus('connected', 'ÁøªË≠Ø‰∏≠');
            // ÊÅ¢Âæ©Ë™™Ë©±ËÄÖÊåáÁ§∫Âô®
            updateSpeakerIndicator('them');
            log('Listening resumed', 'success');
        }

        /**
         * ËøîÂõûÈ¶ñÈ†Å - Â∏∂Á¢∫Ë™çÂ∞çË©±Ê°Ü
         */
        function goToHome() {
            const confirmed = confirm('Á¢∫ÂÆöË¶ÅÈõ¢ÈñãÂóéÔºüÁøªË≠ØË®òÈåÑÂ∞áÊúÉÊ∏ÖÈô§„ÄÇ');
            if (confirmed) {
                stopTest();
            }
        }

        /**
         * ÂåØÂá∫Â∞çË©±Ë®òÈåÑÁÇ∫ Markdown Ê†ºÂºè
         */
        function exportTranscript() {
            // Âæû DOM Êî∂ÈõÜÊâÄÊúâ segment Êï∏Êìö
            const segmentEls = document.querySelectorAll('.segment-item');

            if (segmentEls.length === 0) {
                alert(t('noExportData'));
                return;
            }

            // Êî∂ÈõÜÊï∏ÊìöÔºàDOM È†ÜÂ∫èÊòØÊúÄÊñ∞Âú®ÂâçÔºåÈúÄË¶ÅÂèçËΩâÔºâ
            const segments = [];
            segmentEls.forEach(el => {
                // Ë™™Ë©±ËÄÖÊ®ôÁ±§Ôºàfont-weight: 600Ôºâ
                const speakerEl = el.querySelector('span[style*="font-weight: 600"]');
                // ÊôÇÈñìÊ®ôÁ±§Ôºàfont-size: 11pxÔºâ
                const timeEl = el.querySelector('span[style*="font-size: 11px"]');
                // Ëã±ÊñáÂéüÊñáÔºàfont-size: 18pxÔºâ
                const englishEl = el.querySelector('div[style*="font-size: 18px"]');
                // ‰∏≠ÊñáÁøªË≠ØÔºàcolor: var(--accent-blue)Ôºâ
                const chineseEl = el.querySelector('div[style*="font-size: 16px"]');

                segments.push({
                    speaker: speakerEl ? speakerEl.textContent.trim() : 'üë§ Â∞çÊñπ',
                    english: englishEl ? englishEl.textContent.trim() : '',
                    chinese: chineseEl ? chineseEl.textContent.trim() : '',
                    time: timeEl ? timeEl.textContent.trim() : ''
                });
            });

            // ÂèçËΩâÈ†ÜÂ∫èÔºàÊúÄËàäÁöÑÂú®ÂâçÔºâ
            segments.reverse();

            // ÂèñÂæóÂ†¥ÊôØÂêçÁ®±
            const scenarioName = SCENARIOS[selectedScenario]?.name || selectedScenario;

            // ÂèñÂæóÈÄöË©±ÊôÇÈñì
            const timerEl = document.getElementById('callTimer');
            const duration = timerEl ? timerEl.textContent : '00:00';

            // ÂèñÂæóÂÆåÊàêÊÆµÊï∏
            const doneCount = document.getElementById('doneCount').textContent || '0';

            // ÁîüÊàêÁï∂ÂâçÊó•ÊúüÊôÇÈñì
            const now = new Date();
            const dateStr = now.toLocaleDateString('zh-TW', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            const timeStr = now.toLocaleTimeString('zh-TW', {
                hour: '2-digit',
                minute: '2-digit'
            });

            // ÁîüÊàê Markdown ÂÖßÂÆπ
            let markdown = `# Ëã±ÊñáÂ∞çË©±Âä©Êâã - Â∞çË©±Ë®òÈåÑ

## Âü∫Êú¨Ë≥áË®ä

| È†ÖÁõÆ | ÂÖßÂÆπ |
|------|------|
| ÂåØÂá∫Êó•Êúü | ${dateStr} |
| ÂåØÂá∫ÊôÇÈñì | ${timeStr} |
| ÈÄöË©±ÊôÇÈï∑ | ${duration} |
| Â∑≤ÁøªË≠ØÊÆµÊï∏ | ${doneCount} ÊÆµ |
| ‰ΩøÁî®Â†¥ÊôØ | ${scenarioName} |

---

## Â∞çË©±ÂÖßÂÆπ

`;

            // Ê∑ªÂä†ÊØèÂÄãÊÆµËêΩ
            segments.forEach((seg, index) => {
                markdown += `### ${seg.speaker}`;
                if (seg.time) {
                    markdown += ` (${seg.time})`;
                }
                markdown += `

**Ëã±ÊñáÂéüÊñáÔºö**
> ${seg.english || '(ÁÑ°ÂÖßÂÆπ)'}

**‰∏≠ÊñáÁøªË≠ØÔºö**
> ${seg.chinese || '(ÁøªË≠Ø‰∏≠...)'}

---

`;
            });

            // Ê∑ªÂä†È†ÅÂ∞æ
            markdown += `
---

*Áî± English Conversation Assistant (ECA) ÁîüÊàê*
`;

            // ÁîüÊàêÊ™îÊ°àÂêçÁ®±
            const filename = `Â∞çË©±Ë®òÈåÑ_${dateStr.replace(/\//g, '-')}_${timeStr.replace(/:/g, '')}.md`;

            // ÂâµÂª∫‰∏ãËºâ
            const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log(`Â∑≤ÂåØÂá∫Â∞çË©±Ë®òÈåÑÔºö${filename}`, 'success');
        }

        // =============================================
        // Phase 1: Call Timer
        // =============================================

        let pausedElapsedTime = 0;  // Êö´ÂÅúÊôÇË®òÈåÑÁöÑÂ∑≤ÈÅéÊôÇÈñì

        function startCallTimer() {
            callStartTime = Date.now();
            pausedElapsedTime = 0;
            const timerEl = document.getElementById('callTimer');
            callTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000) + pausedElapsedTime;
                const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');
                timerEl.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function pauseCallTimer() {
            if (callTimerInterval) {
                // Ë®òÈåÑÊö´ÂÅúÊôÇÁöÑÂ∑≤ÈÅéÊôÇÈñì
                pausedElapsedTime += Math.floor((Date.now() - callStartTime) / 1000);
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
        }

        function resumeCallTimer() {
            if (!callTimerInterval) {
                // ÈáçÊñ∞ÈñãÂßãË®àÊôÇÔºåÂæûÊö´ÂÅúÈªûÁπºÁ∫å
                callStartTime = Date.now();
                const timerEl = document.getElementById('callTimer');
                callTimerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - callStartTime) / 1000) + pausedElapsedTime;
                    const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                    const seconds = String(elapsed % 60).padStart(2, '0');
                    timerEl.textContent = `${minutes}:${seconds}`;
                }, 1000);
            }
        }

        function stopCallTimer() {
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
            pausedElapsedTime = 0;
            const timerEl = document.getElementById('callTimer');
            if (timerEl) timerEl.textContent = '00:00';
        }

        // =============================================
        // Phase 1: Quick Response Bar ‚Äî Prepared Cards
        // =============================================

        function renderPreparedCards() {
            const row = document.getElementById('preparedCardsRow');
            const divider = document.getElementById('quickResponseDivider');
            const scripts = getSavedScripts();
            row.innerHTML = '';

            // Show max 3 cards (compact layout), ÊúÄÊñ∞ÁöÑÂÑ™ÂÖàÈ°ØÁ§∫
            const toShow = scripts.slice(-3).reverse();

            if (toShow.length > 0) {
                toShow.forEach(script => {
                    const card = document.createElement('button');
                    card.className = 'prepared-card';
                    card.setAttribute('tabindex', '0');
                    // È°ØÁ§∫‰∏≠ÊñáÂâçÂπæÂÄãÂ≠óÔºåÊñπ‰æøÁî®Êà∂Ëæ®Ë≠ò
                    const displayText = script.chinese || script.english;
                    const truncated = displayText.length > 8
                        ? displayText.substring(0, 8) + '...'
                        : displayText;
                    card.innerHTML = `
                        <span class="prepared-card-icon">
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                            </svg>
                        </span>
                        ${escapeHtml(truncated)}
                    `;
                    card.onclick = () => showTeleprompterOverlay(script.english, script.chinese);
                    row.appendChild(card);
                });
                // Show divider if we have cards
                if (divider) divider.style.display = '';
            } else {
                // Hide divider if no cards
                if (divider) divider.style.display = 'none';
            }
        }

        // =============================================
        // Phase 1: Quick Phrases
        // =============================================

        function showQuickPhrase(index) {
            const phrase = QUICK_PHRASES[index];
            if (!phrase) return;
            showTeleprompterOverlay(phrase.english, phrase.chinese);
        }

        // =============================================
        // Phase 1: Panic Button
        // =============================================

        function triggerPanic() {
            // Pick a random stalling phrase (avoid repeating last one)
            let idx;
            do {
                idx = Math.floor(Math.random() * STALLING_PHRASES.length);
            } while (idx === lastStallingIndex && STALLING_PHRASES.length > 1);
            lastStallingIndex = idx;

            const phrase = STALLING_PHRASES[idx];
            showTeleprompterOverlay(phrase.english, phrase.chinese, true);
        }

        // =============================================
        // Phase 1: Teleprompter Overlay
        // =============================================

        function showTeleprompterOverlay(english, chinese, showScripts) {
            const overlay = document.getElementById('teleprompterOverlay');
            document.getElementById('overlayEnglish').textContent = english;
            document.getElementById('overlayChinese').textContent = chinese || '';

            // Show/hide Chinese section
            const chineseEl = document.getElementById('overlayChinese');
            chineseEl.style.display = chinese ? '' : 'none';

            // Show prepared scripts in panic mode
            const scriptsSection = document.getElementById('overlayScripts');
            if (showScripts) {
                const scripts = getSavedScripts();
                const listEl = document.getElementById('overlayScriptsList');
                listEl.innerHTML = '';

                if (scripts.length > 0) {
                    scripts.forEach(script => {
                        const item = document.createElement('div');
                        item.className = 'teleprompter-overlay-script-item';
                        item.setAttribute('tabindex', '0');
                        item.innerHTML = `
                            <div class="teleprompter-overlay-script-item-en">${escapeHtml(script.english)}</div>
                            <div class="teleprompter-overlay-script-item-zh">${escapeHtml(script.chinese)}</div>
                        `;
                        item.onclick = () => {
                            document.getElementById('overlayEnglish').textContent = script.english;
                            document.getElementById('overlayChinese').textContent = script.chinese;
                            chineseEl.style.display = '';
                            scriptsSection.style.display = 'none';
                        };
                        listEl.appendChild(item);
                    });
                    scriptsSection.style.display = '';
                } else {
                    scriptsSection.style.display = 'none';
                }
            } else {
                scriptsSection.style.display = 'none';
            }

            overlay.classList.add('visible');
        }

        function closeTeleprompterOverlay(event) {
            // If called from click on backdrop, check target
            if (event && event.target !== document.getElementById('teleprompterOverlay')) return;
            document.getElementById('teleprompterOverlay').classList.remove('visible');
        }

        // Close overlay on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeTeleprompterOverlay();
            }
        });

        // =============================================
        // Phase 1: Start Listening (from preparation mode)
        // =============================================

        function startListening() {
            // This bridges preparation ‚Üí call mode via the existing startTest()
            startTest();
        }

        // =============================================
        // Script Generator Functions (design.md ¬ß 5)
        // =============================================

        let currentScript = '';
        let currentAlternatives = [];
        let isGenerating = false;

        /**
         * Handle Enter key in script input
         */
        function handleScriptInputKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                generateScript();
            }
        }

        /**
         * Generate English script from Chinese input
         * Uses streaming API for faster perceived response
         * If input is empty, uses scenario-appropriate default prompt
         */
        async function generateScript() {
            if (isGenerating) return;

            const input = document.getElementById('scriptInput').value.trim();
            // Empty input is OK - backend will use scenario default

            isGenerating = true;
            const btn = document.getElementById('btnGenerate');
            btn.disabled = true;
            btn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="animate-spin">
                    <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
                </svg>
                ÁîüÊàê‰∏≠...
            `;

            // Show teleprompter
            const teleprompter = document.getElementById('teleprompter');
            const scriptOutput = document.getElementById('scriptOutput');
            const alternativesSection = document.getElementById('alternativesSection');
            const alternativesList = document.getElementById('alternativesList');

            teleprompter.classList.add('visible');
            scriptOutput.innerHTML = '<span class="streaming-cursor"></span>';
            alternativesSection.style.display = 'none';

            currentScript = '';
            currentAlternatives = [];

            try {
                const response = await fetch('/api/script/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chinese_input: input,
                        context: {
                            scenario: selectedScenario,
                            tone: 'polite'
                        }
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));

                                if (data.type === 'using_default') {
                                    // Backend is using a default prompt - show it in input
                                    const scriptInputEl = document.getElementById('scriptInput');
                                    if (scriptInputEl && data.prompt) {
                                        scriptInputEl.value = data.prompt;
                                        log(`[Ë¨õÁ®ø] ‰ΩøÁî®È†êË®≠Ôºö${data.prompt}`, 'info');
                                    }
                                } else if (data.type === 'script_delta') {
                                    currentScript += data.text;
                                    scriptOutput.innerHTML = currentScript + '<span class="streaming-cursor"></span>';
                                } else if (data.type === 'script_done') {
                                    currentScript = data.text;
                                    scriptOutput.textContent = currentScript;
                                } else if (data.type === 'alternatives') {
                                    currentAlternatives = data.alternatives || [];
                                    if (currentAlternatives.length > 0) {
                                        alternativesSection.style.display = 'block';
                                        alternativesList.innerHTML = currentAlternatives
                                            .map(alt => `<div class="alternative-item" onclick="useAlternative('${escapeHtmlForAttr(alt)}')">${alt}</div>`)
                                            .join('');
                                    }
                                } else if (data.type === 'error') {
                                    scriptOutput.innerHTML = `<span style="color:var(--accent-red);">ÁîüÊàêÂ§±ÊïóÔºö${data.error}</span>`;
                                }
                            } catch (e) {
                                // Ignore parse errors for incomplete JSON
                            }
                        }
                    }
                }

                log(`[Ë¨õÁ®ø] ÁîüÊàêÂÆåÊàê: "${currentScript.substring(0, 50)}..."`, 'success');

            } catch (error) {
                console.error('Script generation error:', error);
                scriptOutput.innerHTML = `<span style="color:var(--accent-red);">ÁîüÊàêÂ§±ÊïóÔºö${error.message}</span>`;
                log(`[Ë¨õÁ®ø] ÈåØË™§: ${error.message}`, 'error');
            } finally {
                isGenerating = false;
                btn.disabled = false;
                btn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m5 12 7-7 7 7"></path>
                        <path d="M12 19V5"></path>
                    </svg>
                    ÁîüÊàêË¨õÁ®ø
                `;
            }
        }

        /**
         * Copy current script to clipboard
         */
        async function copyScript() {
            if (!currentScript) return;

            try {
                await navigator.clipboard.writeText(currentScript);
                // Show brief feedback
                const btn = event.target.closest('.teleprompter-action-btn');
                const originalText = btn.innerHTML;
                btn.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    Â∑≤Ë§áË£Ω
                `;
                setTimeout(() => { btn.innerHTML = originalText; }, 1500);
            } catch (error) {
                console.error('Copy failed:', error);
            }
        }

        /**
         * Regenerate script with same input
         */
        function regenerateScript() {
            generateScript();
        }

        /**
         * Use an alternative script
         */
        function useAlternative(text) {
            currentScript = text;
            document.getElementById('scriptOutput').textContent = text;
        }

        /**
         * Escape HTML for safe insertion
         */
        /**
         * Escape HTML for safe display (‰∏çËôïÁêÜÂñÆÂºïËôü)
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Escape HTML for use in onclick attributes (ËôïÁêÜÂñÆÂºïËôü)
         */
        function escapeHtmlForAttr(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/'/g, "\\'");
        }

        // DOM Elements
        const statusBadge = document.getElementById('statusBadge');
        const statusText = document.getElementById('statusText');
        const transcriptContent = document.getElementById('transcriptContent');
        const transcriptEmpty = document.getElementById('transcriptEmpty');
        const logPanel = document.getElementById('logPanel');

        // Stats (these are now in hidden div or call header)
        const segmentCountEl = document.getElementById('segmentCount');
        const activeCountEl = document.getElementById('activeCount');
        const doneCountEl = document.getElementById('doneCount');
        const queueCountEl = document.getElementById('queueCount');

        // ============================================
        // Logging
        // ============================================

        function log(msg, level = 'info') {
            const time = new Date().toLocaleTimeString('zh-TW');
            console.log(`[${level}] ${msg}`);
            // Log panel is hidden but still exists for debugging
            if (logPanel) {
                const entry = document.createElement('div');
                entry.className = `log-entry ${level}`;
                entry.textContent = `[${time}] ${msg}`;
                logPanel.appendChild(entry);
                logPanel.scrollTop = logPanel.scrollHeight;
            }
        }

        // ============================================
        // Status Updates
        // ============================================

        function updateStatus(status, text) {
            statusBadge.className = `status-badge ${status}`;
            statusText.textContent = text;
        }

        /**
         * ÈñÉÁàçÊèêÁ§∫Áî®Êà∂ÂèØ‰ª•ÈñãÂßãË™™Ë©±
         */
        function flashReadyIndicator() {
            // ÈñÉÁàçÁãÄÊÖãÊåáÁ§∫Âô®
            statusBadge.style.animation = 'flash-ready 0.5s ease-in-out 3';
            setTimeout(() => {
                statusBadge.style.animation = '';
            }, 1500);

            // Êõ¥Êñ∞Ëã±ÊñáÂéüÊñáÂçÄÂüüÊèêÁ§∫ - ‰ΩøÁî® Karaoke È´ò‰∫ÆÊïàÊûú
            const previewText = document.getElementById('previewText');
            if (previewText) {
                previewText.innerHTML = '<span class="preview-text-inner"><span class="interim">Ready! Start speaking...</span></span>';
            }
        }

        function updateStats() {
            if (!eventHandler) return;
            const store = eventHandler.getStore();

            const all = store.getAll();
            const active = store.getActiveSegments();
            const done = all.filter(s => s.status === 'done');
            const queue = store.pendingForResponse?.length || 0;

            segmentCountEl.textContent = all.length;
            activeCountEl.textContent = active.length;
            doneCountEl.textContent = done.length;
            queueCountEl.textContent = queue;
        }

        // ============================================
        // Initialize Modules
        // ============================================

        function initModules() {
            // Check if modules are loaded
            if (typeof EnhancedSegmentStore === 'undefined') {
                log('ERROR: segment_store.js not loaded!', 'error');
                return false;
            }
            if (typeof RealtimeEventHandler === 'undefined') {
                log('ERROR: realtime_event_handler.js not loaded!', 'error');
                return false;
            }
            if (typeof SegmentRenderer === 'undefined') {
                log('ERROR: segment_renderer.js not loaded!', 'error');
                return false;
            }

            // Initialize event handler (creates EnhancedSegmentStore internally)
            eventHandler = new RealtimeEventHandler();

            // Initialize renderer
            renderer = new SegmentRenderer(transcriptContent);

            // Inject styles
            if (typeof injectSegmentRendererStyles === 'function') {
                injectSegmentRendererStyles();
            }

            // Connect event handler to renderer
            // ‚ö†Ô∏è ÊñπÊ°à A Êû∂ÊßãÔºöUI Ê∏≤ÊüìÁî± SmartSegmenter ÁöÑ translateViaBackend() ÊéßÂà∂
            // RealtimeEventHandler Âè™Ë®òÈåÑÊó•Ë™åÔºå‰∏çÊ∏≤Êüì UI segments
            // ÈÄôÈÅøÂÖç‰∫Ü„ÄåÂ≠§ÂÖí segment„ÄçÂïèÈ°åÔºàOpenAI ËΩâÈåÑÂâµÂª∫ÁöÑ segment Ê≤íÊúâÁøªË≠ØÔºâ
            eventHandler.onSegmentUpdate = (segment) => {
                // ‰∏çÊ∏≤Êüì OpenAI ÁöÑ segmentsÔºåÂè™Ë®òÈåÑ
                // renderer.queueUpdate(segment);
                // updateStats();
            };

            // Connect logging
            eventHandler.onLog = (msg, level) => {
                log(msg, level);
            };

            // Error handling
            eventHandler.onError = (error) => {
                log(`API Error: ${error.message || error.code}`, 'error');
            };

            // Initialize Smart Segmenter with current preset
            if (typeof SmartSegmenter !== 'undefined') {
                const preset = SEGMENTER_PRESETS[currentPreset];

                // Use AdaptiveSegmenter for dynamic WPM adjustment
                smartSegmenter = new AdaptiveSegmenter({
                    pauseThreshold: preset.pauseThreshold,
                    stabilityDelay: preset.stabilityDelay,
                    softLimit: preset.softLimit,
                    hardLimit: preset.hardLimit,
                    minSegmentWords: preset.minSegmentWords
                });

                // When segment detected, translate via backend API (ÊñπÊ°à A)
                smartSegmenter.onSegment = (segment, info) => {
                    const speaker = currentSpeaker;  // ÊçïÁç≤Áï∂ÂâçË™™Ë©±ËÄÖ
                    log(`SmartSegmenter: "${segment.substring(0, 40)}..." (${info.wordCount}w, ${info.reason}, speaker: ${speaker})`, 'event');

                    // üîß ÊñπÊ°à A: ÂÖ©ÈöéÊÆµÊû∂Êßã + ËßíËâ≤Ê®ôË®ò
                    // ‰∏çÂÜç‰ΩøÁî® OpenAI Realtime API ÁøªË≠ØÔºàÊúÉËÆäÊàê Q&A Â∞çË©±Ôºâ
                    // ÊîπÁî® gpt-4.1-nano ÊñáÂ≠ó API ÁøªË≠ØÔºå‰∏¶ÂÇ≥ÂÖ•Ë™™Ë©±ËÄÖÊ®ôË®ò
                    translateViaBackend(segment, speaker);
                };

                log(`SmartSegmenter initialized (preset: ${preset.name}, Êö´ÂÅú:${preset.pauseThreshold}ms)`, 'success');
            } else {
                log('smart_segmenter.js not loaded - using OpenAI default (2-3s)', 'warn');
            }

            // Initialize Web Speech for real-time English subtitles
            if (typeof WebSpeechRealtime !== 'undefined') {
                webSpeech = new WebSpeechRealtime();

                if (webSpeech.isSupported()) {
                    // ÂØ¶ÊôÇËã±ÊñáÂõûË™ø - ÈÇäË™™ÈÇäÈ°ØÁ§∫ + Êô∫ËÉΩÂàÜÊÆµ
                    // üîß ËßíËâ≤Ê®ôË®òÊ®°ÂºèÔºö‰∏çË´ñË™∞Âú®Ë™™Ë©±ÈÉΩËôïÁêÜÔºåspeaker Ê®ôË®òÂú® translateViaBackend ‰∏≠Ë®≠ÂÆö
                    webSpeech.onInterimResult = (fullText, interim) => {
                        currentRealtimeEnglish = fullText;
                        updateRealtimePreview(fullText, interim);

                        // Feed to SmartSegmenter
                        if (smartSegmenter) {
                            smartSegmenter.process(fullText, false);
                        }
                    };

                    // Web Speech final result
                    // Ê≥®ÊÑèÔºö‰∏çÈúÄË¶ÅÂú®ÈÄôË£°ÂÜçÊ¨°Ë™øÁî® SmartSegmenter.process()
                    // Âõ†ÁÇ∫ onInterimResult Â∑≤Á∂ìÂåÖÂê´‰∫ÜÊúÄÁµÇÊñáÂ≠óÔºåËÄå‰∏î SmartSegmenter
                    // ÊúâËá™Â∑±ÁöÑÂÅúÈ†ìÂÅµÊ∏¨Ê©üÂà∂Ôºà600msÔºâ‰æÜÊ±∫ÂÆö‰ΩïÊôÇÂàÜÊÆµ„ÄÇ
                    // Web Speech ÁöÑ "final" Âè™Ë°®Á§∫„ÄåÁ¢∫Ë™çÈÄôÊÆµÊñáÂ≠ó„ÄçÔºå‰∏çÊòØ„ÄåÁî®Êà∂ÂÅúÊ≠¢Ë™™Ë©±„Äç„ÄÇ
                    webSpeech.onFinalResult = (finalText) => {
                        // ÂÉÖË®òÈåÑÔºå‰∏çË™øÁî® SmartSegmenter
                        // SmartSegmenter Â∑≤Âæû onInterimResult Áç≤ÂæóÁ¥ØÁ©çÊñáÂ≠ó
                        console.log('[WebSpeech] Final result received:', finalText.substring(0, 40));
                    };

                    webSpeech.onError = (error, message) => {
                        log(`WebSpeech error: ${error}`, 'warn');
                    };

                    // Èü≥Ë®äÈñãÂßãÊî∂ÈåÑ - ÈÄôÊôÇÁî®Êà∂ÂèØ‰ª•ÈñãÂßãË™™Ë©±
                    webSpeech.onAudioStart = () => {
                        log('Audio capture ready - you can speak now!', 'success');
                        updateStatus('connected', 'ÁøªË≠Ø‰∏≠');
                        // ÂàùÂßãÂåñË™™Ë©±ËÄÖÊåáÁ§∫Âô®ÔºàÈ†êË®≠ÁÇ∫„ÄåÂ∞çÊñπË™™Ë©±„ÄçÔºâ
                        updateSpeakerIndicator('them');
                        // ÈñÉÁàçÊèêÁ§∫Áî®Êà∂ÂèØ‰ª•ÈñãÂßãË™™Ë©±
                        flashReadyIndicator();
                    };

                    log('WebSpeech initialized for real-time English subtitles', 'success');
                } else {
                    log('WebSpeech not supported in this browser', 'warn');
                }
            } else {
                log('webspeech_realtime.js not loaded', 'warn');
            }

            log('Modules initialized: EnhancedSegmentStore, RealtimeEventHandler, SegmentRenderer', 'success');
            return true;
        }

        // Êõ¥Êñ∞ÂØ¶ÊôÇËã±ÊñáÈ†êË¶ΩÔºàKaraoke È¢®Ê†ºÔºâ
        function updateRealtimePreview(fullText, interim) {
            let previewEl = document.getElementById('realtimePreview');
            const container = document.getElementById('realtimePreviewContainer');

            if (!previewEl && container) {
                // ÂâµÂª∫ÂØ¶ÊôÇÈ†êË¶ΩÂçÄÂüüÔºàÈ†êË®≠Êî∂ÂêàÔºåÂñÆË°åÈ°ØÁ§∫ÊúÄÂæåÊñáÂ≠óÔºâ
                previewEl = document.createElement('div');
                previewEl.id = 'realtimePreview';
                previewEl.className = 'realtime-preview';
                previewEl.innerHTML = `
                    <div class="preview-label preview-toggle" onclick="toggleRealtimePreview()">
                        <span class="toggle-icon">‚ñº</span>
                        <span>Ëã±ÊñáÂéüÊñá</span>
                    </div>
                    <div class="preview-text" id="previewText"><span class="preview-text-inner">Á≠âÂæÖË™ûÈü≥...</span></div>
                `;
                container.appendChild(previewEl);
            }

            if (!previewEl) return;

            // ÁßªÈô§ stopped ÁãÄÊÖãÔºàÂ¶ÇÊûúÊúâÔºâ
            previewEl.classList.remove('stopped');

            const textEl = document.getElementById('previewText');
            if (textEl) {
                const displayText = fullText || 'Á≠âÂæÖË™ûÈü≥...';

                // Karaoke ÊïàÊûúÔºöÂ∑≤Á¢∫Ë™çÊñáÂ≠óËºÉÊöóÔºåÊ≠£Âú®Ë™™ÁöÑÊñáÂ≠óÈ´ò‰∫ÆÁôºÂÖâ
                if (interim) {
                    const finalPart = fullText.slice(0, fullText.length - interim.length);
                    textEl.innerHTML = '<span class="preview-text-inner">' +
                        '<span class="final-text">' + escapeHtml(finalPart) + '</span>' +
                        '<span class="interim">' + escapeHtml(interim) + '</span>' +
                        '</span>';
                } else {
                    // Ê≤íÊúâ interim ÊôÇÔºåÂÖ®ÈÉ®È°ØÁ§∫ÁÇ∫Â∑≤Á¢∫Ë™ç
                    textEl.innerHTML = '<span class="preview-text-inner">' +
                        '<span class="final-text">' + escapeHtml(displayText) + '</span>' +
                        '</span>';
                }

                // Â±ïÈñãÁãÄÊÖãÊôÇÔºåËá™ÂãïÊç≤ÂãïÂà∞ÊúÄÊñ∞ÂÖßÂÆπ
                if (previewEl.classList.contains('expanded')) {
                    textEl.scrollTop = textEl.scrollHeight;
                }
            }
        }

        // Toggle ÂØ¶ÊôÇÈ†êË¶ΩÁöÑÂ±ïÈñã/Êî∂Âêà
        function toggleRealtimePreview() {
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.classList.toggle('expanded');

                // Â±ïÈñãÊôÇËá™ÂãïÊç≤ÂãïÂà∞ÊúÄÊñ∞ÂÖßÂÆπ
                if (previewEl.classList.contains('expanded')) {
                    const textEl = document.getElementById('previewText');
                    if (textEl) {
                        // ‰ΩøÁî® setTimeout Á¢∫‰øù DOM Êõ¥Êñ∞ÂæåÂÜçÊç≤Âãï
                        setTimeout(() => {
                            textEl.scrollTop = textEl.scrollHeight;
                        }, 50);
                    }
                }
            }
        }

        // ============================================
        // Start Test
        // ============================================

        async function startTest() {
            // Initialize modules if not done
            if (!eventHandler) {
                if (!initModules()) {
                    return;
                }
            }

            // Check AudioCapture
            if (!audioCapture) {
                log('ERROR: AudioCapture not loaded!', 'error');
                return;
            }

            // ====== ÂïèÈ°å 4 ‰øÆÂæ©ÔºöÊ∏ÖÁêÜËàäÊï∏Êìö ======
            // Clear previous segment data
            if (eventHandler && eventHandler.getStore()) {
                eventHandler.getStore().reset();
                log('Cleared previous segment data', 'info');
            }
            currentRealtimeEnglish = '';

            // Reset SmartSegmenter state
            if (smartSegmenter) {
                smartSegmenter.reset();
            }

            // Clear UI: remove old segment items
            const oldSegmentItems = document.querySelectorAll('.segment-item');
            oldSegmentItems.forEach(el => el.remove());

            // Remove old realtime preview if exists
            const oldPreview = document.getElementById('realtimePreview');
            if (oldPreview) {
                oldPreview.remove();
            }

            // Reset pause state
            isPaused = false;
            document.getElementById('btnPause').style.display = '';
            document.getElementById('btnResume').style.display = 'none';

            // Reset stats
            updateStats();
            // ====== ÂïèÈ°å 4 ‰øÆÂæ©ÁµêÊùü ======

            try {
                updateStatus('connecting', 'ÈÄ£Á∑ö‰∏≠...');
                document.getElementById('btnStartListening').disabled = true;

                // Step 1: Capture microphone
                log('Requesting microphone access...');
                const audioStream = await audioCapture.captureMicrophone();
                log('Microphone access granted', 'success');

                // Step 1.5: Start Web Speech IMMEDIATELY after mic access
                // This prevents missing the first few words while waiting for token/WebRTC
                if (webSpeech && webSpeech.isSupported()) {
                    // üîß ‰ΩøÁî®„ÄåÂ∞çÊñπÂè£Èü≥„ÄçË®≠ÂÆöÂïüÂãï
                    webSpeech.setLanguage(accentThem, false);  // false = ‰∏çÈáçÂïüÔºàÈÇÑÊ≤íÈñãÂßãÔºâ
                    webSpeech.start();
                    log(`WebSpeech started early (${accentThem})`, 'success');
                }

                // Start Smart Segmenter early too
                if (smartSegmenter) {
                    smartSegmenter.start();
                    log('SmartSegmenter started early', 'success');
                }

                // Step 2: Get ephemeral token (runs in parallel with Web Speech)
                log('Getting ephemeral token...');
                const tokenResponse = await fetch('/api/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ voice: 'marin' })
                });

                if (!tokenResponse.ok) {
                    throw new Error('Failed to get token');
                }

                const tokenData = await tokenResponse.json();
                log('Token received', 'success');

                // Step 3: Setup WebRTC
                await setupWebRTC(audioStream, tokenData.client_secret);

                // UI updates: switch to call mode
                isConnected = true;
                transcriptEmpty.style.display = 'flex';
                switchToCallMode();

            } catch (error) {
                log(`Start failed: ${error.message}`, 'error');
                resetUI();
                document.getElementById('btnStartListening').disabled = false;
            }
        }

        async function setupWebRTC(audioStream, clientSecret) {
            const rtcConfig = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(rtcConfig);

            // Add audio track
            const audioTrack = audioStream.getAudioTracks()[0];
            peerConnection.addTrack(audioTrack, audioStream);
            log('Audio track added');

            // Handle remote audio (not needed for translation, but required by API)
            peerConnection.ontrack = (event) => {
                log('Remote track received', 'event');
            };

            // Create data channel
            dataChannel = peerConnection.createDataChannel('oai-events');
            setupDataChannel();

            // ICE state handling
            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE state: ${peerConnection.iceConnectionState}`, 'event');
                if (peerConnection.iceConnectionState === 'connected') {
                    // ÈÄ£Á∑öÊàêÂäüÔºå‰ΩÜÈÇÑË¶ÅÁ≠â Web Speech Ê∫ñÂÇôÂ•ΩÊâçËÉΩÈñãÂßãË™™Ë©±
                    updateStatus('connecting', 'Ê∫ñÂÇô‰∏≠...');
                } else if (peerConnection.iceConnectionState === 'failed') {
                    stopTest();
                }
            };

            // Create and send offer
            await peerConnection.setLocalDescription();
            log('SDP offer created');

            const sdpResponse = await fetch('https://api.openai.com/v1/realtime/calls', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${clientSecret}`,
                    'Content-Type': 'application/sdp'
                },
                body: peerConnection.localDescription.sdp
            });

            if (!sdpResponse.ok) {
                throw new Error(`SDP exchange failed: ${sdpResponse.status}`);
            }

            const answerSdp = await sdpResponse.text();
            await peerConnection.setRemoteDescription({
                type: 'answer',
                sdp: answerSdp
            });

            log('WebRTC connected', 'success');
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                log('Data channel opened', 'success');
                sendSessionUpdate();
            };

            dataChannel.onclose = () => {
                log('Data channel closed', 'warn');
            };

            dataChannel.onerror = (error) => {
                log(`Data channel error: ${error}`, 'error');
            };

            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                // Route to new event handler
                eventHandler.handle(data);
            };
        }

        function sendSessionUpdate() {
            // Translation mode session configuration
            // Uses GA API format (2025)
            //
            // üîß Smart Segmentation Strategy (2026-02-02):
            // - create_response: false ‚Üí Á¶ÅÁî® OpenAI ÁöÑËá™ÂãïÂàÜÊÆµÔºà2-3s Âª∂ÈÅ≤Ôºâ
            // - ÂâçÁ´Ø SmartSegmenter ÊéßÂà∂ÂàÜÊÆµÔºà600ms ÈñæÂÄºÔºâ
            // - Ë¶ã spec/research/speech_segmentation.md
            //
            // üîß Fix Test 21 Issues (2026-02-02):
            // - 2.2a Á∞°È´î‚ÜíÁπÅÈ´îÔºöÊòéÁ¢∫ÊåáÂÆö "Traditional Chinese (Hong Kong)" + Ë≤†Èù¢ÁØÑ‰æã
            // - 2.2b Q&A‚ÜíÁøªË≠ØÔºöÊé°Áî® Twilio È¢®Ê†º prompt "translation machine"
            // - Reference: https://github.com/twilio-samples/live-translation-openai-realtime-api
            const sessionConfig = {
                type: 'session.update',
                session: {
                    type: 'realtime',
                    // üîß Twilio-style translation prompt (Test 21 fix)
                    // Key elements:
                    // 1. "translation machine" identity - prevents dialogue mode
                    // 2. Explicit "Traditional Chinese (Hong Kong)" - prevents simplified Chinese
                    // 3. Negative examples - prevents common errors
                    instructions: `You are a translation machine. Your sole function is to translate English audio to Traditional Chinese (Hong Kong style, ÁπÅÈ´î‰∏≠Êñá).

CRITICAL RULES:
- Do NOT respond to the audio content. Do NOT have a dialogue.
- Do NOT say "ÊàëÊòéÁôΩ", "Â•ΩÁöÑ", "Ë´ãÂïè", or any conversational phrases.
- Output ONLY the Chinese translation, nothing else.
- Use Traditional Chinese characters (ÁπÅÈ´îÂ≠ó), NOT Simplified Chinese (ÁÆÄ‰ΩìÂ≠ó).
  ‚úì Correct: Ë™™Ë©±„ÄÅÂ≠∏Áøí„ÄÅÈõªË©±„ÄÅÁ∂ìÊøü
  ‚úó Wrong: ËØ¥ËØù„ÄÅÂ≠¶‰π†„ÄÅÁîµËØù„ÄÅÁªèÊµé

FORMAT:
- Proper nouns: HK-style with English in brackets, e.g., "ÊõºÂæ∑ÁàæÊ£Æ (Peter Mandelson)"
- Numbers: Keep as digits, e.g., "$75,000", "2019Âπ¥"
- Output: Pure translation text only`,
                    output_modalities: ['text'],
                    audio: {
                        input: {
                            format: { type: 'audio/pcm', rate: 24000 },
                            transcription: {
                                model: 'gpt-4o-mini-transcribe',
                                language: 'en'  // üîß Âº∑Âà∂Ëã±ÊñáËΩâÈåÑÔºåÈÅøÂÖçË™§Ë≠òÂà•ÁÇ∫ÂÖ∂‰ªñË™ûË®Ä
                            },
                            turn_detection: {
                                type: 'semantic_vad',
                                eagerness: 'high',
                                // üîß Disable auto response - SmartSegmenter controls segmentation
                                create_response: false,
                                interrupt_response: false
                            }
                        }
                    }
                }
            };

            sendEvent(sessionConfig);
            log('Session configured: Twilio-style translation prompt + SmartSegmenter (600ms)');

            // ‚ö†Ô∏è ÁßªÈô§ few-shot priming - Á∂ìÊ∏¨Ë©¶ÁôºÁèæÊúÉËÆìÊ®°ÂûãÈÄ≤ÂÖ•Â∞çË©±Ê®°Âºè
            // ÂéüÂõ†ÔºöTEXT ÁØÑ‰æãËàá AUDIO Ëº∏ÂÖ•‰∏çÂêåÔºåÊ®°ÂûãÊúÉË™çÁÇ∫Âú®Â∞çË©±
            // ÊîπÁî®Êõ¥Âº∑ÁöÑ session instructions + response.create instructions
        }

        function sendEvent(event) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(event));
            }
        }

        /**
         * Force translation by sending response.create event
         * This bypasses OpenAI's 2-3s semantic_vad delay
         *
         * See: src/skills/openai-realtime-mini-voice/SKILL.md
         *
         * üêõ Bug fix (2026-02-02):
         * - response.create Ê†ºÂºèÊáâË©≤ÊòØ { conversation: "auto" }Ôºå‰∏çÊòØ { modalities: ["text"] }
         * - Ê∑ªÂä†Èò≤ÊäñÊ©üÂà∂ÔºåÈÅøÂÖçÈ†ªÁπÅËß∏Áôº
         * - Ê∑ªÂä†ÊúÄÂ∞èÈñìÈöîÊ™¢Êü•
         */
        let lastForceTranslationTime = 0;
        const MIN_TRANSLATION_INTERVAL = 500;  // ÊúÄÂ∞ë 500ms ÈñìÈöî

        function forceTranslation() {
            if (!dataChannel || dataChannel.readyState !== 'open') {
                log('Cannot force translation: data channel not open', 'warn');
                return;
            }

            // Èò≤ÊäñÔºöÁ¢∫‰øùÊúÄÂ∞ë 500ms ÈñìÈöî
            const now = Date.now();
            if (now - lastForceTranslationTime < MIN_TRANSLATION_INTERVAL) {
                // Â§™È†ªÁπÅÔºåË∑≥ÈÅé
                return;
            }
            lastForceTranslationTime = now;

            // Commit current audio buffer and create response
            // This tells OpenAI: "I've finished speaking this segment, process it now"
            const commitEvent = {
                type: 'input_audio_buffer.commit'
            };
            sendEvent(commitEvent);

            // Create response (translation)
            // üîß Test 21 fix: Âº∑ÂåñÁøªË≠ØË°åÁÇ∫
            // 1. ÊòéÁ¢∫ÊåáÂÆöÁπÅÈ´î‰∏≠Êñá
            // 2. Á¶ÅÊ≠¢Â∞çË©±Ê®°Âºè
            const responseEvent = {
                type: 'response.create',
                response: {
                    conversation: 'auto',
                    // üîß Twilio-style: Âº∑ÂåñÁøªË≠ØÊåá‰ª§
                    instructions: 'Translate to Traditional Chinese (ÁπÅÈ´î‰∏≠Êñá). Output ONLY the translation. No dialogue, no "ÊàëÊòéÁôΩ", no "Â•ΩÁöÑ", no questions. Use Traditional characters (Ë™™Ë©± not ËØ¥ËØù).'
                }
            };
            sendEvent(responseEvent);

            log('Force translation triggered (Traditional Chinese)', 'event');
        }

        // ============================================
        // ÊñπÊ°à A: ‰∏≤ÊµÅÁøªË≠Ø API (gpt-4o-mini + SSE)
        // È¶ñÂ≠óÂõûÊáâÁ¥Ñ 0.3 Áßí
        // ============================================

        let segmentCounter = 0;

        /**
         * ÈÄèÈÅé‰∏≤ÊµÅ API ÁøªË≠ØËã±ÊñáÊÆµËêΩ
         * ÊñπÊ°à A: ÂÖ©ÈöéÊÆµÊû∂Êßã + ‰∏≤ÊµÅÂõûÊáâ
         * - Web Speech API ‚Üí Ëã±Êñá STT
         * - gpt-4o-mini ‚Üí ÊñáÂ≠óÁøªË≠ØÔºà‰∏≤ÊµÅÔºâ
         *
         * ÂÑ™ÈªûÔºöÈ¶ñÂ≠óÂõûÊáâÁ¥Ñ 0.3 ÁßíÔºåÁî®Êà∂ÂèØ‰ª•ÈÇäÁúãÈÇäËÆÄ
         */
        async function translateViaBackend(englishText, speaker = 'them') {
            if (!englishText || englishText.trim().length === 0) {
                return;
            }

            // ÂâµÂª∫ segment Áî®Êñº UI È°ØÁ§∫ÔºàÂåÖÂê´Ë™™Ë©±ËÄÖÊ®ôË®òÔºâ
            const segmentId = `seg-${++segmentCounter}`;
            const segment = {
                id: segmentId,
                englishText: englishText.trim(),
                chineseTranslation: '',
                status: 'translating',
                speaker: speaker,  // 'them' Êàñ 'me'
                createdAt: Date.now(),
                completedAt: null,
                error: null
            };

            // Á´ãÂç≥È°ØÁ§∫Ëã±ÊñáÔºàÁãÄÊÖãÔºöÁøªË≠Ø‰∏≠Ôºâ
            renderSegment(segment);
            updateStats();

            const startTime = Date.now();
            log(`[‰∏≤ÊµÅ] ÈñãÂßãÁøªË≠Ø: "${englishText.substring(0, 30)}..."`, 'event');

            // Ê™¢Êü• API Key
            const apiKey = getApiKey();
            if (!apiKey) {
                log('[ÁøªË≠Ø] Êú™Ë®≠ÂÆö API KeyÔºåË´ãÂú®Ë®≠ÂÆöÈ†ÅËº∏ÂÖ•', 'error');
                segment.status = 'error';
                segment.chineseTranslation = t('apiKeyRequired');
                renderSegment(segment);
                return;
            }
            log(`[ÁøªË≠Ø] ‰ΩøÁî® API Key: ${apiKey.substring(0, 8)}...`, 'info');

            try {
                // ‰ΩøÁî®‰∏≤ÊµÅ APIÔºàÂ∏∂Â†¥ÊôØË©ûÂ∫´ÊîØÊè¥ + Áî®Êà∂ API KeyÔºâ
                const response = await fetch('/api/translate/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey  // Áî®Êà∂Êèê‰æõÁöÑ API Key
                    },
                    body: JSON.stringify({
                        text: englishText.trim(),
                        scenario: selectedScenario  // ÂÇ≥ÈÅûÂ†¥ÊôØ‰ª•ÂïüÁî®Ë©ûÂ∫´
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    log(`[ÁøªË≠Ø] API ÈåØË™§: ${response.status} - ${errorText}`, 'error');
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let firstChunkTime = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        log(`[‰∏≤ÊµÅ] Stream ended, translation so far: "${segment.chineseTranslation}"`, 'info');
                        break;
                    }

                    const text = decoder.decode(value, { stream: true });
                    log(`[‰∏≤ÊµÅ] Raw chunk: ${text.substring(0, 100)}...`, 'debug');
                    const lines = text.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            let data;
                            try {
                                data = JSON.parse(line.slice(6));
                            } catch (parseErr) {
                                // JSON parse error, skip this line
                                continue;
                            }

                            log(`[‰∏≤ÊµÅ] Parsed data: ${JSON.stringify(data)}`, 'debug');

                            // üêõ ‰øÆÂæ©ÔºöAPI ÈåØË™§Ë¶ÅÊ≠£Á¢∫ËôïÁêÜÔºå‰∏çÊòØÈùúÈªòÂøΩÁï•
                            if (data.error) {
                                log(`[‰∏≤ÊµÅ] API ËøîÂõûÈåØË™§: ${data.error}`, 'error');
                                segment.status = 'error';
                                segment.error = data.error;
                                segment.chineseTranslation = `[ÁøªË≠ØÂ§±Êïó] ${data.error}`;
                                renderSegment(segment);
                                updateStats();
                                return;  // ÁµÇÊ≠¢ÁøªË≠Ø
                            }

                            if (data.text) {
                                // Ë®òÈåÑÈ¶ñÂ≠óÊôÇÈñì
                                if (!firstChunkTime) {
                                    firstChunkTime = Date.now() - startTime;
                                    log(`[‰∏≤ÊµÅ] È¶ñÂ≠óÂõûÊáâ: ${firstChunkTime}ms`, 'success');
                                }

                                // Á¥ØÂä†ÁøªË≠ØÊñáÂ≠ó
                                segment.chineseTranslation += data.text;
                                // Âç≥ÊôÇÊõ¥Êñ∞ UI
                                renderSegment(segment);
                            }

                            if (data.done) {
                                // ÂÆåÊàê
                                segment.status = 'done';
                                segment.completedAt = Date.now();

                                // È©óË≠âÁøªË≠ØÂìÅË≥™
                                if (window.TranslationValidator) {
                                    const validator = new TranslationValidator();
                                    segment.validation = validator.validate(
                                        segment.englishText,
                                        segment.chineseTranslation,
                                        selectedScenario
                                    );
                                    if (segment.validation.showWarning) {
                                        log(`[È©óË≠â] Ë≠¶Âëä: ${segment.validation.warnings.map(w => w.message).join(', ')}`, 'warning');
                                    }
                                }

                                renderSegment(segment);
                                updateStats();

                                const totalTime = Date.now() - startTime;
                                log(`[‰∏≤ÊµÅ] ÂÆåÊàê: ${totalTime}ms, "${segment.chineseTranslation.substring(0, 30)}..."`, 'success');
                            }
                        }
                    }
                }

                // Á¢∫‰øùÊ®ôË®òÁÇ∫ÂÆåÊàêÔºàÂè™ÊúâÊàêÂäüÊôÇÊâçÊ®ôË®òÔºåÈåØË™§ÊÉÖÊ≥ÅÂ∑≤Âú®‰∏äÈù¢ËôïÁêÜÔºâ
                if (segment.status === 'translating') {
                    segment.status = 'done';
                    segment.completedAt = Date.now();
                    renderSegment(segment);
                    updateStats();
                }

            } catch (error) {
                // ÈåØË™§ËôïÁêÜ
                segment.status = 'error';
                segment.error = error.message;
                segment.chineseTranslation = `[ÁøªË≠ØÂ§±Êïó] ${error.message}`;

                renderSegment(segment);
                updateStats();

                log(`[‰∏≤ÊµÅ] ÁøªË≠ØÈåØË™§: ${error.message}`, 'error');
            }
        }

        /**
         * Ê∏≤ÊüìÂñÆÂÄã segment Âà∞ UI
         * Á∞°ÂåñÁâàÔºöÁõ¥Êé•Êìç‰Ωú DOMÔºå‰∏ç‰æùË≥¥ SegmentRenderer
         * ÊîØÊè¥Ë™™Ë©±ËÄÖÊ®ôË®òÔºàspeaker: 'them' | 'me'Ôºâ
         */
        function renderSegment(segment) {
            // Èö±ËóèÁ©∫ÁãÄÊÖã
            transcriptEmpty.style.display = 'none';

            let segmentEl = document.getElementById(segment.id);

            // Ë™™Ë©±ËÄÖÊ®£Âºè
            const isMe = segment.speaker === 'me';
            const speakerLabel = isMe ? 'üôã Êàë' : 'üë§ Â∞çÊñπ';
            const speakerColor = isMe ? 'var(--accent-blue)' : 'var(--accent-green)';
            const borderColor = isMe ? 'var(--accent-blue)' : 'var(--accent-green)';
            const bgTint = isMe ? 'rgba(0, 212, 255, 0.08)' : 'rgba(0, 255, 136, 0.08)';

            if (!segmentEl) {
                // ÂâµÂª∫Êñ∞ÁöÑ segment ÂÖÉÁ¥†
                segmentEl = document.createElement('div');
                segmentEl.id = segment.id;
                segmentEl.className = 'segment-item';
                transcriptContent.insertBefore(segmentEl, transcriptContent.firstChild);
            }

            // ÊáâÁî®Ë™™Ë©±ËÄÖÊ®£Âºè
            segmentEl.style.cssText = `
                background: ${bgTint};
                border-radius: 8px;
                padding: 12px 16px;
                margin-bottom: 12px;
                border-left: 3px solid ${borderColor};
            `;

            // ÁãÄÊÖãÈ°èËâ≤
            const statusColors = {
                'translating': 'var(--accent-yellow)',
                'done': 'var(--accent-green)',
                'error': 'var(--accent-red)'
            };
            const statusIcons = {
                'translating': '‚è≥',
                'done': '‚úÖ',
                'error': '‚ùå'
            };
            const statusTexts = {
                'translating': 'ÁøªË≠Ø‰∏≠...',
                'done': 'ÂÆåÊàê',
                'error': 'ÈåØË™§'
            };

            // Â¶ÇÊûúÊúâÈ©óË≠âË≠¶ÂëäÔºåÊîπËÆäÈÇäÊ°ÜÈ°èËâ≤ÔºàË¶ÜËìãË™™Ë©±ËÄÖÈ°èËâ≤Ôºâ
            if (segment.validation && segment.validation.showWarning) {
                segmentEl.style.borderLeftColor = 'var(--accent-yellow)';
            }

            // ÊôÇÈñìÊ†ºÂºè
            const time = new Date(segment.createdAt).toLocaleTimeString('zh-TW');

            // ÊßãÂª∫Ë≠¶Âëä HTMLÔºàÂ¶ÇÊûúÊúâÁöÑË©±Ôºâ
            let warningHtml = '';
            if (segment.validation && segment.validation.showWarning && segment.validation.warnings.length > 0) {
                const warningMessages = segment.validation.warnings
                    .filter(w => w.severity === 'high')
                    .map(w => w.message)
                    .slice(0, 2)  // ÊúÄÂ§öÈ°ØÁ§∫ 2 Ê¢ùË≠¶Âëä
                    .join('Ôºõ');

                if (warningMessages) {
                    warningHtml = `
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            padding: 6px 10px;
                            background: rgba(255, 170, 0, 0.1);
                            border-radius: 4px;
                            font-size: 12px;
                            color: var(--accent-yellow);
                            margin-top: 8px;
                        ">
                            <span>‚ö†Ô∏è</span>
                            <span>${warningMessages}ÔºåË´ãÂ∞çÁÖßËã±ÊñáÂéüÊñá</span>
                        </div>
                    `;
                }
            }

            segmentEl.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="font-size: 12px; color: ${speakerColor}; font-weight: 600;">${speakerLabel}</span>
                    <span style="font-size: 11px; color: var(--text-secondary);">${time}</span>
                </div>
                <div style="font-size: 18px; color: var(--text-primary); margin-bottom: 8px;">${segment.englishText}</div>
                <div style="font-size: 16px; color: var(--accent-blue); margin-bottom: 8px;">
                    ${segment.chineseTranslation || '<span style="color: var(--text-secondary);">ÁøªË≠Ø‰∏≠...</span>'}
                </div>
                ${warningHtml}
                <div style="display: flex; justify-content: flex-end; font-size: 12px; color: var(--text-secondary);">
                    <span style="color: ${statusColors[segment.status]}">${statusIcons[segment.status]} ${statusTexts[segment.status]}</span>
                </div>
            `;
        }

        /**
         * Êõ¥Êñ∞Áµ±Ë®àÊï∏ÊìöÔºàÊñπÊ°à A ÁâàÊú¨Ôºâ
         */
        function updateStats() {
            const segments = document.querySelectorAll('.segment-item');
            const total = segments.length;
            let done = 0;
            let active = 0;

            segments.forEach(el => {
                const html = el.innerHTML;
                if (html.includes('‚úÖ') || html.includes('ÂÆåÊàê')) {
                    done++;
                } else if (html.includes('‚è≥') || html.includes('ÁøªË≠Ø‰∏≠')) {
                    active++;
                }
            });

            segmentCountEl.textContent = total;
            activeCountEl.textContent = active;
            doneCountEl.textContent = done;
            queueCountEl.textContent = '0';  // ÊñπÊ°à A Ê≤íÊúâÈöäÂàó
        }

        // ============================================
        // Stop Test
        // ============================================

        function stopTest() {
            log('Stopping...');

            // Stop Smart Segmenter
            if (smartSegmenter) {
                smartSegmenter.stop();
                const stats = smartSegmenter.getStats();
                log(`SmartSegmenter stats: ${stats.segmentCount} segments, avg ${stats.avgWordsPerSegment} words/segment`, 'info');
            }

            // Stop Web Speech
            if (webSpeech) {
                webSpeech.isRunning = false;  // Prevent auto-restart
                webSpeech.stop();
                webSpeech.reset();
                log('WebSpeech stopped', 'info');
            }

            // üîß v7: ÂèñÊ∂àÊâÄÊúâÊ¥ªË∫çÁöÑ segmentÔºàÊõ¥Êñ∞ UI ÁãÄÊÖãÔºâ
            if (eventHandler && eventHandler.getStore()) {
                const cancelledCount = eventHandler.getStore().cancelAllActive();
                log(`Cancelled ${cancelledCount} active segments`, 'info');
            }

            // üêõ Bug fix: Ê®ôË®òÂØ¶ÊôÇËã±ÊñáÈ†êË¶ΩÁÇ∫Â∑≤ÂÅúÊ≠¢
            clearRealtimePreview();

            if (audioCapture) {
                audioCapture.cleanup();
            }

            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            isConnected = false;
            currentRealtimeEnglish = '';  // ÈáçÁΩÆËÆäÊï∏
            isPaused = false;  // ÈáçÁΩÆÊö´ÂÅúÁãÄÊÖã
            currentSpeaker = 'them';  // ÈáçÁΩÆË™™Ë©±ËÄÖ
            resetUI();
            updateStatus('disconnected', 'Â∑≤ÂÅúÊ≠¢');
            hideSpeakerIndicator();  // Èö±ËóèË™™Ë©±ËÄÖÊåáÁ§∫Âô®
            switchToPreparationMode();
            log('Stopped', 'success');
        }

        /**
         * Ê®ôË®òÂØ¶ÊôÇËã±ÊñáÈ†êË¶ΩÁÇ∫Â∑≤ÂÅúÊ≠¢Ôºà‰øùÁïôÂÖßÂÆπ‰æõÂ∞çÁÖßÔºâ
         */
        function clearRealtimePreview() {
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                // ‰∏çÁßªÈô§ÔºåÊîπÁÇ∫Ê®ôË®ò stopped ÁãÄÊÖãÔºàËÆäÁÅ∞Ëâ≤Ôºâ
                previewEl.classList.add('stopped');
                // Êõ¥Êñ∞Ê®ôÁ±§ÊñáÂ≠ó
                const labelEl = previewEl.querySelector('.preview-label span:last-child');
                if (labelEl) {
                    labelEl.textContent = 'Ëã±ÊñáÂéüÊñáÔºàÂ∑≤ÂÅúÊ≠¢Ôºâ';
                }
            }
        }

        function resetUI() {
            document.getElementById('btnStartListening').disabled = false;
        }

        function clearAll() {
            // Clear renderer
            if (renderer) {
                renderer.clear();
            }

            // Reset event handler
            if (eventHandler) {
                eventHandler.reset();
            }

            // ÂÆåÂÖ®ÁßªÈô§Ëã±ÊñáÂéüÊñáÊ°Ü
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.remove();
            }

            // Clear segment items from transcript
            const segmentItems = document.querySelectorAll('.segment-item');
            segmentItems.forEach(el => el.remove());

            // Show empty state
            transcriptEmpty.style.display = 'flex';

            // Clear log
            logPanel.innerHTML = '<div style="color:var(--text-secondary);">Â∑≤Ê∏ÖÈô§</div>';

            // Reset stats
            updateStats();

            log('All cleared');
        }

        // ============================================
        // Initialize
        // ============================================

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize language preference first (before rendering UI)
            loadLanguagePreference();
            updateUILanguage();

            // Initialize API Key from localStorage
            loadApiKey();

            // Initialize AudioCapture
            if (typeof AudioCapture !== 'undefined') {
                audioCapture = new AudioCapture();
                audioCapture.onError = (error) => {
                    log(`Audio error: ${error}`, 'error');
                    stopTest();
                };
                log('AudioCapture initialized', 'success');
            } else {
                log('AudioCapture not loaded - check if audio_capture.js exists', 'error');
            }

            // Initialize new modules
            if (!initModules()) {
                log('Module initialization failed - some features may not work', 'error');
            }

            // Initialize preset selector buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyPreset(btn.dataset.preset);
                });
            });

            // Initialize accent settings from localStorage
            loadAccentSettings();

            // Phase 1: Initialize scenario grid, quick prompts, and saved scripts
            renderScenarioGrid();
            renderQuickPrompts(selectedScenario);
            renderSavedScripts();

            // Update initial placeholder based on selected scenario
            const initialScenario = SCENARIOS[selectedScenario];
            if (initialScenario && initialScenario.placeholder) {
                document.getElementById('scriptInput').placeholder = initialScenario.placeholder;
            }

            // Ensure we start in preparation mode
            switchToPreparationMode();

            log('ECA Parallel Translation Test ready');
        });
    </script>

    <!-- Footer Credit -->
    <footer class="footer-credit">
        Designed by Adam Chan & Claude Code (2026)
    </footer>
</body>
</html>
