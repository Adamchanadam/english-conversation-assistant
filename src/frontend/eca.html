<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, interactive-widget=resizes-content">
    <title>英文對話助手 - English Conversation Assistant</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent-blue: #00d4ff;
            --accent-green: #00ff88;
            --accent-red: #ff4444;
            --accent-yellow: #ffaa00;
            --border-color: #333;
        }

        body {
            font-family: 'Noto Sans TC', 'Microsoft JhengHei', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100%;
            height: 100dvh; /* Mobile: accounts for browser chrome (URL bar) */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding-bottom: env(safe-area-inset-bottom, 0px);
        }

        html {
            height: 100%;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 500;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            background: var(--bg-tertiary);
        }

        .status-badge.connected {
            background: rgba(0, 255, 136, 0.15);
            color: var(--accent-green);
        }

        .status-badge.disconnected {
            background: rgba(255, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .status-badge.connecting {
            background: rgba(255, 170, 0, 0.15);
            color: var(--accent-yellow);
        }

        .status-badge.paused {
            background: rgba(255, 170, 0, 0.15);
            color: var(--accent-yellow);
        }

        .status-badge.ptt {
            background: rgba(0, 212, 255, 0.15);
            color: var(--accent-blue);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        /* Focus states for accessibility */
        button:focus-visible,
        .preset-btn:focus-visible,
        .control-btn:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Main Content */
        .main-content {
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            font-size: 14px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            font-weight: 500;
            color: var(--accent-blue);
        }

        /* Transcript Panel */
        .transcript-panel {
            flex: 1;
            min-height: 0;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .transcript-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .transcript-header h3 {
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .transcript-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .transcript-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            text-align: center;
            gap: 12px;
        }

        /* Script Generator Section */
        .script-section {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 16px;
        }

        .script-input-row {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .script-input-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .script-input-label {
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .script-input {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 15px;
            font-family: inherit;
            resize: none;
            min-height: 48px;
        }

        .script-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .script-input::placeholder {
            color: var(--text-secondary);
        }

        .script-generate-btn {
            padding: 12px 24px;
            min-height: 48px;
            border: none;
            border-radius: 8px;
            background: var(--accent-blue);
            color: #000;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            white-space: nowrap;
        }

        .script-generate-btn:hover:not(:disabled) {
            background: #00b8e0;
            transform: translateY(-1px);
        }

        .script-generate-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Quick Prompt Buttons */
        .quick-prompts-container {
            margin-top: 12px;
        }

        .quick-prompts-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .quick-prompts-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .quick-prompt-btn {
            padding: 8px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.15s ease;
            white-space: nowrap;
        }

        .quick-prompt-btn:hover {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: var(--bg-primary);
        }

        .quick-prompt-btn:active {
            transform: scale(0.97);
        }

        /* Teleprompter Display */
        .teleprompter {
            margin-top: 16px;
            display: none;
        }

        .teleprompter.visible {
            display: block;
        }

        .teleprompter-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px 24px;
        }

        .teleprompter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .teleprompter-title {
            font-size: 13px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .teleprompter-actions {
            display: flex;
            gap: 8px;
        }

        .teleprompter-action-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .teleprompter-action-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .teleprompter-script {
            font-size: 22px;
            line-height: 1.6;
            color: var(--text-primary);
            font-weight: 500;
            padding: 16px 0;
        }

        .teleprompter-alternatives {
            border-top: 1px solid var(--border-color);
            padding-top: 12px;
            margin-top: 12px;
        }

        .alternatives-title {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .alternative-item {
            font-size: 14px;
            color: var(--text-secondary);
            padding: 8px 0;
            cursor: pointer;
            transition: color 0.2s;
        }

        .alternative-item:hover {
            color: var(--accent-blue);
        }

        .alternative-item::before {
            content: "• ";
            color: var(--accent-blue);
        }

        /* Streaming cursor */
        .streaming-cursor {
            display: inline-block;
            width: 2px;
            height: 1em;
            background: var(--accent-blue);
            margin-left: 2px;
            animation: cursor-blink 1s infinite;
        }

        @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        /* Spin animation for loading */
        .animate-spin {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Flash animation for ready indicator */
        @keyframes flash-ready {
            0%, 100% {
                transform: scale(1);
                box-shadow: none;
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 12px var(--accent-green);
            }
        }

        /* Control Bar */
        .control-bar {
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        .control-btn {
            padding: 14px 28px;
            min-height: 48px;  /* 觸控目標 44px+ */
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .control-btn:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .control-btn:active:not(:disabled) {
            transform: translateY(0);
        }

        /* Realtime Preview (Web Speech) - Karaoke Style */
        .realtime-preview {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.05), rgba(0, 255, 136, 0.03));
            border-bottom: 1px solid var(--border-color);
            padding: 12px 16px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
            flex-shrink: 0;
        }

        .preview-label {
            font-size: 12px;
            color: var(--accent-blue);
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
            cursor: pointer;
            white-space: nowrap;
            padding-top: 4px;
        }

        .preview-label:hover {
            opacity: 0.8;
        }

        .preview-text {
            font-size: 18px;
            font-weight: 500;
            color: rgba(255, 255, 255, 0.7);
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            direction: rtl;
            text-align: left;
            line-height: 1.4;
        }

        /* 內部文字保持 LTR 正常閱讀順序 */
        .preview-text-inner {
            direction: ltr;
            unicode-bidi: embed;
        }

        /* 已確認的文字 - 較暗 */
        .preview-text .final-text {
            color: rgba(255, 255, 255, 0.5);
        }

        /* 正在說的文字 - Karaoke 高亮效果 */
        .preview-text .interim {
            color: #00ffcc;
            text-shadow: 0 0 8px rgba(0, 255, 204, 0.6), 0 0 16px rgba(0, 255, 204, 0.3);
            animation: karaoke-glow 1.5s ease-in-out infinite;
        }

        @keyframes karaoke-glow {
            0%, 100% {
                text-shadow: 0 0 8px rgba(0, 255, 204, 0.6), 0 0 16px rgba(0, 255, 204, 0.3);
            }
            50% {
                text-shadow: 0 0 12px rgba(0, 255, 204, 0.8), 0 0 24px rgba(0, 255, 204, 0.5);
            }
        }

        /* Toggle button for realtime preview */
        .preview-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .preview-toggle .toggle-icon {
            transition: transform 0.2s;
            font-size: 10px;
        }

        /* 展開狀態：顯示完整多行文字 */
        .realtime-preview.expanded .preview-toggle .toggle-icon {
            transform: rotate(0deg);
        }

        .realtime-preview.expanded .preview-text {
            font-size: 20px;
            white-space: pre-wrap;
            word-break: break-word;
            direction: ltr;
            text-align: left;
            max-height: 180px;
            overflow-y: auto;
            line-height: 1.6;
            padding: 8px 0;
        }

        .realtime-preview.expanded .preview-text-inner {
            unicode-bidi: normal;
        }

        /* 收合狀態：單行顯示最後文字 */
        .realtime-preview:not(.expanded) .preview-toggle .toggle-icon {
            transform: rotate(-90deg);
        }

        .realtime-preview.stopped {
            background: var(--bg-tertiary);
        }

        .realtime-preview.stopped .preview-label {
            color: var(--text-secondary);
        }

        .realtime-preview.stopped .preview-text {
            color: var(--text-secondary);
        }

        .realtime-preview.stopped .preview-text .interim {
            color: var(--text-secondary);
            text-shadow: none;
            animation: none;
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-start {
            background: var(--accent-blue);
            color: #000;
        }

        .btn-stop {
            background: var(--accent-red);
            color: #fff;
        }

        .btn-clear {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Log Panel (可收合) */
        .log-panel-wrapper {
            margin-top: auto;
        }

        .log-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .log-toggle:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .log-toggle .chevron {
            margin-left: auto;
            transition: transform 0.2s;
        }

        .log-toggle.expanded .chevron {
            transform: rotate(180deg);
        }

        .log-panel {
            max-height: 150px;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 0 0 8px 8px;
            border: 1px solid var(--border-color);
            border-top: none;
            font-family: monospace;
            font-size: 12px;
            margin-top: -1px;
        }

        .log-panel.collapsed {
            display: none;
        }

        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .log-entry.event { color: var(--accent-blue); }
        .log-entry.success { color: var(--accent-green); }
        .log-entry.warn { color: var(--accent-yellow); }
        .log-entry.error { color: var(--accent-red); }

        /* Preset Selector */
        /* Accent Selector */
        .accent-selector {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        /* PWA Standalone Warning Banner */
        .pwa-warning {
            display: none;
            background: linear-gradient(135deg, #ff6b35 0%, #e63946 100%);
            color: #fff;
            padding: 14px 20px;
            font-size: 13px;
            line-height: 1.5;
            text-align: center;
            flex-shrink: 0;
            position: relative;
        }

        .pwa-warning.visible {
            display: block;
        }

        .pwa-warning-title {
            font-weight: 700;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .pwa-warning-text {
            opacity: 0.95;
        }

        .pwa-warning-link {
            display: inline-block;
            margin-top: 8px;
            padding: 6px 16px;
            background: rgba(255,255,255,0.2);
            border: 1px solid rgba(255,255,255,0.4);
            border-radius: 6px;
            color: #fff;
            font-weight: 600;
            font-size: 13px;
            text-decoration: none;
            cursor: pointer;
        }

        .pwa-warning-dismiss {
            position: absolute;
            top: 8px;
            right: 10px;
            background: none;
            border: none;
            color: rgba(255,255,255,0.7);
            font-size: 18px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .pwa-warning-dismiss:hover {
            color: #fff;
        }

        /* Footer Credit */
        .footer-credit {
            text-align: center;
            padding: 16px;
            padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
            font-size: 11px;
            color: var(--text-secondary);
            opacity: 0.6;
            letter-spacing: 0.3px;
        }

        .footer-credit a {
            color: var(--text-secondary);
            text-decoration: none;
        }

        .footer-credit a:hover {
            color: var(--accent-blue);
        }

        .accent-row {
            display: flex;
            align-items: center;
        }

        .accent-label {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .accent-selects {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .accent-select-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
            min-width: 120px;
        }

        .accent-select-label {
            font-size: 12px;
            color: var(--text-muted);
        }

        .accent-select {
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
        }

        .accent-select:hover {
            border-color: var(--accent-blue);
        }

        .accent-select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .accent-hint {
            font-size: 11px;
            color: var(--text-muted);
            font-style: italic;
        }

        .accent-hint-inline {
            font-size: 11px;
            color: var(--text-secondary);
            font-style: italic;
            margin-left: 8px;
            opacity: 0.7;
        }

        /* API Key Settings */
        .api-key-section {
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .api-key-header {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
            padding: 4px 0;
        }

        .api-key-section.collapsed .api-key-header {
            margin-bottom: 0;
        }

        .api-key-section:not(.collapsed) .api-key-header {
            margin-bottom: 10px;
        }

        #apiKeyDetails {
            transition: all 0.2s ease;
        }

        .api-key-section.collapsed #apiKeyDetails {
            display: none;
        }

        .api-key-section.collapsed #apiKeyToggleIcon {
            transform: rotate(-90deg);
        }

        .api-key-desc {
            font-size: 12px;
            color: var(--text-muted);
            margin-bottom: 10px;
            line-height: 1.4;
        }

        .api-key-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }

        .api-key-input {
            flex: 1;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
            font-family: monospace;
        }

        .api-key-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .api-key-btn {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .api-key-btn.save {
            background: var(--accent-green);
            color: #000;
        }

        .api-key-btn.clear {
            background: var(--accent-red);
            color: #fff;
        }

        .api-key-btn:hover {
            opacity: 0.8;
        }

        .api-key-status-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            margin-bottom: 8px;
        }

        .api-key-status {
            font-weight: 500;
        }

        .api-key-status.set {
            color: var(--accent-green);
        }

        .api-key-status.not-set {
            color: var(--accent-red);
        }

        .api-key-security-note {
            font-size: 11px;
            color: var(--text-muted);
            line-height: 1.4;
            padding: 8px;
            background: rgba(0, 212, 255, 0.05);
            border-radius: 4px;
            border-left: 2px solid var(--accent-blue);
        }

        /* Language Selector in Header */
        .header-lang-select {
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
        }

        .header-lang-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .preset-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .preset-label {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .preset-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 8px 14px;
            min-height: 36px;  /* 觸控友好 */
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .preset-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-blue);
        }

        .preset-btn.active {
            background: var(--accent-blue);
            color: #000;
            border-color: var(--accent-blue);
            font-weight: 500;
        }

        /* 響應式：手機上只顯示3個主要選項 */
        @media (max-width: 480px) {
            .preset-btn[data-preset="ultra-fast"],
            .preset-btn[data-preset="conservative"] {
                display: none;
            }

            /* Mobile: API Key section more compact */
            .api-key-section {
                padding: 10px 12px;
            }

            .api-key-desc {
                font-size: 11px;
            }

            /* Mobile: Script input row stacks vertically */
            .script-input-row {
                flex-direction: column;
                align-items: stretch;
            }

            .script-input-wrapper {
                width: 100%;
            }

            .script-input-label {
                text-align: center;
                justify-content: center;
            }

            .script-generate-btn {
                width: 100%;
                justify-content: center;
                margin-top: 4px;
            }

            /* Mobile: Quick prompts scroll horizontally */
            .quick-prompts-grid {
                flex-wrap: nowrap;
                overflow-x: auto;
                padding-bottom: 8px;
                -webkit-overflow-scrolling: touch;
            }

            .quick-prompt-btn {
                flex-shrink: 0;
            }

            /* Mobile: Footer smaller */
            .footer-credit {
                padding: 12px;
                font-size: 10px;
            }
        }

        /* ============================================
         * Phase 1: Pre-Call Preparation Mode
         * ============================================ */

        .preparation-mode {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .preparation-mode.hidden {
            display: none;
        }

        /* Call mode container (transcript + quick bar shown during call) */
        .call-mode {
            display: none;
            flex-direction: column;
            flex: 1;
            min-height: 0;
            gap: 20px;
        }

        .call-mode.active {
            display: flex;
        }

        /* Scenario Cards Grid */
        .scenario-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
        }

        .scenario-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-height: 44px;
        }

        .scenario-card:hover {
            border-color: var(--accent-blue);
            background: var(--bg-tertiary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 212, 255, 0.15);
        }

        .scenario-card:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .scenario-card.selected {
            border-color: var(--accent-blue);
            background: rgba(0, 212, 255, 0.1);
        }

        .scenario-card-icon {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background: var(--bg-tertiary);
        }

        .scenario-card.selected .scenario-card-icon {
            background: rgba(0, 212, 255, 0.2);
        }

        .scenario-card-name {
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
        }

        .scenario-card-vocab {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
            word-break: break-word;
        }

        /* Section headers in preparation mode */
        .prep-section-title {
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        /* Saved Scripts List */
        .saved-scripts-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .saved-script-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.2s;
        }

        .saved-script-item:hover {
            border-color: var(--accent-blue);
        }

        .saved-script-body {
            flex: 1;
            min-width: 0;
        }

        .saved-script-english {
            font-size: 14px;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-script-chinese {
            font-size: 13px;
            color: var(--text-secondary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-top: 2px;
        }

        .saved-script-meta {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
            display: flex;
            gap: 8px;
        }

        .saved-script-delete {
            padding: 8px;
            min-width: 36px;
            min-height: 36px;
            border: none;
            border-radius: 6px;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .saved-script-delete:hover {
            background: rgba(255, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .saved-script-delete:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .saved-scripts-empty {
            text-align: center;
            padding: 16px;
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Save as Quick Card button (in prep teleprompter) */
        .btn-save-card {
            padding: 10px 20px;
            min-height: 44px;
            border: 1px solid var(--accent-green);
            border-radius: 8px;
            background: rgba(0, 255, 136, 0.1);
            color: var(--accent-green);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-save-card:hover {
            background: rgba(0, 255, 136, 0.2);
        }

        .btn-save-card:focus-visible {
            outline: 2px solid var(--accent-green);
            outline-offset: 2px;
        }

        .btn-save-card:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Start Listening Button (in preparation mode) */
        .btn-start-listening {
            padding: 16px 32px;
            min-height: 52px;
            border: none;
            border-radius: 12px;
            background: var(--accent-blue);
            color: #000;
            font-size: 17px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
        }

        .btn-start-listening:hover:not(:disabled) {
            background: #00b8e0;
            transform: translateY(-1px);
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.3);
        }

        .btn-start-listening:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .btn-start-listening:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ============================================
         * Phase 1: Quick Response Bar (during call) - Single Row
         * ============================================ */

        .quick-response-bar {
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 10px 16px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
            overflow-x: auto;
        }

        .quick-response-divider {
            width: 1px;
            height: 28px;
            background: var(--border-color);
            flex-shrink: 0;
        }

        /* Prepared script card (compact) */
        .prepared-card {
            padding: 8px 12px;
            min-height: 40px;
            border: 1px solid var(--accent-blue);
            border-radius: 6px;
            background: rgba(0, 212, 255, 0.08);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            max-width: 160px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            align-items: center;
            gap: 6px;
            flex-shrink: 0;
        }

        .prepared-card:hover {
            background: rgba(0, 212, 255, 0.15);
        }

        .prepared-card:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .prepared-card-icon {
            flex-shrink: 0;
            color: var(--accent-blue);
        }

        /* Quick phrase buttons */
        .quick-phrase-btn {
            padding: 8px 12px;
            min-height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .quick-phrase-btn:hover {
            border-color: var(--accent-green);
            background: rgba(0, 255, 136, 0.08);
        }

        .quick-phrase-btn:focus-visible {
            outline: 2px solid var(--accent-green);
            outline-offset: 2px;
        }

        /* Panic Button - Compact */
        .panic-btn {
            padding: 8px 14px;
            min-height: 40px;
            border: 2px solid var(--accent-red);
            border-radius: 6px;
            background: rgba(255, 68, 68, 0.1);
            color: var(--accent-red);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: auto;
            flex-shrink: 0;
        }

        .panic-btn:hover {
            background: rgba(255, 68, 68, 0.2);
        }

        .panic-btn:focus-visible {
            outline: 2px solid var(--accent-red);
            outline-offset: 2px;
        }

        .panic-btn:active {
            transform: scale(0.98);
        }

        /* ============================================
         * Overflow Menu (⋮) — replaces header buttons
         * ============================================ */

        .overflow-menu-wrapper {
            position: relative;
        }

        .overflow-menu-btn {
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 1px;
            transition: all 0.2s;
        }

        .overflow-menu-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .overflow-menu-dropdown {
            position: absolute;
            top: calc(100% + 6px);
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            min-width: 140px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
            z-index: 100;
            display: none;
            overflow: hidden;
        }

        .overflow-menu-dropdown.open {
            display: block;
        }

        .overflow-menu-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            color: var(--text-primary);
            font-size: 14px;
            cursor: pointer;
            transition: background 0.15s;
            border: none;
            background: none;
            width: 100%;
            text-align: left;
        }

        .overflow-menu-item:hover {
            background: var(--bg-tertiary);
        }

        .overflow-menu-item svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            color: var(--text-secondary);
        }

        /* ============================================
         * Bottom Bar — 3 main buttons (mobile)
         * ============================================ */

        .call-bottom-bar {
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 10px 16px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
            display: none;
        }

        .bottom-bar-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        .bottom-bar-btn {
            flex: 1;
            max-width: 140px;
            min-height: 48px;
            border: 1px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            user-select: none;
            -webkit-user-select: none;
        }

        .bottom-bar-btn svg {
            width: 18px;
            height: 18px;
        }

        .bottom-bar-btn.ptt {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
            touch-action: manipulation;
        }
        .bottom-bar-btn.ptt:hover { background: rgba(255, 170, 0, 0.1); }
        .bottom-bar-btn.ptt:active,
        .bottom-bar-btn.ptt.active {
            background: rgba(255, 170, 0, 0.3);
            color: #fff;
        }

        .bottom-bar-btn.pause-resume {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }
        .bottom-bar-btn.pause-resume:hover { background: rgba(255, 170, 0, 0.1); }
        .bottom-bar-btn.pause-resume.paused {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .bottom-bar-btn.suggest {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }
        .bottom-bar-btn.suggest:hover { background: rgba(0, 170, 255, 0.1); }
        .bottom-bar-btn.suggest:disabled { opacity: 0.4; cursor: default; }
        .bottom-bar-btn.suggest .spinner {
            display: none;
            width: 14px;
            height: 14px;
            border: 2px solid transparent;
            border-top-color: currentColor;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        .bottom-bar-btn.suggest.loading .spinner { display: inline-block; }
        .bottom-bar-btn.suggest.loading .suggest-icon { display: none; }

        /* ============================================
         * Peek Bar + Bottom Sheet
         * ============================================ */

        .peek-bar {
            flex-shrink: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 8px 16px;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 13px;
            transition: background 0.15s;
        }

        .peek-bar:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        .peek-bar-arrow {
            font-size: 10px;
            transition: transform 0.3s;
        }

        .peek-bar.sheet-open .peek-bar-arrow {
            transform: rotate(180deg);
        }

        .bottom-sheet-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.4);
            z-index: 90;
            display: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .bottom-sheet-overlay.open {
            display: block;
            opacity: 1;
        }

        .bottom-sheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            border-radius: 16px 16px 0 0;
            z-index: 91;
            transform: translateY(100%);
            transition: transform 0.3s ease, visibility 0.3s;
            max-height: 60vh;
            overflow-y: auto;
            padding-bottom: env(safe-area-inset-bottom, 0px);
            visibility: hidden;
            pointer-events: none;
        }

        .bottom-sheet.open {
            transform: translateY(0);
            visibility: visible;
            pointer-events: auto;
        }

        .bottom-sheet-handle {
            width: 36px;
            height: 4px;
            background: var(--border-color);
            border-radius: 2px;
            margin: 10px auto;
        }

        .bottom-sheet-section {
            padding: 4px 16px 12px;
        }

        .bottom-sheet-section-title {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-left: 2px;
        }

        .bottom-sheet-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .bottom-sheet-grid .quick-phrase-btn {
            flex: 1;
            min-width: calc(50% - 4px);
            justify-content: center;
        }

        .bottom-sheet-grid .prepared-card {
            flex: 1;
            min-width: calc(50% - 4px);
            max-width: none;
        }

        .bottom-sheet .panic-btn {
            width: 100%;
            justify-content: center;
            margin-left: 0;
            margin-top: 4px;
        }

        /* ============================================
         * Feature C: Key Info Highlighting
         * ============================================ */

        .key-info {
            cursor: pointer;
            padding: 1px 4px;
            border-radius: 3px;
            font-weight: 500;
            transition: all 0.15s;
            position: relative;
        }
        .key-info:hover {
            filter: brightness(1.3);
        }
        .key-info-phone {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
        }
        .key-info-amount {
            background: rgba(34, 197, 94, 0.15);
            color: #4ade80;
        }
        .key-info-date {
            background: rgba(250, 204, 21, 0.15);
            color: #fbbf24;
        }
        .key-info-ref {
            background: rgba(168, 85, 247, 0.15);
            color: #c084fc;
        }
        .key-info-postcode {
            background: rgba(251, 146, 60, 0.15);
            color: #fb923c;
        }
        .key-info-time {
            background: rgba(45, 212, 191, 0.15);
            color: #2dd4bf;
        }

        /* Copy toast notification */
        .copy-toast {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%) translateY(20px);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 13px;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
            z-index: 9999;
            border: 1px solid var(--border-color);
        }
        .copy-toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* ============================================
         * Feature A: Smart Suggestions
         * ============================================ */

        .suggest-btn {
            padding: 8px 14px;
            min-height: 40px;
            border: 1px solid var(--accent-yellow);
            border-radius: 6px;
            background: rgba(255, 170, 0, 0.1);
            color: var(--accent-yellow);
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .suggest-btn:hover {
            background: rgba(255, 170, 0, 0.2);
        }
        .suggest-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .suggest-btn .spinner {
            display: none;
            width: 14px;
            height: 14px;
            border: 2px solid var(--accent-yellow);
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        .suggest-btn.loading .spinner { display: inline-block; }
        .suggest-btn.loading .suggest-icon { display: none; }

        /* Suggestion Panel */
        .suggestion-panel {
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            padding: 12px 16px;
            display: flex;
            gap: 10px;
            overflow-x: auto;
            flex-shrink: 0;
        }
        .suggestion-card {
            flex: 1;
            min-width: 180px;
            max-width: 280px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .suggestion-card:hover {
            border-color: var(--accent-yellow);
            background: rgba(255, 170, 0, 0.05);
        }
        .suggestion-card-en {
            font-size: 15px;
            color: var(--text-primary);
            margin-bottom: 6px;
            line-height: 1.4;
        }
        .suggestion-card-zh {
            font-size: 13px;
            color: var(--accent-blue);
            margin-bottom: 8px;
        }
        .suggestion-card-use {
            font-size: 11px;
            color: var(--accent-yellow);
            text-align: right;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ============================================
         * Phase 1: Teleprompter Overlay
         * ============================================ */

        .teleprompter-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 24px;
        }

        .teleprompter-overlay.visible {
            display: flex;
        }

        .teleprompter-overlay-content {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 32px;
            max-width: 600px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .teleprompter-overlay-close {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 36px;
            height: 36px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .teleprompter-overlay-close:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .teleprompter-overlay-close:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .teleprompter-overlay-english {
            font-size: 24px;
            font-weight: 500;
            color: var(--text-primary);
            line-height: 1.6;
            margin-bottom: 16px;
        }

        .teleprompter-overlay-chinese {
            font-size: 18px;
            color: var(--accent-blue);
            line-height: 1.6;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .teleprompter-overlay-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Panic mode: show prepared scripts below stalling phrase */
        .teleprompter-overlay-scripts {
            margin-top: 20px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
        }

        .teleprompter-overlay-scripts-title {
            font-size: 13px;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .teleprompter-overlay-script-item {
            padding: 10px 14px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-tertiary);
        }

        .teleprompter-overlay-script-item:hover {
            border-color: var(--accent-blue);
        }

        .teleprompter-overlay-script-item:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .teleprompter-overlay-script-item-en {
            font-size: 16px;
            color: var(--text-primary);
        }

        .teleprompter-overlay-script-item-zh {
            font-size: 14px;
            color: var(--accent-blue);
            margin-top: 4px;
        }

        /* Call Control Buttons (during call) */
        .btn-call-control {
            padding: 10px 18px;
            min-height: 44px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn-call-control:hover {
            background: var(--bg-primary);
            border-color: var(--accent-blue);
        }

        .btn-call-control:focus-visible {
            outline: 2px solid var(--accent-blue);
            outline-offset: 2px;
        }

        .btn-call-control.pause {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
        }

        .btn-call-control.pause:hover {
            background: rgba(255, 170, 0, 0.1);
        }

        .btn-call-control.resume {
            border-color: var(--accent-green);
            color: var(--accent-green);
        }

        .btn-call-control.resume:hover {
            background: rgba(0, 255, 136, 0.1);
        }

        .btn-call-control.home {
            border-color: var(--text-secondary);
            color: var(--text-secondary);
        }

        .btn-call-control.home:hover {
            border-color: var(--text-primary);
            color: var(--text-primary);
        }

        .btn-call-control.export {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .btn-call-control.export:hover {
            background: rgba(0, 170, 255, 0.1);
            border-color: var(--accent-blue);
        }

        .btn-call-control.ptt {
            border-color: var(--accent-yellow);
            color: var(--accent-yellow);
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
        }

        .btn-call-control.ptt:hover {
            background: rgba(255, 170, 0, 0.1);
        }

        .btn-call-control.ptt:active,
        .btn-call-control.ptt.active {
            background: rgba(255, 170, 0, 0.3);
            border-color: var(--accent-yellow);
            color: #fff;
        }

        /* Call header bar (during call) */
        .call-header-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 16px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .call-header-left {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .call-header-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .call-timer {
            font-size: 14px;
            color: var(--text-secondary);
            font-variant-numeric: tabular-nums;
        }

        /* ============================================
         * Responsive: Mobile
         * ============================================ */

        @media (max-width: 480px) {
            .scenario-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .scenario-card {
                padding: 12px;
            }

            .scenario-card-vocab {
                display: none;
            }

            /* Call header compact on mobile */
            .call-header-bar {
                padding: 8px 12px;
            }

            .call-header-left {
                gap: 10px;
            }

            .call-header-right {
                gap: 6px;
            }

            .btn-call-control {
                padding: 8px 12px;
                min-height: 38px;
                font-size: 12px;
            }

            .btn-call-control svg {
                width: 12px;
                height: 12px;
            }

            /* Realtime preview compact */
            .realtime-preview {
                padding: 10px 12px;
            }

            .preview-label {
                font-size: 11px;
            }

            .preview-text {
                font-size: 16px;
            }

            .realtime-preview.expanded .preview-text {
                font-size: 18px;
                max-height: 120px;
            }

            /* Quick response bar compact */
            .quick-response-bar {
                padding: 8px 10px;
                padding-bottom: calc(8px + env(safe-area-inset-bottom, 0px));
                gap: 6px;
            }

            .quick-phrase-btn {
                font-size: 11px;
                padding: 6px 8px;
                min-height: 36px;
            }

            .panic-btn {
                padding: 6px 10px;
                font-size: 12px;
                min-height: 36px;
            }

            .prepared-card {
                max-width: 120px;
                font-size: 11px;
                padding: 6px 10px;
                min-height: 36px;
            }

            .suggest-btn {
                font-size: 11px;
                padding: 6px 10px;
                min-height: 36px;
            }

            .suggestion-panel {
                padding: 8px 12px;
                gap: 8px;
            }

            .suggestion-card {
                min-width: 150px;
                padding: 10px;
            }

            .suggestion-card-en {
                font-size: 14px;
            }

            .teleprompter-overlay {
                padding: 12px;
            }

            .teleprompter-overlay-content {
                padding: 20px;
            }

            .teleprompter-overlay-english {
                font-size: 20px;
            }

            .teleprompter-overlay-chinese {
                font-size: 16px;
            }

            /* Mobile: hide old quick-response-bar, show new bottom bar + peek bar */
            .quick-response-bar {
                display: none !important;
            }

            .call-bottom-bar.active {
                display: block;
            }

            .peek-bar.active {
                display: flex;
            }

            /* Mobile: hide header PTT/Pause/Resume (moved to bottom bar) */
            .call-header-right .btn-call-control.ptt,
            .call-header-right .btn-call-control.pause,
            .call-header-right .btn-call-control.resume {
                display: none !important;
            }

            /* Mobile: hide Home/Export buttons (moved to overflow menu) */
            .call-header-right .btn-call-control.home,
            .call-header-right .btn-call-control.export {
                display: none !important;
            }

            .bottom-bar-btn {
                min-height: 44px;
                font-size: 13px;
            }
        }

        /* Desktop: keep old layout mostly, just add overflow menu */
        @media (min-width: 481px) {
            .call-bottom-bar { display: none !important; }
            .peek-bar { display: none !important; }
            .bottom-sheet { display: none !important; }
            .bottom-sheet-overlay { display: none !important; }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-title">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                <line x1="12" x2="12" y1="19" y2="22"></line>
            </svg>
            <span data-i18n="appTitle">英文對話助手</span>
        </div>
        <div class="header-status">
            <select id="languageSelect" class="header-lang-select" onchange="changeLanguage(this.value)">
                <option value="zh-HK">繁體</option>
                <option value="zh-CN">简体</option>
                <option value="en">ENG</option>
            </select>
            <div class="status-badge disconnected" id="statusBadge">
                <span class="status-dot"></span>
                <span id="statusText" data-i18n="statusDisconnected">未連線</span>
            </div>
        </div>
    </header>

    <!-- PWA Standalone Warning (iOS Add to Home Screen) -->
    <div class="pwa-warning" id="pwaWarning">
        <button class="pwa-warning-dismiss" onclick="dismissPwaWarning()" aria-label="Close">&times;</button>
        <div class="pwa-warning-title" data-i18n="pwaWarningTitle">⚠️ 語音功能受限</div>
        <div class="pwa-warning-text" data-i18n="pwaWarningText">「主畫面」模式暫不支援語音辨識。請用 Safari 開啟此網址以使用完整功能。</div>
        <a class="pwa-warning-link" id="pwaWarningCopyLink" onclick="copyCurrentUrl()" data-i18n="pwaWarningCopy">📋 複製網址到 Safari 開啟</a>
    </div>

    <!-- Main Content -->
    <main class="main-content">
        <!-- ============================================
             PREPARATION MODE (shown when NOT connected)
             ============================================ -->
        <div class="preparation-mode" id="preparationMode">

            <!-- 0. API Key Settings (collapsible when set) -->
            <div class="api-key-section" id="apiKeySection">
                <div class="api-key-header" onclick="toggleApiKeyDetails()" style="cursor: pointer;">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>
                    </svg>
                    <span data-i18n="apiKeySettings">OpenAI API Key</span>
                    <span id="apiKeyStatusText" class="api-key-status not-set" data-i18n="apiKeyNotSet">未設定</span>
                    <svg id="apiKeyToggleIcon" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-left: auto; transition: transform 0.2s;">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                </div>
                <div id="apiKeyDetails">
                    <div class="api-key-desc" data-i18n="apiKeyDesc">
                        翻譯功能需要 OpenAI API Key（可在 platform.openai.com 取得）
                    </div>
                    <div class="api-key-row">
                        <input type="password" id="apiKeyInput" class="api-key-input" data-i18n-placeholder="apiKeyPlaceholder" placeholder="sk-...">
                        <button id="apiKeySaveBtn" class="api-key-btn save" onclick="saveApiKey()" data-i18n="apiKeySave">儲存</button>
                        <button id="apiKeyClearBtn" class="api-key-btn clear" onclick="clearApiKey()" style="display:none" data-i18n="apiKeyClear">清除</button>
                    </div>
                    <div class="api-key-security-note" data-i18n="apiKeySecurityNote">
                        🔒 安全提示：API Key 只會儲存在你的瀏覽器本機 (localStorage)，我們不會收集或儲存你的 API Key。
                    </div>
                </div>
            </div>

            <!-- 1. Scenario Selector -->
            <div>
                <div class="prep-section-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect>
                        <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>
                    </svg>
                    <span data-i18n="selectScenario">選擇場景</span>
                </div>
                <div class="scenario-grid" id="scenarioGrid">
                    <!-- Populated by JS -->
                </div>
            </div>

            <!-- 2. Script Generator (reused, moved into prep) -->
            <div>
                <div class="prep-section-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 20h9"></path>
                        <path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"></path>
                    </svg>
                    <span data-i18n="prepareScript">準備講稿</span>
                </div>
                <div class="script-input-row">
                    <div class="script-input-wrapper">
                        <label class="script-input-label" data-i18n="scriptInputLabel">
                            我想說...（中文）
                        </label>
                        <textarea
                            class="script-input"
                            id="scriptInput"
                            data-i18n-placeholder="scriptInputPlaceholder"
                            placeholder="輸入你想說的話，例如：我想問一下這筆費用是什麼"
                            rows="1"
                            onkeydown="handleScriptInputKeydown(event)"
                        ></textarea>
                    </div>
                    <button class="script-generate-btn" id="btnGenerate" onclick="generateScript()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m5 12 7-7 7 7"></path>
                            <path d="M12 19V5"></path>
                        </svg>
                        <span data-i18n="generateScript">生成講稿</span>
                    </button>
                </div>

                <!-- Quick Prompt Buttons -->
                <div class="quick-prompts-container" id="quickPromptsContainer">
                    <div class="quick-prompts-label">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                        </svg>
                        <span data-i18n="quickPrompts">快速選擇常用目的：</span>
                    </div>
                    <div class="quick-prompts-grid" id="quickPromptsGrid">
                        <!-- Populated by JavaScript based on selected scenario -->
                    </div>
                </div>

                <!-- Teleprompter Display (in prep mode) -->
                <div class="teleprompter" id="teleprompter">
                    <div class="teleprompter-card">
                        <div class="teleprompter-header">
                            <span class="teleprompter-title">
                                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                </svg>
                                <span data-i18n="yourScript">你的講稿</span>
                            </span>
                            <div class="teleprompter-actions">
                                <button class="teleprompter-action-btn" onclick="copyScript()">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <rect width="14" height="14" x="8" y="8" rx="2" ry="2"></rect>
                                        <path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"></path>
                                    </svg>
                                    <span data-i18n="copy">複製</span>
                                </button>
                                <button class="teleprompter-action-btn" onclick="regenerateScript()">
                                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                                        <path d="M3 3v5h5"></path>
                                        <path d="M3 12a9 9 0 0 0 9 9 9.75 9.75 0 0 0 6.74-2.74L21 16"></path>
                                        <path d="M16 16h5v5"></path>
                                    </svg>
                                    <span data-i18n="regenerate">重新生成</span>
                                </button>
                                <button class="btn-save-card" id="btnSaveCard" onclick="saveAsQuickCard()">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                                        <polyline points="7 3 7 8 15 8"></polyline>
                                    </svg>
                                    <span data-i18n="saveAsCard">儲存為快捷卡片</span>
                                </button>
                            </div>
                        </div>
                        <div class="teleprompter-script" id="scriptOutput">
                            <!-- Generated script will appear here -->
                        </div>
                        <div class="teleprompter-alternatives" id="alternativesSection" style="display:none;">
                            <div class="alternatives-title" data-i18n="otherWays">其他說法：</div>
                            <div id="alternativesList">
                                <!-- Alternatives will appear here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 3. Saved Scripts List -->
            <div>
                <div class="prep-section-title">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
                        <polyline points="17 21 17 13 7 13 7 21"></polyline>
                        <polyline points="7 3 7 8 15 8"></polyline>
                    </svg>
                    <span data-i18n="savedScripts">已儲存的講稿</span>
                </div>
                <div class="saved-scripts-list" id="savedScriptsList">
                    <div class="saved-scripts-empty" id="savedScriptsEmpty" data-i18n="noSavedScripts">尚未儲存任何講稿</div>
                </div>
            </div>

            <!-- Accent Selector (English recognition accent) -->
            <div class="accent-selector">
                <div class="accent-row">
                    <span class="accent-label">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" x2="12" y1="19" y2="22"></line>
                        </svg>
                        <span data-i18n="accentRecognition">英語口音識別：</span>
                        <span class="accent-hint-inline" data-i18n="accentHint">按住「我在說話」時會自動切換</span>
                    </span>
                </div>
                <div class="accent-selects">
                    <div class="accent-select-group">
                        <label class="accent-select-label" data-i18n="otherPartyAccent">對方口音</label>
                        <select id="accentThem" class="accent-select" onchange="saveAccentSettings()">
                            <!-- Options populated by JS -->
                        </select>
                    </div>
                    <div class="accent-select-group">
                        <label class="accent-select-label" data-i18n="myAccent">我的口音</label>
                        <select id="accentMe" class="accent-select" onchange="saveAccentSettings()">
                            <!-- Options populated by JS -->
                        </select>
                    </div>
                </div>
            </div>

            <!-- Preset Selector (in prep mode) -->
            <div class="preset-selector">
                <span class="preset-label">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;">
                        <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                    <span data-i18n="translationSpeed">翻譯速度：</span>
                </span>
                <div class="preset-buttons" id="presetButtons">
                    <button class="preset-btn" data-preset="ultra-fast" data-i18n="speedUltraFast">極速</button>
                    <button class="preset-btn active" data-preset="fast" data-i18n="speedFast">快速</button>
                    <button class="preset-btn" data-preset="balanced" data-i18n="speedBalanced">平衡</button>
                    <button class="preset-btn" data-preset="stable" data-i18n="speedStable">穩定</button>
                    <button class="preset-btn" data-preset="conservative" data-i18n="speedConservative">保守</button>
                </div>
            </div>

            <!-- 4. Start Listening Button -->
            <button class="btn-start-listening" id="btnStartListening" onclick="startListening()">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" x2="12" y1="19" y2="22"></line>
                </svg>
                <span data-i18n="startListening">開始聆聽</span>
            </button>
        </div>

        <!-- ============================================
             CALL MODE (shown when connected)
             ============================================ -->
        <div class="call-mode" id="callMode">

            <!-- Call header: stats + timer + controls -->
            <div class="call-header-bar">
                <div class="call-header-left">
                    <div class="stat-item">
                        <span class="stat-label">已翻譯:</span>
                        <span class="stat-value" id="doneCount">0</span>
                        <span class="stat-label">段</span>
                    </div>
                    <div class="call-timer" id="callTimer">00:00</div>
                </div>
                <div class="call-header-right">
                    <!-- Desktop: keep all buttons visible -->
                    <button class="btn-call-control ptt" id="btnPTT"
                            onmousedown="pttStart()" onmouseup="pttEnd()" onmouseleave="pttEnd()"
                            ontouchstart="pttStart()" ontouchend="pttEnd()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" x2="12" y1="19" y2="22"></line>
                        </svg>
                        <span data-i18n="iAmSpeaking">我講緊嘢</span>
                    </button>
                    <button class="btn-call-control pause" id="btnPause" onclick="pauseListening()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <rect x="6" y="4" width="4" height="16" rx="1"></rect>
                            <rect x="14" y="4" width="4" height="16" rx="1"></rect>
                        </svg>
                        <span data-i18n="pause">暫停</span>
                    </button>
                    <button class="btn-call-control resume" id="btnResume" onclick="resumeListening()" style="display:none;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <polygon points="5 3 19 12 5 21 5 3"></polygon>
                        </svg>
                        <span data-i18n="resume">繼續</span>
                    </button>
                    <button class="btn-call-control home" id="btnHome" onclick="goToHome()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                            <polyline points="9 22 9 12 15 12 15 22"></polyline>
                        </svg>
                        首頁
                    </button>
                    <button class="btn-call-control export" id="btnExport" onclick="exportTranscript()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                            <polyline points="7 10 12 15 17 10"></polyline>
                            <line x1="12" x2="12" y1="15" y2="3"></line>
                        </svg>
                        匯出
                    </button>
                    <!-- Overflow menu (visible on mobile, replaces Home/Export) -->
                    <div class="overflow-menu-wrapper">
                        <button class="overflow-menu-btn" onclick="toggleOverflowMenu()" aria-label="更多選項">&#8942;</button>
                        <div class="overflow-menu-dropdown" id="overflowMenu">
                            <button class="overflow-menu-item" onclick="goToHome(); closeOverflowMenu();">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
                                    <polyline points="9 22 9 12 15 12 15 22"></polyline>
                                </svg>
                                首頁
                            </button>
                            <button class="overflow-menu-item" onclick="exportTranscript(); closeOverflowMenu();">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                    <polyline points="7 10 12 15 17 10"></polyline>
                                    <line x1="12" x2="12" y1="15" y2="3"></line>
                                </svg>
                                匯出記錄
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hidden stats -->
            <div style="display:none;">
                <span id="segmentCount">0</span>
                <span id="activeCount">0</span>
                <span id="queueCount">0</span>
            </div>

            <!-- Realtime English Preview Container (single line, inserted dynamically) -->
            <div id="realtimePreviewContainer"></div>

            <!-- Transcript Panel -->
            <div class="transcript-panel">
                <div class="transcript-header">
                    <h3>
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                        </svg>
                        <span>即時翻譯</span>
                    </h3>
                </div>
                <div class="transcript-content" id="transcriptContent">
                    <div class="transcript-empty" id="transcriptEmpty">
                        <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" style="opacity:0.4;">
                            <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                            <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                            <line x1="12" x2="12" y1="19" y2="22"></line>
                        </svg>
                        <div style="font-size:16px;font-weight:500;margin-top:12px;">聆聽中...</div>
                        <div style="font-size:14px;color:var(--text-secondary);max-width:300px;line-height:1.6;">
                            將手機通話開啟擴音，<br>對方說的英文會即時翻譯成中文
                        </div>
                    </div>
                </div>
            </div>

            <!-- Hidden Log Panel for debugging (not visible in call mode) -->
            <div class="log-panel collapsed" id="logPanel" style="display:none;">
                <div style="color:var(--text-secondary);">等待日誌...</div>
            </div>
        </div>
    </main>

    <!-- Suggestion Panel (between transcript and Quick Response Bar) -->
    <div id="suggestionPanel" style="display:none;" class="suggestion-panel"></div>

    <!-- Quick Response Bar (shown DURING call) - Single Row Layout -->
    <div class="quick-response-bar" id="quickResponseBar" style="display:none;">
        <!-- Prepared script cards (from localStorage) -->
        <div id="preparedCardsRow" style="display:contents;"></div>
        <!-- Divider between cards and phrases (hidden if no cards) -->
        <div class="quick-response-divider" id="quickResponseDivider" style="display:none;"></div>
        <!-- Quick phrases -->
        <button class="quick-phrase-btn" onclick="showQuickPhrase(0)" title="請再說一次">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                <path d="M3 3v5h5"></path>
            </svg>
            再說一次
        </button>
        <button class="quick-phrase-btn" onclick="showQuickPhrase(1)" title="請慢點說">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10"></circle>
                <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            慢點說
        </button>
        <button class="quick-phrase-btn" onclick="showQuickPhrase(2)" title="我確認一下">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="20 6 9 17 4 12"></polyline>
            </svg>
            確認一下
        </button>
        <button class="quick-phrase-btn" onclick="showQuickPhrase(3)" title="謝謝再見">
            <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4.5 21.5l6-6M9 10.5L4.5 15m0 0l6 6"></path>
            </svg>
            謝謝
        </button>
        <!-- Smart Suggest Button -->
        <button class="suggest-btn" id="suggestBtn" onclick="requestSuggestions()" disabled title="AI 幫我回應">
            <span class="suggest-icon">💡</span>
            <span class="spinner"></span>
            幫我回應
        </button>
        <!-- Panic Button -->
        <button class="panic-btn" id="panicBtn" onclick="triggerPanic()">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                <line x1="12" y1="9" x2="12" y2="13"></line>
                <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            求助
        </button>
    </div>

    <!-- Mobile: Peek Bar (tap to open bottom sheet) -->
    <div class="peek-bar" id="peekBar" onclick="toggleBottomSheet()">
        <span>💬 快速回應</span>
        <span class="peek-bar-arrow">▲</span>
    </div>

    <!-- Mobile: Bottom Bar (3 main buttons) -->
    <div class="call-bottom-bar" id="callBottomBar">
        <div class="bottom-bar-buttons">
            <button class="bottom-bar-btn ptt" id="btnPTTMobile"
                    onmousedown="pttStart()" onmouseup="pttEnd()" onmouseleave="pttEnd()"
                    ontouchstart="pttStart()" ontouchend="pttEnd()">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"></path>
                    <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                    <line x1="12" x2="12" y1="19" y2="22"></line>
                </svg>
                <span>我在說</span>
            </button>
            <button class="bottom-bar-btn pause-resume" id="btnPauseResumeMobile" onclick="togglePauseResume()">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" stroke="none" id="pauseResumeIcon">
                    <rect x="6" y="4" width="4" height="16" rx="1"></rect>
                    <rect x="14" y="4" width="4" height="16" rx="1"></rect>
                </svg>
                <span id="pauseResumeLabel">暫停</span>
            </button>
            <button class="bottom-bar-btn suggest" id="suggestBtnMobile" onclick="requestSuggestions()" disabled>
                <span class="suggest-icon">💡</span>
                <span class="spinner"></span>
                <span>幫我回應</span>
            </button>
        </div>
    </div>

    <!-- Mobile: Bottom Sheet Overlay -->
    <div class="bottom-sheet-overlay" id="bottomSheetOverlay" onclick="closeBottomSheet()"></div>

    <!-- Mobile: Bottom Sheet -->
    <div class="bottom-sheet" id="bottomSheet">
        <div class="bottom-sheet-handle"></div>
        <!-- Prepared scripts section -->
        <div class="bottom-sheet-section" id="sheetPreparedSection" style="display:none;">
            <div class="bottom-sheet-section-title">📋 準備好的講稿</div>
            <div class="bottom-sheet-grid" id="sheetPreparedCards"></div>
        </div>
        <!-- Quick phrases section -->
        <div class="bottom-sheet-section">
            <div class="bottom-sheet-section-title">⚡ 常用回應</div>
            <div class="bottom-sheet-grid">
                <button class="quick-phrase-btn" onclick="showQuickPhrase(0); closeBottomSheet();" title="請再說一次">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 12a9 9 0 0 0-9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path>
                        <path d="M3 3v5h5"></path>
                    </svg>
                    再說一次
                </button>
                <button class="quick-phrase-btn" onclick="showQuickPhrase(1); closeBottomSheet();" title="請慢點說">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                    慢點說
                </button>
                <button class="quick-phrase-btn" onclick="showQuickPhrase(2); closeBottomSheet();" title="我確認一下">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    確認一下
                </button>
                <button class="quick-phrase-btn" onclick="showQuickPhrase(3); closeBottomSheet();" title="謝謝再見">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M4.5 21.5l6-6M9 10.5L4.5 15m0 0l6 6"></path>
                    </svg>
                    謝謝
                </button>
            </div>
        </div>
        <!-- Panic section -->
        <div class="bottom-sheet-section">
            <button class="panic-btn" onclick="triggerPanic(); closeBottomSheet();">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                    <line x1="12" y1="9" x2="12" y2="13"></line>
                    <line x1="12" y1="17" x2="12.01" y2="17"></line>
                </svg>
                求助
            </button>
        </div>
    </div>

    <!-- Copy Toast -->
    <div id="copyToast" class="copy-toast">已複製!</div>

    <!-- Teleprompter Overlay (for quick phrases, panic, prepared cards) -->
    <div class="teleprompter-overlay" id="teleprompterOverlay" onclick="closeTeleprompterOverlay(event)">
        <div class="teleprompter-overlay-content" onclick="event.stopPropagation()">
            <button class="teleprompter-overlay-close" onclick="closeTeleprompterOverlay()" aria-label="關閉">
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
            <div>
                <div class="teleprompter-overlay-label" id="overlayLabel">English</div>
                <div class="teleprompter-overlay-english" id="overlayEnglish"></div>
            </div>
            <div class="teleprompter-overlay-chinese" id="overlayChinese"></div>
            <!-- Prepared scripts shown in panic mode -->
            <div class="teleprompter-overlay-scripts" id="overlayScripts" style="display:none;">
                <div class="teleprompter-overlay-scripts-title">你準備好的講稿：</div>
                <div id="overlayScriptsList"></div>
            </div>
        </div>
    </div>

    <!-- Load modules -->
    <script src="/static/segment_store.js"></script>
    <script src="/static/realtime_event_handler.js"></script>
    <script src="/static/segment_renderer.js"></script>
    <script src="/static/audio_capture.js"></script>
    <script src="/static/webspeech_realtime.js"></script>
    <script src="/static/smart_segmenter.js"></script>
    <script src="/static/translation_validator.js"></script>

    <script>
        // ============================================
        // ECA - English Conversation Assistant
        // 英文對話助手 - 即時翻譯工具
        // ============================================

        // ============================================
        // Localization System (地區化系統)
        // Supports: zh-HK (繁體), zh-CN (简体), en
        // ============================================

        const TRANSLATIONS = {
            'zh-HK': {
                appTitle: '英文對話助手',
                appSubtitle: '即時英譯中翻譯',
                statusConnected: '翻譯中',
                statusDisconnected: '未連線',
                statusConnecting: '連線中...',
                statusPaused: '已暫停',
                statusSpeaking: '我在說話',
                selectScenario: '選擇場景',
                prepareScript: '準備講稿',
                savedScripts: '已儲存的講稿',
                noSavedScripts: '尚未儲存任何講稿',
                scriptInputLabel: '我想說...（中文）',
                scriptInputPlaceholder: '輸入你想說的話，例如：我想詢問這筆費用是什麼',
                generateScript: '生成講稿',
                quickPrompts: '快速選擇常用目的：',
                yourScript: '你的講稿',
                copy: '複製',
                regenerate: '重新生成',
                saveAsCard: '儲存為快捷卡片',
                otherWays: '其他說法：',
                accentRecognition: '英語口音識別：',
                otherPartyAccent: '對方口音',
                myAccent: '我的口音',
                accentHint: '（通話開始時套用）',
                translationSpeed: '翻譯速度：',
                accentUS: '美式 (US)',
                accentUK: '英式 (UK)',
                accentAU: '澳洲 (AU)',
                accentIN: '印度 (IN)',
                accentAsia: '亞洲口音 (粵/普)',
                accentNZ: '紐西蘭 (NZ)',
                accentCA: '加拿大 (CA)',
                accentZA: '南非 (ZA)',
                accentPH: '菲律賓 (PH)',
                speedUltraFast: '極速',
                speedFast: '快速',
                speedBalanced: '平衡',
                speedStable: '穩定',
                speedConservative: '保守',
                startListening: '開始聆聽',
                stopListening: '結束通話',
                iAmSpeaking: '我在說話',
                pause: '暫停',
                resume: '繼續',
                translated: '已翻譯：',
                segments: '段',
                quickResponse: '快速回應',
                endCall: '結束通話',
                emptyTranscript: '對話內容將會在此顯示',
                speakerThem: '對方',
                speakerMe: '我',
                apiKeySettings: 'OpenAI API Key',
                apiKeyDesc: '翻譯功能需要 OpenAI API Key（可在 platform.openai.com 取得）',
                apiKeyPlaceholder: 'sk-...',
                apiKeySave: '儲存',
                apiKeyClear: '清除',
                apiKeyStatus: '狀態：',
                apiKeySet: '已設定 ✓',
                apiKeyNotSet: '未設定',
                apiKeySecurityNote: '🔒 安全提示：API Key 只會儲存在你的瀏覽器本機 (localStorage)，我們不會收集或儲存你的 API Key。',
                apiKeyRequired: '⚠️ 需要提供 OpenAI API Key 才能使用翻譯功能',
                apiKeyInvalidFormat: 'API Key 格式錯誤，需以「sk-」開頭',
                apiKeySaveFailed: 'API Key 儲存失敗',
                noExportData: '目前沒有翻譯記錄可以匯出',
                language: '語言',
                langZhHK: '繁體',
                langZhCN: '简体',
                langEn: 'ENG',
                scenarioGeneral: '一般對話',
                scenarioBank: '銀行/金融',
                scenarioNHS: '醫療/NHS',
                scenarioUtilities: '水電煤',
                scenarioInsurance: '保險',
                scenarioGovernment: '政府部門',
                loading: '載入中...',
                error: '錯誤',
                success: '成功',
                warning: '警告',
                pwaWarningTitle: '⚠️ 語音功能受限',
                pwaWarningText: '「主畫面」模式暫不支援語音辨識。請用 Safari 開啟此網址以使用完整功能。',
                pwaWarningCopy: '📋 複製網址到 Safari 開啟'
            },
            'zh-CN': {
                appTitle: '英文对话助手',
                appSubtitle: '实时英译中翻译',
                statusConnected: '翻译中',
                statusDisconnected: '未连接',
                statusConnecting: '连接中...',
                statusPaused: '已暂停',
                statusSpeaking: '我在说话',
                selectScenario: '选择场景',
                prepareScript: '准备讲稿',
                savedScripts: '已保存的讲稿',
                noSavedScripts: '尚未保存任何讲稿',
                scriptInputLabel: '我想说...（中文）',
                scriptInputPlaceholder: '输入你想说的话，例如：我想问一下这笔费用是什么',
                generateScript: '生成讲稿',
                quickPrompts: '快速选择常用目的：',
                yourScript: '你的讲稿',
                copy: '复制',
                regenerate: '重新生成',
                saveAsCard: '保存为快捷卡片',
                otherWays: '其他说法：',
                accentRecognition: '英语口音识别：',
                otherPartyAccent: '对方口音',
                myAccent: '我的口音',
                accentHint: '（通话开始时套用）',
                translationSpeed: '翻译速度：',
                accentUS: '美式 (US)',
                accentUK: '英式 (UK)',
                accentAU: '澳洲 (AU)',
                accentIN: '印度 (IN)',
                accentAsia: '亚洲口音 (粤/普)',
                accentNZ: '新西兰 (NZ)',
                accentCA: '加拿大 (CA)',
                accentZA: '南非 (ZA)',
                accentPH: '菲律宾 (PH)',
                speedUltraFast: '极速',
                speedFast: '快速',
                speedBalanced: '平衡',
                speedStable: '稳定',
                speedConservative: '保守',
                startListening: '开始聆听',
                stopListening: '结束通话',
                iAmSpeaking: '我在说话',
                pause: '暂停',
                resume: '继续',
                translated: '已翻译：',
                segments: '段',
                quickResponse: '快速回应',
                endCall: '结束通话',
                emptyTranscript: '对话内容将会在这里显示',
                speakerThem: '对方',
                speakerMe: '我',
                apiKeySettings: 'OpenAI API Key',
                apiKeyDesc: '翻译功能需要 OpenAI API Key（可在 platform.openai.com 获取）',
                apiKeyPlaceholder: 'sk-...',
                apiKeySave: '保存',
                apiKeyClear: '清除',
                apiKeyStatus: '状态：',
                apiKeySet: '已设置 ✓',
                apiKeyNotSet: '未设置',
                apiKeySecurityNote: '🔒 安全提示：API Key 只会存储在您的浏览器本地 (localStorage)，我们不会收集或存储您的 API Key。',
                apiKeyRequired: '⚠️ 需要提供 OpenAI API Key 才能使用翻译功能',
                apiKeyInvalidFormat: 'API Key 格式错误，需以「sk-」开头',
                apiKeySaveFailed: 'API Key 保存失败',
                noExportData: '目前没有翻译记录可以导出',
                language: '语言',
                langZhHK: '繁體',
                langZhCN: '简体',
                langEn: 'ENG',
                scenarioGeneral: '一般对话',
                scenarioBank: '银行/金融',
                scenarioNHS: '医疗/NHS',
                scenarioUtilities: '水电燃气',
                scenarioInsurance: '保险',
                scenarioGovernment: '政府部门',
                loading: '加载中...',
                error: '错误',
                success: '成功',
                warning: '警告',
                pwaWarningTitle: '⚠️ 语音功能受限',
                pwaWarningText: '「主画面」模式暂不支持语音识别。请用 Safari 打开此网址以使用完整功能。',
                pwaWarningCopy: '📋 复制网址到 Safari 打开'
            },
            'en': {
                appTitle: 'English Conversation Assistant',
                appSubtitle: 'Real-time English to Chinese Translation',
                statusConnected: 'Translating',
                statusDisconnected: 'Disconnected',
                statusConnecting: 'Connecting...',
                statusPaused: 'Paused',
                statusSpeaking: 'I am speaking',
                selectScenario: 'Select Scenario',
                prepareScript: 'Prepare Script',
                savedScripts: 'Saved Scripts',
                noSavedScripts: 'No saved scripts yet',
                scriptInputLabel: 'I want to say... (Chinese)',
                scriptInputPlaceholder: 'Enter what you want to say',
                generateScript: 'Generate Script',
                quickPrompts: 'Quick select common purposes:',
                yourScript: 'Your Script',
                copy: 'Copy',
                regenerate: 'Regenerate',
                saveAsCard: 'Save as Quick Card',
                otherWays: 'Alternative phrases:',
                accentRecognition: 'English Accent Recognition:',
                otherPartyAccent: "Other Party's Accent",
                myAccent: 'My Accent',
                accentHint: '(Applied at call start)',
                translationSpeed: 'Translation Speed:',
                accentUS: 'American (US)',
                accentUK: 'British (UK)',
                accentAU: 'Australian (AU)',
                accentIN: 'Indian (IN)',
                accentAsia: 'Asian Accent (Canto/Mando)',
                accentNZ: 'New Zealand (NZ)',
                accentCA: 'Canadian (CA)',
                accentZA: 'South African (ZA)',
                accentPH: 'Filipino (PH)',
                speedUltraFast: 'Ultra Fast',
                speedFast: 'Fast',
                speedBalanced: 'Balanced',
                speedStable: 'Stable',
                speedConservative: 'Conservative',
                startListening: 'Start Listening',
                stopListening: 'End Call',
                iAmSpeaking: 'I am speaking',
                pause: 'Pause',
                resume: 'Resume',
                translated: 'Translated:',
                segments: 'segments',
                quickResponse: 'Quick Response',
                endCall: 'End Call',
                emptyTranscript: 'Conversation will appear here',
                speakerThem: 'Them',
                speakerMe: 'Me',
                apiKeySettings: 'OpenAI API Key',
                apiKeyDesc: 'Translation requires an OpenAI API Key (get one at platform.openai.com)',
                apiKeyPlaceholder: 'sk-...',
                apiKeySave: 'Save',
                apiKeyClear: 'Clear',
                apiKeyStatus: 'Status:',
                apiKeySet: 'Set ✓',
                apiKeyNotSet: 'Not set',
                apiKeySecurityNote: "🔒 Security: API Key is stored only in your browser's localStorage. We do not collect or store your API Key.",
                apiKeyRequired: '⚠️ OpenAI API Key required for translation',
                apiKeyInvalidFormat: 'Invalid API Key format. Should start with "sk-"',
                apiKeySaveFailed: 'Failed to save API Key',
                noExportData: 'No translation records to export',
                language: 'Language',
                langZhHK: '繁體',
                langZhCN: '简体',
                langEn: 'ENG',
                scenarioGeneral: 'General',
                scenarioBank: 'Banking',
                scenarioNHS: 'Healthcare/NHS',
                scenarioUtilities: 'Utilities',
                scenarioInsurance: 'Insurance',
                scenarioGovernment: 'Government',
                loading: 'Loading...',
                error: 'Error',
                success: 'Success',
                warning: 'Warning',
                pwaWarningTitle: '⚠️ Voice Feature Unavailable',
                pwaWarningText: 'Speech recognition is not supported in Home Screen mode. Please open this URL in Safari for full functionality.',
                pwaWarningCopy: '📋 Copy URL to open in Safari'
            }
        };

        let currentLanguage = 'zh-HK';
        const LANGUAGE_STORAGE_KEY = 'eca_language';
        const API_KEY_STORAGE_KEY = 'eca_openai_api_key';

        function t(key) {
            return (TRANSLATIONS[currentLanguage] || TRANSLATIONS['zh-HK'])[key] || key;
        }

        function loadLanguagePreference() {
            try {
                const saved = localStorage.getItem(LANGUAGE_STORAGE_KEY);
                if (saved && TRANSLATIONS[saved]) currentLanguage = saved;
            } catch (e) {}
            console.log(`[i18n] Language: ${currentLanguage}`);
        }

        function saveLanguagePreference(lang) {
            if (!TRANSLATIONS[lang]) return;
            currentLanguage = lang;
            try { localStorage.setItem(LANGUAGE_STORAGE_KEY, lang); } catch (e) {}
        }

        function updateUILanguage() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                if (key) el.textContent = t(key);
            });
            document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
                const key = el.getAttribute('data-i18n-placeholder');
                if (key) el.placeholder = t(key);
            });
            document.querySelectorAll('[data-i18n-title]').forEach(el => {
                const key = el.getAttribute('data-i18n-title');
                if (key) el.title = t(key);
            });
            updateAccentSelectOptions();
            const langSelect = document.getElementById('languageSelect');
            if (langSelect) langSelect.value = currentLanguage;
            document.title = `${t('appTitle')} - English Conversation Assistant`;
        }

        function updateAccentSelectOptions() {
            // 使用陣列允許多個選項映射到相同的語言代碼
            const opts = [
                { value: 'en-GB', labelKey: 'accentUK' },
                { value: 'en-US', labelKey: 'accentUS' },
                { value: 'en-AU', labelKey: 'accentAU' },
                { value: 'en-IN', labelKey: 'accentAsia' },  // 亞洲口音放前面（推薦）
                { value: 'en-IN', labelKey: 'accentIN' },    // 保留印度選項
                { value: 'en-NZ', labelKey: 'accentNZ' },
                { value: 'en-CA', labelKey: 'accentCA' },
                { value: 'en-ZA', labelKey: 'accentZA' },
                { value: 'en-PH', labelKey: 'accentPH' }
            ];
            ['accentThem', 'accentMe'].forEach(id => {
                const sel = document.getElementById(id);
                if (!sel) return;
                const val = sel.value;
                sel.innerHTML = '';
                opts.forEach(({ value, labelKey }) => {
                    const opt = document.createElement('option');
                    opt.value = value;
                    opt.textContent = t(labelKey);
                    sel.appendChild(opt);
                });
                sel.value = val;
            });
        }

        function changeLanguage(lang) {
            saveLanguagePreference(lang);
            updateUILanguage();
            // 🐛 Bug fix: 語言切換後要重新設定 API Key 狀態，否則會被 data-i18n 覆蓋
            updateApiKeyStatus(userApiKey !== null);
            if (typeof renderScenarioGrid === 'function') renderScenarioGrid();
            if (typeof renderQuickPrompts === 'function') renderQuickPrompts(selectedScenario);
            if (typeof renderSavedScripts === 'function') renderSavedScripts();
        }

        // ============================================
        // API Key Management
        // ============================================

        let userApiKey = null;

        function loadApiKey() {
            try {
                const saved = localStorage.getItem(API_KEY_STORAGE_KEY);
                if (saved) { userApiKey = saved; updateApiKeyStatus(true); return true; }
            } catch (e) {}
            updateApiKeyStatus(false);
            return false;
        }

        function saveApiKey() {
            const input = document.getElementById('apiKeyInput');
            if (!input) return;
            const key = input.value.trim();
            if (!key || !key.startsWith('sk-')) {
                alert(t('apiKeyInvalidFormat'));
                return;
            }
            try {
                localStorage.setItem(API_KEY_STORAGE_KEY, key);
                userApiKey = key;
                input.value = '';
                updateApiKeyStatus(true);
            } catch (e) { alert(t('apiKeySaveFailed')); }
        }

        function clearApiKey() {
            try {
                localStorage.removeItem(API_KEY_STORAGE_KEY);
                userApiKey = null;
                updateApiKeyStatus(false);
            } catch (e) {}
        }

        function updateApiKeyStatus(isSet) {
            const sectionEl = document.getElementById('apiKeySection');
            const statusEl = document.getElementById('apiKeyStatusText');
            const inputEl = document.getElementById('apiKeyInput');
            const saveBtn = document.getElementById('apiKeySaveBtn');
            const clearBtn = document.getElementById('apiKeyClearBtn');
            if (statusEl) {
                statusEl.textContent = isSet ? t('apiKeySet') : t('apiKeyNotSet');
                statusEl.className = isSet ? 'api-key-status set' : 'api-key-status not-set';
            }
            if (inputEl) inputEl.placeholder = isSet ? '••••••••••••••••' : t('apiKeyPlaceholder');
            if (saveBtn) saveBtn.style.display = isSet ? 'none' : '';
            if (clearBtn) clearBtn.style.display = isSet ? '' : 'none';
            // Auto-collapse when API key is set
            if (sectionEl) {
                if (isSet) {
                    sectionEl.classList.add('collapsed');
                } else {
                    sectionEl.classList.remove('collapsed');
                }
            }
        }

        function toggleApiKeyDetails() {
            const sectionEl = document.getElementById('apiKeySection');
            if (sectionEl) {
                sectionEl.classList.toggle('collapsed');
            }
        }

        function getApiKey() { return userApiKey; }

        // ============================================
        // Scenario Data (from script_generator.py)
        // ============================================

        const SCENARIOS = {
            bank: {
                name: '銀行',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>`,
                vocab: ['account', 'balance', 'transaction', 'statement', 'charge', 'fee', 'transfer'],
                placeholder: '例如：我想查詢帳戶餘額',
                defaultPrompts: [
                    { label: '查詢餘額', prompt: '我想查詢帳戶餘額和最近的交易記錄' },
                    { label: '不明收費', prompt: '我想詢問帳戶上一筆不明的收費是什麼' },
                    { label: '更新資料', prompt: '我想更新我的地址和電話號碼' },
                    { label: '開戶咨詢', prompt: '我想了解開立新帳戶需要什麼文件' },
                    { label: '轉帳問題', prompt: '我想查詢一筆轉帳為什麼還沒到帳' },
                    { label: '掛失卡片', prompt: '我的銀行卡遺失了，想辦理掛失和補發' },
                    { label: '申請貸款', prompt: '我想了解個人貸款的利率和申請條件' }
                ]
            },
            nhs: {
                name: '醫療',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 12h-4l-3 9L9 3l-3 9H2"></path></svg>`,
                vocab: ['appointment', 'prescription', 'symptoms', 'referral', 'doctor', 'surgery'],
                placeholder: '例如：我想預約看 GP',
                defaultPrompts: [
                    { label: '預約 GP', prompt: '我想預約看 GP 的時間' },
                    { label: '領處方簽', prompt: '我想詢問我的處方簽是否可以領取' },
                    { label: '轉診進度', prompt: '我想查詢專科轉診的進度' },
                    { label: '檢驗結果', prompt: '我想詢問上次檢驗的結果出來了嗎' },
                    { label: '取消預約', prompt: '我想取消或更改我的預約時間' },
                    { label: '病假證明', prompt: '我需要一份病假證明給我的雇主' },
                    { label: '重複處方', prompt: '我想申請重複處方的續期' }
                ]
            },
            utilities: {
                name: '水電',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2L3 14h9l-1 8 10-12h-9l1-8z"></path></svg>`,
                vocab: ['bill', 'meter reading', 'tariff', 'direct debit', 'account number'],
                placeholder: '例如：我想查詢帳單',
                defaultPrompts: [
                    { label: '查帳單', prompt: '我想查詢最新的帳單金額' },
                    { label: '更新付款', prompt: '我想更新 Direct Debit 的銀行資料' },
                    { label: '報讀數', prompt: '我想報告電錶/瓦斯表的讀數' },
                    { label: '換方案', prompt: '我想了解有沒有更優惠的方案' },
                    { label: '搬家通知', prompt: '我下個月要搬家，想通知更新地址' },
                    { label: '付款困難', prompt: '我暫時有經濟困難，想了解分期付款的選項' },
                    { label: '斷供投訴', prompt: '我家突然停電/停水了，想查詢原因和恢復時間' }
                ]
            },
            insurance: {
                name: '保險',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>`,
                vocab: ['policy', 'claim', 'excess', 'cover', 'premium', 'renewal'],
                placeholder: '例如：我想了解保單內容',
                defaultPrompts: [
                    { label: '保障範圍', prompt: '我想了解我的保單涵蓋範圍' },
                    { label: '提出理賠', prompt: '我想提出一個理賠申請' },
                    { label: '續約保費', prompt: '我想詢問保費續約的金額' },
                    { label: '更改資料', prompt: '我想更改保單上的個人資料' },
                    { label: '取消保單', prompt: '我想了解取消保單的流程' },
                    { label: '理賠進度', prompt: '我想查詢我之前提出的理賠申請目前的進度' },
                    { label: '加保項目', prompt: '我想了解可以加保哪些額外項目，例如牙科或眼科' }
                ]
            },
            general: {
                name: '一般',
                icon: `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`,
                vocab: ['enquiry', 'confirm', 'reference number', 'information', 'details'],
                placeholder: '例如：您好，我想詢問一些事情',
                defaultPrompts: [
                    { label: '一般詢問', prompt: '您好，我想詢問一些事情' },
                    { label: '確認狀態', prompt: '我想確認我的預約/訂單狀態' },
                    { label: '客服轉接', prompt: '請問可以幫我轉接客服部門嗎' },
                    { label: '投訴反映', prompt: '我想反映一個問題' },
                    { label: '感謝結束', prompt: '好的，謝謝你的幫忙，再見' },
                    { label: '留言回電', prompt: '請問可以留言嗎？請他方便時回電給我' },
                    { label: '索取編號', prompt: '可以給我這次通話的參考編號嗎？' }
                ]
            }
        };

        // Quick Phrases (hardcoded, no API call)
        const QUICK_PHRASES = [
            { english: "Could you repeat that, please?", chinese: "請再說一次" },
            { english: "Could you speak more slowly?", chinese: "請慢點說" },
            { english: "Let me confirm that...", chinese: "我確認一下" },
            { english: "Thank you. Goodbye.", chinese: "謝謝再見" }
        ];

        // Panic Button stalling phrases (rotate randomly)
        const STALLING_PHRASES = [
            { english: "Let me think about that for a moment...", chinese: "讓我想一下..." },
            { english: "That's a good question. Give me a second...", chinese: "好問題，請給我一秒..." },
            { english: "Could you hold on for just a second?", chinese: "請稍等一下好嗎？" },
            { english: "I want to make sure I understand correctly...", chinese: "我想確認我理解正確..." },
            { english: "Let me just check something quickly...", chinese: "讓我快速確認一下..." },
            { english: "Hmm, let me consider that...", chinese: "嗯，讓我考慮一下..." },
            { english: "I need a moment to think about this...", chinese: "我需要一點時間想想..." },
            { english: "That's interesting. Let me think...", chinese: "這很有趣，讓我想想..." }
        ];

        let lastStallingIndex = -1;

        // ============================================
        // localStorage key for saved scripts
        // ============================================

        const STORAGE_KEY = 'eca_prepared_scripts';

        // ============================================
        // Selected scenario state
        // ============================================

        let selectedScenario = 'general';

        // ============================================
        // Call timer
        // ============================================

        let callTimerInterval = null;
        let callStartTime = null;

        // State
        let audioCapture = null;
        let peerConnection = null;
        let dataChannel = null;
        let isConnected = false;

        // New modules
        let eventHandler = null;
        let renderer = null;

        // Web Speech for real-time English subtitles (雙軌策略)
        let webSpeech = null;
        let currentRealtimeEnglish = '';  // 當前實時英文預覽

        // Smart Segmenter for intelligent segmentation (600ms vs 2-3s)
        let smartSegmenter = null;

        // ============================================
        // Segmenter Presets Configuration
        // ============================================

        const SEGMENTER_PRESETS = {
            'ultra-fast': {
                name: '極速',
                pauseThreshold: 400,    // 更短的暫停偵測
                stabilityDelay: 80,     // 更短的穩定等待
                softLimit: 12,          // 更短的軟性限制
                hardLimit: 20,          // 更短的硬性限制
                minSegmentWords: 2,     // 更少的最小字數
                description: '最快反應，可能切斷單詞'
            },
            'fast': {
                name: '快速',
                pauseThreshold: 500,
                stabilityDelay: 100,
                softLimit: 14,
                hardLimit: 22,
                minSegmentWords: 3,
                description: '快速反應，輕微風險'
            },
            'balanced': {
                name: '平衡',
                pauseThreshold: 600,
                stabilityDelay: 150,
                softLimit: 15,
                hardLimit: 25,
                minSegmentWords: 3,
                description: '平衡速度與穩定性（預設）'
            },
            'stable': {
                name: '穩定',
                pauseThreshold: 750,
                stabilityDelay: 200,
                softLimit: 18,
                hardLimit: 28,
                minSegmentWords: 4,
                description: '更穩定，較慢'
            },
            'conservative': {
                name: '保守',
                pauseThreshold: 900,
                stabilityDelay: 250,
                softLimit: 20,
                hardLimit: 30,
                minSegmentWords: 4,
                description: '最穩定，最慢'
            }
        };

        let currentPreset = 'fast';

        function applyPreset(presetKey) {
            const preset = SEGMENTER_PRESETS[presetKey];
            if (!preset) {
                log(`Unknown preset: ${presetKey}`, 'error');
                return;
            }

            currentPreset = presetKey;

            // Update UI
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === presetKey);
            });

            // Apply to SmartSegmenter if it exists
            if (smartSegmenter) {
                smartSegmenter.pauseThreshold = preset.pauseThreshold;
                smartSegmenter.stabilityDelay = preset.stabilityDelay;
                smartSegmenter.softLimit = preset.softLimit;
                smartSegmenter.hardLimit = preset.hardLimit;
                smartSegmenter.minSegmentWords = preset.minSegmentWords;
                log(`Preset: ${preset.name}`, 'success');
            }
        }

        // Toggle log panel visibility
        function toggleLogPanel() {
            const logPanel = document.getElementById('logPanel');
            const logToggle = document.getElementById('logToggle');
            const isCollapsed = logPanel.classList.contains('collapsed');

            logPanel.classList.toggle('collapsed');
            logToggle.classList.toggle('expanded');

            // Update button text
            const textSpan = logToggle.querySelector('span');
            textSpan.textContent = isCollapsed ? '隱藏日誌' : '顯示日誌';
        }

        // =============================================
        // Phase 1: Scenario Selector
        // =============================================

        function renderScenarioGrid() {
            const grid = document.getElementById('scenarioGrid');
            grid.innerHTML = '';
            for (const [key, scenario] of Object.entries(SCENARIOS)) {
                const card = document.createElement('button');
                card.className = 'scenario-card' + (key === selectedScenario ? ' selected' : '');
                card.setAttribute('tabindex', '0');
                card.setAttribute('aria-label', scenario.name);
                card.onclick = () => selectScenario(key);
                card.innerHTML = `
                    <div class="scenario-card-icon">${scenario.icon}</div>
                    <div class="scenario-card-name">${scenario.name}</div>
                    <div class="scenario-card-vocab">${scenario.vocab.join(', ')}</div>
                `;
                grid.appendChild(card);
            }
        }

        function selectScenario(key) {
            selectedScenario = key;
            document.querySelectorAll('.scenario-card').forEach(card => {
                card.classList.remove('selected');
            });
            // Find the clicked card via scenario-card-name text matching
            document.querySelectorAll('.scenario-card').forEach(card => {
                const nameEl = card.querySelector('.scenario-card-name');
                if (nameEl && nameEl.textContent === SCENARIOS[key].name) {
                    card.classList.add('selected');
                }
            });

            // Update input placeholder and quick prompts
            const scenario = SCENARIOS[key];
            const scriptInput = document.getElementById('scriptInput');
            if (scriptInput && scenario.placeholder) {
                scriptInput.placeholder = scenario.placeholder;
            }
            renderQuickPrompts(key);
        }

        /**
         * Render quick prompt buttons for the selected scenario
         */
        function renderQuickPrompts(scenarioKey) {
            const grid = document.getElementById('quickPromptsGrid');
            if (!grid) return;

            const scenario = SCENARIOS[scenarioKey];
            if (!scenario || !scenario.defaultPrompts) {
                grid.innerHTML = '';
                return;
            }

            grid.innerHTML = scenario.defaultPrompts.map(item => `
                <button class="quick-prompt-btn" onclick="useQuickPrompt('${escapeHtmlForAttr(item.prompt)}')">
                    ${item.label}
                </button>
            `).join('');
        }

        /**
         * Use a quick prompt - fill the input and generate script
         */
        function useQuickPrompt(prompt) {
            const scriptInput = document.getElementById('scriptInput');
            if (scriptInput) {
                scriptInput.value = prompt;
            }
            generateScript();
        }

        // =============================================
        // Phase 1: Saved Scripts (localStorage)
        // =============================================

        function getSavedScripts() {
            try {
                const data = localStorage.getItem(STORAGE_KEY);
                return data ? JSON.parse(data) : [];
            } catch (e) {
                console.error('Error reading saved scripts:', e);
                return [];
            }
        }

        function saveSavedScripts(scripts) {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(scripts));
            } catch (e) {
                console.error('Error saving scripts:', e);
            }
        }

        function saveAsQuickCard() {
            if (!currentScript) return;

            const scripts = getSavedScripts();
            const newCard = {
                id: 'prep-' + Date.now(),
                chinese: document.getElementById('scriptInput').value.trim(),
                english: currentScript,
                scenario: selectedScenario,
                createdAt: Date.now()
            };
            scripts.push(newCard);
            saveSavedScripts(scripts);
            renderSavedScripts();

            // Visual feedback on button
            const btn = document.getElementById('btnSaveCard');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = `
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="20 6 9 17 4 12"></polyline>
                </svg>
                已儲存
            `;
            btn.disabled = true;
            setTimeout(() => {
                btn.innerHTML = originalHTML;
                btn.disabled = false;
            }, 1500);

            log(`[講稿] 已儲存為快捷卡片: "${currentScript.substring(0, 30)}..."`, 'success');
        }

        function deleteSavedScript(id) {
            let scripts = getSavedScripts();
            scripts = scripts.filter(s => s.id !== id);
            saveSavedScripts(scripts);
            renderSavedScripts();
        }

        function renderSavedScripts() {
            const container = document.getElementById('savedScriptsList');
            const emptyEl = document.getElementById('savedScriptsEmpty');
            const scripts = getSavedScripts();

            // Clear existing items (but keep empty state el)
            const existingItems = container.querySelectorAll('.saved-script-item');
            existingItems.forEach(el => el.remove());

            if (scripts.length === 0) {
                emptyEl.style.display = 'block';
                return;
            }

            emptyEl.style.display = 'none';

            // 最新置頂：反轉順序顯示
            scripts.slice().reverse().forEach(script => {
                const item = document.createElement('div');
                item.className = 'saved-script-item';
                const scenarioName = SCENARIOS[script.scenario]?.name || script.scenario;
                const date = new Date(script.createdAt).toLocaleDateString('zh-TW');
                item.innerHTML = `
                    <div class="saved-script-body">
                        <div class="saved-script-english">${escapeHtml(script.english)}</div>
                        <div class="saved-script-chinese">${escapeHtml(script.chinese)}</div>
                        <div class="saved-script-meta">
                            <span>${scenarioName}</span>
                            <span>${date}</span>
                        </div>
                    </div>
                    <button class="saved-script-delete" onclick="deleteSavedScript('${script.id}')" aria-label="刪除" title="刪除">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                        </svg>
                    </button>
                `;
                container.appendChild(item);
            });
        }

        // =============================================
        // Phase 1: Mode Switching (Preparation <-> Call)
        // =============================================

        function switchToCallMode() {
            document.getElementById('preparationMode').classList.add('hidden');
            document.getElementById('callMode').classList.add('active');
            document.getElementById('quickResponseBar').style.display = '';
            // Mobile: show bottom bar + peek bar
            document.getElementById('callBottomBar').classList.add('active');
            document.getElementById('peekBar').classList.add('active');
            renderPreparedCards();
            renderSheetPreparedCards();
            startCallTimer();
        }

        function switchToPreparationMode() {
            document.getElementById('preparationMode').classList.remove('hidden');
            document.getElementById('callMode').classList.remove('active');
            document.getElementById('quickResponseBar').style.display = 'none';
            document.getElementById('suggestionPanel').style.display = 'none';
            // Mobile: hide bottom bar + peek bar + sheet
            document.getElementById('callBottomBar').classList.remove('active');
            document.getElementById('peekBar').classList.remove('active');
            closeBottomSheet();
            stopCallTimer();
        }

        // =============================================
        // Mobile UI: Overflow Menu, Bottom Sheet, Toggle
        // =============================================

        function toggleOverflowMenu() {
            const menu = document.getElementById('overflowMenu');
            menu.classList.toggle('open');
        }

        function closeOverflowMenu() {
            document.getElementById('overflowMenu').classList.remove('open');
        }

        // Close overflow menu on outside click
        document.addEventListener('click', function(e) {
            const wrapper = document.querySelector('.overflow-menu-wrapper');
            if (wrapper && !wrapper.contains(e.target)) {
                closeOverflowMenu();
            }
        });

        function toggleBottomSheet() {
            const sheet = document.getElementById('bottomSheet');
            const overlay = document.getElementById('bottomSheetOverlay');
            const peek = document.getElementById('peekBar');
            const isOpen = sheet.classList.contains('open');
            if (isOpen) {
                closeBottomSheet();
            } else {
                sheet.classList.add('open');
                overlay.classList.add('open');
                peek.classList.add('sheet-open');
            }
        }

        function closeBottomSheet() {
            document.getElementById('bottomSheet').classList.remove('open');
            document.getElementById('bottomSheetOverlay').classList.remove('open');
            document.getElementById('peekBar').classList.remove('sheet-open');
        }

        function togglePauseResume() {
            const btn = document.getElementById('btnPauseResumeMobile');
            const icon = document.getElementById('pauseResumeIcon');
            const label = document.getElementById('pauseResumeLabel');
            if (btn.classList.contains('paused')) {
                // Resume
                resumeListening();
                btn.classList.remove('paused');
                icon.innerHTML = '<rect x="6" y="4" width="4" height="16" rx="1"></rect><rect x="14" y="4" width="4" height="16" rx="1"></rect>';
                label.textContent = '暫停';
            } else {
                // Pause
                pauseListening();
                btn.classList.add('paused');
                icon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3"></polygon>';
                label.textContent = '繼續';
            }
        }

        // Render prepared script cards in bottom sheet
        function renderSheetPreparedCards() {
            const container = document.getElementById('sheetPreparedCards');
            const section = document.getElementById('sheetPreparedSection');
            if (!container || !section) return;

            const savedCards = JSON.parse(localStorage.getItem('eca_prepared_cards') || '[]');
            if (savedCards.length === 0) {
                section.style.display = 'none';
                return;
            }

            section.style.display = '';
            container.innerHTML = '';
            savedCards.forEach(card => {
                const btn = document.createElement('button');
                btn.className = 'prepared-card';
                btn.tabIndex = 0;
                const displayText = card.chinese
                    ? card.chinese.substring(0, 8) + ' / ' + card.english.substring(0, 12)
                    : card.english.substring(0, 20);
                btn.innerHTML = `<span class="prepared-card-icon"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline></svg></span><span>${displayText}</span>`;
                btn.onclick = () => {
                    showTeleprompterOverlay(card.english, card.chinese || '');
                    closeBottomSheet();
                };
                container.appendChild(btn);
            });
        }

        // =============================================
        // Phase 1: PTT (Push-to-Talk / 角色標記模式)
        // 用途：區分「對方說話」和「我在說話」
        // Spacebar HOLD 模式：按住=我，放開=對方
        // =============================================

        let isPTTActive = false;
        let currentSpeaker = 'them';  // 'them' (預設) 或 'me' (按住 Spacebar 時)

        // =============================================
        // 口音設定（localStorage 持久化）
        // =============================================

        const ACCENT_STORAGE_KEY = 'eca_accent_settings';
        let accentThem = 'en-GB';  // 對方的英語口音（預設：英式）
        let accentMe = 'en-IN';    // 我的英語口音（預設：亞洲口音）

        /**
         * 載入口音設定（從 localStorage）
         */
        function loadAccentSettings() {
            try {
                const saved = localStorage.getItem(ACCENT_STORAGE_KEY);
                if (saved) {
                    const settings = JSON.parse(saved);
                    accentThem = settings.them || 'en-GB';
                    accentMe = settings.me || 'en-IN';
                }
            } catch (e) {
                console.warn('[Accent] Failed to load settings:', e);
            }

            // 更新 UI
            const selectThem = document.getElementById('accentThem');
            const selectMe = document.getElementById('accentMe');
            if (selectThem) selectThem.value = accentThem;
            if (selectMe) selectMe.value = accentMe;

            console.log(`[Accent] Loaded: them=${accentThem}, me=${accentMe}`);
        }

        /**
         * 儲存口音設定（到 localStorage）
         */
        function saveAccentSettings() {
            const selectThem = document.getElementById('accentThem');
            const selectMe = document.getElementById('accentMe');

            if (selectThem) accentThem = selectThem.value;
            if (selectMe) accentMe = selectMe.value;

            try {
                localStorage.setItem(ACCENT_STORAGE_KEY, JSON.stringify({
                    them: accentThem,
                    me: accentMe
                }));
                console.log(`[Accent] Saved: them=${accentThem}, me=${accentMe}`);
            } catch (e) {
                console.warn('[Accent] Failed to save settings:', e);
            }
        }

        /**
         * 切換 Web Speech 語言（用於 PTT 切換）
         * @param {string} speaker - 'them' 或 'me'
         */
        function switchAccent(speaker) {
            if (!webSpeech || !webSpeech.isSupported()) return;

            const targetLang = speaker === 'me' ? accentMe : accentThem;
            const currentLang = webSpeech.getLanguage();

            if (currentLang !== targetLang) {
                webSpeech.setLanguage(targetLang);
                log(`[Accent] Switched to ${targetLang} (${speaker})`, 'info');
            }
        }

        /**
         * PTT 開始 - 切換為「我在說話」模式
         * 🔧 角色標記機制（非靜音）：
         * 1. 強制輸出 buffer 中的內容（標記為「對方」）
         * 2. 切換 currentSpeaker = 'me'
         * 3. Web Speech 和 SmartSegmenter 繼續運行
         */
        function pttStart() {
            console.log('[PTT] pttStart called:', { isPTTActive, isPaused, isConnected });
            if (isPTTActive || isPaused || !isConnected) {
                console.log('[PTT] pttStart blocked:', { isPTTActive, isPaused, isConnected });
                return;
            }
            isPTTActive = true;

            // 🔧 先強制輸出 SmartSegmenter buffer 中的所有內容（標記為「對方」）
            // 這確保切換前的對方說話內容不會丟失
            if (smartSegmenter && smartSegmenter.buffer && smartSegmenter.buffer.trim()) {
                smartSegmenter._emitSegment('speaker_change');
                console.log('[PTT] Force emitted buffer before speaker change');
            }

            // 🔧 關鍵：切換說話者為「我」
            currentSpeaker = 'me';

            // 🔧 2024-02-11 修復：移除口音切換，避免 WebSpeech restart 導致音訊丟失
            // 原本：switchAccent('me') 會觸發 100-500ms 的延遲
            // 現在：只更新 speaker 標記，不切換語言，零延遲
            // 口音設定在通話開始時已設定（對方口音），通話中保持不變

            // 注意：不 mute、不 stop - Web Speech 和 SmartSegmenter 繼續運行
            // 後續的 segment 會被標記為 speaker='me'

            // 更新按鈕 UI (desktop + mobile)
            const btn = document.getElementById('btnPTT');
            if (btn) btn.classList.add('active');
            const btnM = document.getElementById('btnPTTMobile');
            if (btnM) btnM.classList.add('active');

            // 更新說話者指示器（取代全螢幕覆蓋層）
            updateSpeakerIndicator('me');

            // 更新狀態指示器
            updateStatus('ptt', '我在說話');

            log('PTT: 我在說話模式', 'info');
        }

        /**
         * PTT 結束 - 切換回「對方說話」模式
         * 🔧 角色標記機制：
         * 1. 強制輸出 buffer 中的內容（標記為「我」）
         * 2. 切換 currentSpeaker = 'them'
         */
        function pttEnd() {
            if (!isPTTActive || isPaused) return;
            isPTTActive = false;

            // 🔧 先強制輸出 SmartSegmenter buffer 中的所有內容（標記為「我」）
            if (smartSegmenter && smartSegmenter.buffer && smartSegmenter.buffer.trim()) {
                smartSegmenter._emitSegment('speaker_change');
                console.log('[PTT] Force emitted buffer before speaker change back');
            }

            // 🔧 關鍵：切換說話者回「對方」
            currentSpeaker = 'them';

            // 🔧 2024-02-11 修復：移除口音切換，避免 WebSpeech restart 導致音訊丟失
            // 保持使用通話開始時設定的口音，不中斷識別

            // 更新按鈕 UI (desktop + mobile)
            const btn = document.getElementById('btnPTT');
            if (btn) btn.classList.remove('active');
            const btnM = document.getElementById('btnPTTMobile');
            if (btnM) btnM.classList.remove('active');

            // 更新說話者指示器
            updateSpeakerIndicator('them');

            // 恢復狀態指示器
            updateStatus('connected', '翻譯中');

            log('PTT: 對方說話模式', 'info');
        }

        /**
         * 更新說話者指示器（底部小 badge，取代全螢幕覆蓋層）
         */
        function updateSpeakerIndicator(speaker) {
            let indicator = document.getElementById('speakerIndicator');

            if (!indicator) {
                // 創建指示器元素
                indicator = document.createElement('div');
                indicator.id = 'speakerIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: calc(20px + env(safe-area-inset-bottom, 0px));
                    left: 50%;
                    transform: translateX(-50%);
                    padding: 10px 20px;
                    border-radius: 25px;
                    font-size: 14px;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    z-index: 100;
                    transition: all 0.2s ease;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                `;
                document.body.appendChild(indicator);
            }

            if (speaker === 'me') {
                indicator.innerHTML = '🙋 我在說話';
                indicator.style.background = 'rgba(0, 212, 255, 0.95)';
                indicator.style.color = '#000';
            } else {
                indicator.innerHTML = '👤 對方說話';
                indicator.style.background = 'rgba(0, 255, 136, 0.25)';
                indicator.style.color = 'var(--accent-green)';
                indicator.style.border = '1px solid var(--accent-green)';
            }
        }

        /**
         * 隱藏說話者指示器（離開通話時）
         */
        function hideSpeakerIndicator() {
            const indicator = document.getElementById('speakerIndicator');
            if (indicator) {
                indicator.remove();
            }
        }

        // Spacebar 控制 PTT（HOLD 模式：按住=我，放開=對方）
        document.addEventListener('keydown', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            if (e.code === 'Space') {
                // 通話模式下：永遠阻止 Spacebar 預設滾動行為
                if (isConnected) e.preventDefault();
                // 只在通話中且未暫停時觸發 PTT
                if (isConnected && !isPaused && !e.repeat) {
                    pttStart();
                }
            }
        });

        document.addEventListener('keyup', function(e) {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            if (e.code === 'Space') {
                if (isConnected) e.preventDefault();
                if (isConnected && !isPaused) {
                    pttEnd();
                }
            }
        });

        // =============================================
        // Phase 1: Pause / Resume / Go Home
        // =============================================

        let isPaused = false;

        /**
         * 暫停聆聽 - 停止麥克風但保留在通話頁面
         */
        function pauseListening() {
            if (isPaused) return;
            isPaused = true;

            // 重置 PTT 狀態
            isPTTActive = false;
            const pttBtn = document.getElementById('btnPTT');
            if (pttBtn) {
                pttBtn.classList.remove('active');
            }

            // Stop Web Speech
            if (webSpeech) {
                webSpeech.isRunning = false;
                webSpeech.stop();
                log('WebSpeech paused', 'info');
            }

            // Stop Smart Segmenter
            if (smartSegmenter) {
                smartSegmenter.stop();
                log('SmartSegmenter paused', 'info');
            }

            // Mark realtime preview as stopped
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.classList.add('stopped');
                const labelEl = previewEl.querySelector('.preview-label span:last-child');
                if (labelEl) {
                    labelEl.textContent = '英文原文（已暫停）';
                }
            }

            // Pause timer
            pauseCallTimer();

            // Update UI: show resume, hide pause
            document.getElementById('btnPause').style.display = 'none';
            document.getElementById('btnResume').style.display = '';

            // Update status
            updateStatus('paused', '已暫停');
            // 隱藏說話者指示器
            hideSpeakerIndicator();
            log('Listening paused', 'success');
        }

        /**
         * 繼續聆聽 - 恢復麥克風收音
         */
        function resumeListening() {
            if (!isPaused) return;
            isPaused = false;

            // Restart Web Speech with current speaker's accent
            if (webSpeech && webSpeech.isSupported()) {
                const resumeAccent = currentSpeaker === 'me' ? accentMe : accentThem;
                webSpeech.setLanguage(resumeAccent, false);
                webSpeech.start();
                log(`WebSpeech resumed (${resumeAccent})`, 'success');
            }

            // Restart Smart Segmenter
            if (smartSegmenter) {
                smartSegmenter.start();
                log('SmartSegmenter resumed', 'success');
            }

            // Remove stopped state from preview
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.classList.remove('stopped');
                const labelEl = previewEl.querySelector('.preview-label span:last-child');
                if (labelEl) {
                    labelEl.textContent = '英文原文';
                }
            }

            // Resume timer
            resumeCallTimer();

            // Update UI: show pause, hide resume
            document.getElementById('btnPause').style.display = '';
            document.getElementById('btnResume').style.display = 'none';

            // Update status
            updateStatus('connected', '翻譯中');
            // 恢復說話者指示器
            updateSpeakerIndicator('them');
            log('Listening resumed', 'success');
        }

        /**
         * 返回首頁 - 帶確認對話框
         */
        function goToHome() {
            const confirmed = confirm('確定要離開嗎？翻譯記錄將會清除。');
            if (confirmed) {
                stopTest();
            }
        }

        /**
         * 匯出對話記錄為 Markdown 格式
         */
        function exportTranscript() {
            // 從 DOM 收集所有 segment 數據
            const segmentEls = document.querySelectorAll('.segment-item');

            if (segmentEls.length === 0) {
                alert(t('noExportData'));
                return;
            }

            // 收集數據（DOM 順序是最新在前，需要反轉）
            const segments = [];
            segmentEls.forEach(el => {
                // 說話者標籤（font-weight: 600）
                const speakerEl = el.querySelector('span[style*="font-weight: 600"]');
                // 時間標籤（font-size: 11px）
                const timeEl = el.querySelector('span[style*="font-size: 11px"]');
                // 英文原文（font-size: 18px）
                const englishEl = el.querySelector('div[style*="font-size: 18px"]');
                // 中文翻譯（color: var(--accent-blue)）
                const chineseEl = el.querySelector('div[style*="font-size: 16px"]');

                segments.push({
                    speaker: speakerEl ? speakerEl.textContent.trim() : '👤 對方',
                    english: englishEl ? englishEl.textContent.trim() : '',
                    chinese: chineseEl ? chineseEl.textContent.trim() : '',
                    time: timeEl ? timeEl.textContent.trim() : ''
                });
            });

            // 反轉順序（最舊的在前）
            segments.reverse();

            // 取得場景名稱
            const scenarioName = SCENARIOS[selectedScenario]?.name || selectedScenario;

            // 取得通話時間
            const timerEl = document.getElementById('callTimer');
            const duration = timerEl ? timerEl.textContent : '00:00';

            // 取得完成段數
            const doneCount = document.getElementById('doneCount').textContent || '0';

            // 生成當前日期時間
            const now = new Date();
            const dateStr = now.toLocaleDateString('zh-TW', {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit'
            });
            const timeStr = now.toLocaleTimeString('zh-TW', {
                hour: '2-digit',
                minute: '2-digit'
            });

            // 生成 Markdown 內容
            let markdown = `# 英文對話助手 - 對話記錄

## 基本資訊

| 項目 | 內容 |
|------|------|
| 匯出日期 | ${dateStr} |
| 匯出時間 | ${timeStr} |
| 通話時長 | ${duration} |
| 已翻譯段數 | ${doneCount} 段 |
| 使用場景 | ${scenarioName} |

---

## 對話內容

`;

            // 添加每個段落
            segments.forEach((seg, index) => {
                markdown += `### ${seg.speaker}`;
                if (seg.time) {
                    markdown += ` (${seg.time})`;
                }
                markdown += `

**英文原文：**
> ${seg.english || '(無內容)'}

**中文翻譯：**
> ${seg.chinese || '(翻譯中...)'}

---

`;
            });

            // 添加頁尾
            markdown += `
---

*由 English Conversation Assistant (ECA) 生成*
`;

            // 生成檔案名稱
            const filename = `對話記錄_${dateStr.replace(/\//g, '-')}_${timeStr.replace(/:/g, '')}.md`;

            // 創建下載
            const blob = new Blob([markdown], { type: 'text/markdown;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            log(`已匯出對話記錄：${filename}`, 'success');
        }

        // =============================================
        // Phase 1: Call Timer
        // =============================================

        let pausedElapsedTime = 0;  // 暫停時記錄的已過時間

        function startCallTimer() {
            callStartTime = Date.now();
            pausedElapsedTime = 0;
            const timerEl = document.getElementById('callTimer');
            callTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - callStartTime) / 1000) + pausedElapsedTime;
                const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                const seconds = String(elapsed % 60).padStart(2, '0');
                timerEl.textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function pauseCallTimer() {
            if (callTimerInterval) {
                // 記錄暫停時的已過時間
                pausedElapsedTime += Math.floor((Date.now() - callStartTime) / 1000);
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
        }

        function resumeCallTimer() {
            if (!callTimerInterval) {
                // 重新開始計時，從暫停點繼續
                callStartTime = Date.now();
                const timerEl = document.getElementById('callTimer');
                callTimerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - callStartTime) / 1000) + pausedElapsedTime;
                    const minutes = String(Math.floor(elapsed / 60)).padStart(2, '0');
                    const seconds = String(elapsed % 60).padStart(2, '0');
                    timerEl.textContent = `${minutes}:${seconds}`;
                }, 1000);
            }
        }

        function stopCallTimer() {
            if (callTimerInterval) {
                clearInterval(callTimerInterval);
                callTimerInterval = null;
            }
            pausedElapsedTime = 0;
            const timerEl = document.getElementById('callTimer');
            if (timerEl) timerEl.textContent = '00:00';
        }

        // =============================================
        // Phase 1: Quick Response Bar — Prepared Cards
        // =============================================

        function renderPreparedCards() {
            const row = document.getElementById('preparedCardsRow');
            const divider = document.getElementById('quickResponseDivider');
            const scripts = getSavedScripts();
            row.innerHTML = '';

            // Show max 3 cards (compact layout), 最新的優先顯示
            const toShow = scripts.slice(-3).reverse();

            if (toShow.length > 0) {
                toShow.forEach(script => {
                    const card = document.createElement('button');
                    card.className = 'prepared-card';
                    card.setAttribute('tabindex', '0');
                    // 顯示中文前幾個字，方便用戶辨識
                    const displayText = script.chinese || script.english;
                    const truncated = displayText.length > 8
                        ? displayText.substring(0, 8) + '...'
                        : displayText;
                    card.innerHTML = `
                        <span class="prepared-card-icon">
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path>
                                <polyline points="14 2 14 8 20 8"></polyline>
                            </svg>
                        </span>
                        ${escapeHtml(truncated)}
                    `;
                    card.onclick = () => showTeleprompterOverlay(script.english, script.chinese);
                    row.appendChild(card);
                });
                // Show divider if we have cards
                if (divider) divider.style.display = '';
            } else {
                // Hide divider if no cards
                if (divider) divider.style.display = 'none';
            }
        }

        // =============================================
        // Phase 1: Quick Phrases
        // =============================================

        function showQuickPhrase(index) {
            const phrase = QUICK_PHRASES[index];
            if (!phrase) return;
            showTeleprompterOverlay(phrase.english, phrase.chinese);
        }

        // =============================================
        // Phase 1: Panic Button
        // =============================================

        function triggerPanic() {
            // Pick a random stalling phrase (avoid repeating last one)
            let idx;
            do {
                idx = Math.floor(Math.random() * STALLING_PHRASES.length);
            } while (idx === lastStallingIndex && STALLING_PHRASES.length > 1);
            lastStallingIndex = idx;

            const phrase = STALLING_PHRASES[idx];
            showTeleprompterOverlay(phrase.english, phrase.chinese, true);
        }

        // =============================================
        // Phase 1: Teleprompter Overlay
        // =============================================

        function showTeleprompterOverlay(english, chinese, showScripts) {
            const overlay = document.getElementById('teleprompterOverlay');
            document.getElementById('overlayEnglish').textContent = english;
            document.getElementById('overlayChinese').textContent = chinese || '';

            // Show/hide Chinese section
            const chineseEl = document.getElementById('overlayChinese');
            chineseEl.style.display = chinese ? '' : 'none';

            // Show prepared scripts in panic mode
            const scriptsSection = document.getElementById('overlayScripts');
            if (showScripts) {
                const scripts = getSavedScripts();
                const listEl = document.getElementById('overlayScriptsList');
                listEl.innerHTML = '';

                if (scripts.length > 0) {
                    scripts.forEach(script => {
                        const item = document.createElement('div');
                        item.className = 'teleprompter-overlay-script-item';
                        item.setAttribute('tabindex', '0');
                        item.innerHTML = `
                            <div class="teleprompter-overlay-script-item-en">${escapeHtml(script.english)}</div>
                            <div class="teleprompter-overlay-script-item-zh">${escapeHtml(script.chinese)}</div>
                        `;
                        item.onclick = () => {
                            document.getElementById('overlayEnglish').textContent = script.english;
                            document.getElementById('overlayChinese').textContent = script.chinese;
                            chineseEl.style.display = '';
                            scriptsSection.style.display = 'none';
                        };
                        listEl.appendChild(item);
                    });
                    scriptsSection.style.display = '';
                } else {
                    scriptsSection.style.display = 'none';
                }
            } else {
                scriptsSection.style.display = 'none';
            }

            overlay.classList.add('visible');
        }

        function closeTeleprompterOverlay(event) {
            // If called from click on backdrop, check target
            if (event && event.target !== document.getElementById('teleprompterOverlay')) return;
            document.getElementById('teleprompterOverlay').classList.remove('visible');
        }

        // Close overlay on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeTeleprompterOverlay();
                document.getElementById('suggestionPanel').style.display = 'none';
                closeBottomSheet();
                closeOverflowMenu();
            }
        });

        // =============================================
        // Feature C: Key Info Highlighting
        // =============================================

        /**
         * Detect and highlight key information in text.
         * Returns HTML with clickable spans for matched items.
         */
        function highlightKeyInfo(text) {
            if (!text) return text;

            // Define patterns with types (order matters — more specific first)
            const patterns = [
                // UK postcodes: SW1A 1AA, EC2R 8AH
                { regex: /\b([A-Z]{1,2}\d[A-Z\d]?\s?\d[A-Z]{2})\b/gi, type: 'postcode' },
                // Phone: 020 7123 4567, +44 20 7123 4567, 07700 900000
                { regex: /(\+44[\s-]?\d{2,4}[\s-]?\d{3,4}[\s-]?\d{3,4}|\b0\d{2,4}[\s-]?\d{3,4}[\s-]?\d{3,4})\b/g, type: 'phone' },
                // Reference numbers: REF-123456, AB1234567, ABC/12345
                { regex: /\b([A-Z]{2,4}[-\/]?\d{4,12})\b/g, type: 'ref' },
                // Currency: £500, $1,000, £12.50
                { regex: /([£$]\s?\d[\d,]*(?:\.\d{1,2})?)/g, type: 'amount' },
                // Amount with words: 500 pounds, 50p, 100 pence
                { regex: /\b(\d[\d,]*(?:\.\d{1,2})?\s?(?:pounds?|pence|p))\b/gi, type: 'amount' },
                // Dates: 15th March 2024, 1 Jan 2025, 03/02/2024
                { regex: /\b(\d{1,2}(?:st|nd|rd|th)?\s+(?:Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+\d{2,4})\b/gi, type: 'date' },
                { regex: /\b(\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4})\b/g, type: 'date' },
                // Times: 2:30pm, 14:00, 9:15 AM
                { regex: /\b(\d{1,2}:\d{2}\s?(?:am|pm|AM|PM)?)\b/g, type: 'time' },
            ];

            // Collect all matches with their positions
            const matches = [];
            for (const { regex, type } of patterns) {
                let m;
                // Reset lastIndex for global regex
                regex.lastIndex = 0;
                while ((m = regex.exec(text)) !== null) {
                    matches.push({
                        start: m.index,
                        end: m.index + m[0].length,
                        value: m[1] || m[0],
                        fullMatch: m[0],
                        type
                    });
                }
            }

            if (matches.length === 0) return escapeHtml(text);

            // Sort by position, remove overlaps (keep first match)
            matches.sort((a, b) => a.start - b.start);
            const filtered = [];
            let lastEnd = 0;
            for (const m of matches) {
                if (m.start >= lastEnd) {
                    filtered.push(m);
                    lastEnd = m.end;
                }
            }

            // Build HTML
            let result = '';
            let pos = 0;
            for (const m of filtered) {
                if (m.start > pos) {
                    result += escapeHtml(text.slice(pos, m.start));
                }
                const cleanValue = m.value.trim();
                result += `<span class="key-info key-info-${m.type}" data-value="${escapeHtml(cleanValue)}" onclick="copyKeyInfo(this)" title="點擊複製">${escapeHtml(m.fullMatch)}</span>`;
                pos = m.end;
            }
            if (pos < text.length) {
                result += escapeHtml(text.slice(pos));
            }

            return result;
        }

        /**
         * Copy key info value to clipboard and show toast.
         */
        function copyKeyInfo(el) {
            const value = el.dataset.value;
            if (!value) return;

            navigator.clipboard.writeText(value).then(() => {
                const toast = document.getElementById('copyToast');
                toast.textContent = `已複製: ${value}`;
                toast.classList.add('visible');
                setTimeout(() => toast.classList.remove('visible'), 1500);
            }).catch(() => {
                // Fallback for older browsers
                const ta = document.createElement('textarea');
                ta.value = value;
                ta.style.position = 'fixed';
                ta.style.opacity = '0';
                document.body.appendChild(ta);
                ta.select();
                document.execCommand('copy');
                document.body.removeChild(ta);
                const toast = document.getElementById('copyToast');
                toast.textContent = `已複製: ${value}`;
                toast.classList.add('visible');
                setTimeout(() => toast.classList.remove('visible'), 1500);
            });
        }

        // =============================================
        // Feature A: Smart Suggestions
        // =============================================

        let suggestAbortController = null;

        function requestSuggestions() {
            const btn = document.getElementById('suggestBtn');
            const btnM = document.getElementById('suggestBtnMobile');
            const panel = document.getElementById('suggestionPanel');

            // If panel is visible, toggle it off
            if (panel.style.display !== 'none') {
                panel.style.display = 'none';
                return;
            }

            // Collect recent segments from DOM
            const segmentEls = document.querySelectorAll('.segment-item');
            if (segmentEls.length === 0) return;

            const turns = [];
            // Segments are newest-first in DOM, so reverse for chronological order
            const els = Array.from(segmentEls).reverse().slice(-5);
            for (const el of els) {
                // Extract speaker from the label
                const labelEl = el.querySelector('span[style*="font-weight"]');
                const label = labelEl ? labelEl.textContent.trim() : '';
                const role = label.includes('我') ? 'me' : 'them';

                // Extract English and Chinese text
                const divs = el.querySelectorAll('div[style*="font-size"]');
                let englishText = '';
                if (divs.length >= 1) {
                    englishText = divs[0].textContent.trim();
                }
                if (englishText && englishText !== '翻譯中...') {
                    turns.push({ role, text: englishText });
                }
            }

            if (turns.length === 0) return;

            // Get current scenario
            const scenarioEl = document.querySelector('.scenario-card.selected');
            const scenario = scenarioEl ? scenarioEl.dataset.scenario : 'general';

            // Show loading state (desktop + mobile)
            if (btn) { btn.classList.add('loading'); btn.disabled = true; }
            if (btnM) { btnM.classList.add('loading'); btnM.disabled = true; }
            panel.innerHTML = '<div style="color:var(--text-secondary);font-size:13px;padding:8px;">思考中...</div>';
            panel.style.display = 'flex';

            // Abort previous request
            if (suggestAbortController) suggestAbortController.abort();
            suggestAbortController = new AbortController();

            // Get API key (required)
            const apiKey = getApiKey();
            if (!apiKey) {
                panel.innerHTML = '<div style="color:var(--accent-red);font-size:13px;padding:8px;">' + t('apiKeyRequired') + '</div>';
                if (btn) { btn.classList.remove('loading'); btn.disabled = false; }
                if (btnM) { btnM.classList.remove('loading'); btnM.disabled = false; }
                return;
            }

            const headers = { 'Content-Type': 'application/json', 'X-API-Key': apiKey };

            // SSE streaming — show each suggestion as it arrives (~1s for first)
            fetch('/api/suggest/stream', {
                method: 'POST',
                headers,
                body: JSON.stringify({ conversation_turns: turns, scenario }),
                signal: suggestAbortController.signal,
            }).then(response => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let firstSuggestion = true;

                function setSuggestDone() {
                    if (btn) { btn.classList.remove('loading'); btn.disabled = false; }
                    if (btnM) { btnM.classList.remove('loading'); btnM.disabled = false; }
                }

                function processStream() {
                    return reader.read().then(({ done, value }) => {
                        if (done) { setSuggestDone(); return; }
                        buffer += decoder.decode(value, { stream: true });
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || '';

                        for (const line of lines) {
                            if (!line.startsWith('data: ')) continue;
                            try {
                                const evt = JSON.parse(line.slice(6));
                                if (evt.type === 'suggestion') {
                                    if (firstSuggestion) {
                                        panel.innerHTML = '';
                                        firstSuggestion = false;
                                    }
                                    appendSuggestionCard(panel, evt);
                                } else if (evt.type === 'done') {
                                    setSuggestDone();
                                } else if (evt.type === 'error') {
                                    panel.innerHTML = `<div style="color:var(--accent-red);font-size:13px;padding:8px;">${escapeHtml(evt.error)}</div>`;
                                    setSuggestDone();
                                }
                            } catch (e) {}
                        }
                        return processStream();
                    });
                }
                return processStream();
            }).catch(err => {
                if (err.name === 'AbortError') return;
                panel.innerHTML = '<div style="color:var(--accent-red);font-size:13px;padding:8px;">建議生成失敗</div>';
                if (btn) { btn.classList.remove('loading'); btn.disabled = false; }
                if (btnM) { btnM.classList.remove('loading'); btnM.disabled = false; }
            });
        }

        function appendSuggestionCard(panel, s) {
            const card = document.createElement('div');
            card.className = 'suggestion-card';
            card.innerHTML = `
                <div class="suggestion-card-en">${escapeHtml(s.english)}</div>
                <div class="suggestion-card-zh">${escapeHtml(s.chinese)}</div>
                <div class="suggestion-card-use">用這個 →</div>
            `;
            card.onclick = () => {
                showTeleprompterOverlay(s.english, s.chinese);
                panel.style.display = 'none';
            };
            panel.appendChild(card);
        }

        // =============================================
        // Phase 1: Start Listening (from preparation mode)
        // =============================================

        function startListening() {
            // This bridges preparation → call mode via the existing startTest()
            startTest();
        }

        // =============================================
        // Script Generator Functions (design.md § 5)
        // =============================================

        let currentScript = '';
        let currentAlternatives = [];
        let isGenerating = false;

        /**
         * Handle Enter key in script input
         */
        function handleScriptInputKeydown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                generateScript();
            }
        }

        /**
         * Generate English script from Chinese input
         * Uses streaming API for faster perceived response
         * If input is empty, uses scenario-appropriate default prompt
         */
        async function generateScript() {
            if (isGenerating) return;

            const input = document.getElementById('scriptInput').value.trim();
            // Empty input is OK - backend will use scenario default

            isGenerating = true;
            const btn = document.getElementById('btnGenerate');
            btn.disabled = true;
            btn.innerHTML = `
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="animate-spin">
                    <path d="M21 12a9 9 0 1 1-6.219-8.56"></path>
                </svg>
                生成中...
            `;

            // Show teleprompter
            const teleprompter = document.getElementById('teleprompter');
            const scriptOutput = document.getElementById('scriptOutput');
            const alternativesSection = document.getElementById('alternativesSection');
            const alternativesList = document.getElementById('alternativesList');

            teleprompter.classList.add('visible');
            scriptOutput.innerHTML = '<span class="streaming-cursor"></span>';
            alternativesSection.style.display = 'none';

            currentScript = '';
            currentAlternatives = [];

            try {
                const apiKey = getApiKey();
                if (!apiKey) {
                    throw new Error('API Key not configured. Please set your OpenAI API Key in Settings.');
                }

                const response = await fetch('/api/script/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey
                    },
                    body: JSON.stringify({
                        chinese_input: input,
                        context: {
                            scenario: selectedScenario,
                            tone: 'polite'
                        }
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value);
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));

                                if (data.type === 'using_default') {
                                    // Backend is using a default prompt - show it in input
                                    const scriptInputEl = document.getElementById('scriptInput');
                                    if (scriptInputEl && data.prompt) {
                                        scriptInputEl.value = data.prompt;
                                        log(`[講稿] 使用預設：${data.prompt}`, 'info');
                                    }
                                } else if (data.type === 'script_delta') {
                                    currentScript += data.text;
                                    scriptOutput.innerHTML = currentScript + '<span class="streaming-cursor"></span>';
                                } else if (data.type === 'script_done') {
                                    currentScript = data.text;
                                    scriptOutput.textContent = currentScript;
                                } else if (data.type === 'alternatives') {
                                    currentAlternatives = data.alternatives || [];
                                    if (currentAlternatives.length > 0) {
                                        alternativesSection.style.display = 'block';
                                        alternativesList.innerHTML = currentAlternatives
                                            .map(alt => `<div class="alternative-item" onclick="useAlternative('${escapeHtmlForAttr(alt)}')">${alt}</div>`)
                                            .join('');
                                    }
                                } else if (data.type === 'error') {
                                    scriptOutput.innerHTML = `<span style="color:var(--accent-red);">生成失敗：${data.error}</span>`;
                                }
                            } catch (e) {
                                // Ignore parse errors for incomplete JSON
                            }
                        }
                    }
                }

                log(`[講稿] 生成完成: "${currentScript.substring(0, 50)}..."`, 'success');

            } catch (error) {
                console.error('Script generation error:', error);
                scriptOutput.innerHTML = `<span style="color:var(--accent-red);">生成失敗：${error.message}</span>`;
                log(`[講稿] 錯誤: ${error.message}`, 'error');
            } finally {
                isGenerating = false;
                btn.disabled = false;
                btn.innerHTML = `
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="m5 12 7-7 7 7"></path>
                        <path d="M12 19V5"></path>
                    </svg>
                    生成講稿
                `;
            }
        }

        /**
         * Copy current script to clipboard
         */
        async function copyScript() {
            if (!currentScript) return;

            try {
                await navigator.clipboard.writeText(currentScript);
                // Show brief feedback
                const btn = event.target.closest('.teleprompter-action-btn');
                const originalText = btn.innerHTML;
                btn.innerHTML = `
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>
                    已複製
                `;
                setTimeout(() => { btn.innerHTML = originalText; }, 1500);
            } catch (error) {
                console.error('Copy failed:', error);
            }
        }

        /**
         * Regenerate script with same input
         */
        function regenerateScript() {
            generateScript();
        }

        /**
         * Use an alternative script
         */
        function useAlternative(text) {
            currentScript = text;
            document.getElementById('scriptOutput').textContent = text;
        }

        /**
         * Escape HTML for safe insertion
         */
        /**
         * Escape HTML for safe display (不處理單引號)
         */
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Escape HTML for use in onclick attributes (處理單引號)
         */
        function escapeHtmlForAttr(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML.replace(/'/g, "\\'");
        }

        // DOM Elements
        const statusBadge = document.getElementById('statusBadge');
        const statusText = document.getElementById('statusText');
        const transcriptContent = document.getElementById('transcriptContent');
        const transcriptEmpty = document.getElementById('transcriptEmpty');
        const logPanel = document.getElementById('logPanel');

        // Stats (these are now in hidden div or call header)
        const segmentCountEl = document.getElementById('segmentCount');
        const activeCountEl = document.getElementById('activeCount');
        const doneCountEl = document.getElementById('doneCount');
        const queueCountEl = document.getElementById('queueCount');

        // ============================================
        // Logging
        // ============================================

        function log(msg, level = 'info') {
            const time = new Date().toLocaleTimeString('zh-TW');
            console.log(`[${level}] ${msg}`);
            // Log panel is hidden but still exists for debugging
            if (logPanel) {
                const entry = document.createElement('div');
                entry.className = `log-entry ${level}`;
                entry.textContent = `[${time}] ${msg}`;
                logPanel.appendChild(entry);
                logPanel.scrollTop = logPanel.scrollHeight;
            }
        }

        // ============================================
        // Status Updates
        // ============================================

        function updateStatus(status, text) {
            statusBadge.className = `status-badge ${status}`;
            statusText.textContent = text;
        }

        /**
         * 閃爍提示用戶可以開始說話
         */
        function flashReadyIndicator() {
            // 閃爍狀態指示器
            statusBadge.style.animation = 'flash-ready 0.5s ease-in-out 3';
            setTimeout(() => {
                statusBadge.style.animation = '';
            }, 1500);

            // 更新英文原文區域提示 - 使用 Karaoke 高亮效果
            const previewText = document.getElementById('previewText');
            if (previewText) {
                previewText.innerHTML = '<span class="preview-text-inner"><span class="interim">Ready! Start speaking...</span></span>';
            }
        }

        function updateStats() {
            if (!eventHandler) return;
            const store = eventHandler.getStore();

            const all = store.getAll();
            const active = store.getActiveSegments();
            const done = all.filter(s => s.status === 'done');
            const queue = store.pendingForResponse?.length || 0;

            segmentCountEl.textContent = all.length;
            activeCountEl.textContent = active.length;
            doneCountEl.textContent = done.length;
            queueCountEl.textContent = queue;
        }

        // ============================================
        // Initialize Modules
        // ============================================

        function initModules() {
            // Check if modules are loaded
            if (typeof EnhancedSegmentStore === 'undefined') {
                log('ERROR: segment_store.js not loaded!', 'error');
                return false;
            }
            if (typeof RealtimeEventHandler === 'undefined') {
                log('ERROR: realtime_event_handler.js not loaded!', 'error');
                return false;
            }
            if (typeof SegmentRenderer === 'undefined') {
                log('ERROR: segment_renderer.js not loaded!', 'error');
                return false;
            }

            // Initialize event handler (creates EnhancedSegmentStore internally)
            eventHandler = new RealtimeEventHandler();

            // Initialize renderer
            renderer = new SegmentRenderer(transcriptContent);

            // Inject styles
            if (typeof injectSegmentRendererStyles === 'function') {
                injectSegmentRendererStyles();
            }

            // Connect event handler to renderer
            // ⚠️ 方案 A 架構：UI 渲染由 SmartSegmenter 的 translateViaBackend() 控制
            // RealtimeEventHandler 只記錄日誌，不渲染 UI segments
            // 這避免了「孤兒 segment」問題（OpenAI 轉錄創建的 segment 沒有翻譯）
            eventHandler.onSegmentUpdate = (segment) => {
                // 不渲染 OpenAI 的 segments，只記錄
                // renderer.queueUpdate(segment);
                // updateStats();
            };

            // Connect logging
            eventHandler.onLog = (msg, level) => {
                log(msg, level);
            };

            // Error handling
            eventHandler.onError = (error) => {
                log(`API Error: ${error.message || error.code}`, 'error');
            };

            // Initialize Smart Segmenter with current preset
            if (typeof SmartSegmenter !== 'undefined') {
                const preset = SEGMENTER_PRESETS[currentPreset];

                // Use AdaptiveSegmenter for dynamic WPM adjustment
                smartSegmenter = new AdaptiveSegmenter({
                    pauseThreshold: preset.pauseThreshold,
                    stabilityDelay: preset.stabilityDelay,
                    softLimit: preset.softLimit,
                    hardLimit: preset.hardLimit,
                    minSegmentWords: preset.minSegmentWords
                });

                // When segment detected, translate via backend API (方案 A)
                smartSegmenter.onSegment = (segment, info) => {
                    const speaker = currentSpeaker;  // 捕獲當前說話者
                    log(`SmartSegmenter: "${segment.substring(0, 40)}..." (${info.wordCount}w, ${info.reason}, speaker: ${speaker})`, 'event');

                    // 🔧 方案 A: 兩階段架構 + 角色標記
                    // 不再使用 OpenAI Realtime API 翻譯（會變成 Q&A 對話）
                    // 改用 gpt-4.1-nano 文字 API 翻譯，並傳入說話者標記
                    translateViaBackend(segment, speaker);
                };

                log(`SmartSegmenter initialized (preset: ${preset.name}, 暫停:${preset.pauseThreshold}ms)`, 'success');
            } else {
                log('smart_segmenter.js not loaded - using OpenAI default (2-3s)', 'warn');
            }

            // Initialize Web Speech for real-time English subtitles
            if (typeof WebSpeechRealtime !== 'undefined') {
                webSpeech = new WebSpeechRealtime();

                if (webSpeech.isSupported()) {
                    // 實時英文回調 - 邊說邊顯示 + 智能分段
                    // 🔧 角色標記模式：不論誰在說話都處理，speaker 標記在 translateViaBackend 中設定
                    webSpeech.onInterimResult = (fullText, interim) => {
                        currentRealtimeEnglish = fullText;
                        updateRealtimePreview(fullText, interim);

                        // Feed to SmartSegmenter
                        if (smartSegmenter) {
                            smartSegmenter.process(fullText, false);
                        }
                    };

                    // Web Speech final result
                    // 注意：不需要在這裡再次調用 SmartSegmenter.process()
                    // 因為 onInterimResult 已經包含了最終文字，而且 SmartSegmenter
                    // 有自己的停頓偵測機制（600ms）來決定何時分段。
                    // Web Speech 的 "final" 只表示「確認這段文字」，不是「用戶停止說話」。
                    webSpeech.onFinalResult = (finalText) => {
                        // 僅記錄，不調用 SmartSegmenter
                        // SmartSegmenter 已從 onInterimResult 獲得累積文字
                        console.log('[WebSpeech] Final result received:', finalText.substring(0, 40));
                    };

                    webSpeech.onError = (error, message) => {
                        log(`WebSpeech error: ${error}`, 'warn');
                    };

                    // 音訊開始收錄 - 這時用戶可以開始說話
                    webSpeech.onAudioStart = () => {
                        log('Audio capture ready - you can speak now!', 'success');
                        updateStatus('connected', '翻譯中');
                        // 🔧 修復：只在非 PTT 模式時才重設為「對方說話」
                        // PTT 模式下 indicator 已經由 pttStart/pttEnd 控制
                        if (!isPTTActive) {
                            updateSpeakerIndicator('them');
                        }
                        // 閃爍提示用戶可以開始說話
                        flashReadyIndicator();
                    };

                    log('WebSpeech initialized for real-time English subtitles', 'success');
                } else {
                    log('WebSpeech not supported in this browser', 'warn');
                }
            } else {
                log('webspeech_realtime.js not loaded', 'warn');
            }

            log('Modules initialized: EnhancedSegmentStore, RealtimeEventHandler, SegmentRenderer', 'success');
            return true;
        }

        // 更新實時英文預覽（Karaoke 風格）
        function updateRealtimePreview(fullText, interim) {
            let previewEl = document.getElementById('realtimePreview');
            const container = document.getElementById('realtimePreviewContainer');

            if (!previewEl && container) {
                // 創建實時預覽區域（預設收合，單行顯示最後文字）
                previewEl = document.createElement('div');
                previewEl.id = 'realtimePreview';
                previewEl.className = 'realtime-preview';
                previewEl.innerHTML = `
                    <div class="preview-label preview-toggle" onclick="toggleRealtimePreview()">
                        <span class="toggle-icon">▼</span>
                        <span>英文原文</span>
                    </div>
                    <div class="preview-text" id="previewText"><span class="preview-text-inner">等待語音...</span></div>
                `;
                container.appendChild(previewEl);
            }

            if (!previewEl) return;

            // 移除 stopped 狀態（如果有）
            previewEl.classList.remove('stopped');

            const textEl = document.getElementById('previewText');
            if (textEl) {
                const displayText = fullText || '等待語音...';

                // Karaoke 效果：已確認文字較暗，正在說的文字高亮發光
                if (interim) {
                    const finalPart = fullText.slice(0, fullText.length - interim.length);
                    textEl.innerHTML = '<span class="preview-text-inner">' +
                        '<span class="final-text">' + escapeHtml(finalPart) + '</span>' +
                        '<span class="interim">' + escapeHtml(interim) + '</span>' +
                        '</span>';
                } else {
                    // 沒有 interim 時，全部顯示為已確認
                    textEl.innerHTML = '<span class="preview-text-inner">' +
                        '<span class="final-text">' + escapeHtml(displayText) + '</span>' +
                        '</span>';
                }

                // 展開狀態時，自動捲動到最新內容
                if (previewEl.classList.contains('expanded')) {
                    textEl.scrollTop = textEl.scrollHeight;
                }
            }
        }

        // Toggle 實時預覽的展開/收合
        function toggleRealtimePreview() {
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.classList.toggle('expanded');

                // 展開時自動捲動到最新內容
                if (previewEl.classList.contains('expanded')) {
                    const textEl = document.getElementById('previewText');
                    if (textEl) {
                        // 使用 setTimeout 確保 DOM 更新後再捲動
                        setTimeout(() => {
                            textEl.scrollTop = textEl.scrollHeight;
                        }, 50);
                    }
                }
            }
        }

        // ============================================
        // Start Test
        // ============================================

        async function startTest() {
            // Initialize modules if not done
            if (!eventHandler) {
                if (!initModules()) {
                    return;
                }
            }

            // Check AudioCapture
            if (!audioCapture) {
                log('ERROR: AudioCapture not loaded!', 'error');
                return;
            }

            // ====== 問題 4 修復：清理舊數據 ======
            // Clear previous segment data
            if (eventHandler && eventHandler.getStore()) {
                eventHandler.getStore().reset();
                log('Cleared previous segment data', 'info');
            }
            currentRealtimeEnglish = '';

            // Reset SmartSegmenter state
            if (smartSegmenter) {
                smartSegmenter.reset();
            }

            // Clear UI: remove old segment items
            const oldSegmentItems = document.querySelectorAll('.segment-item');
            oldSegmentItems.forEach(el => el.remove());

            // Remove old realtime preview if exists
            const oldPreview = document.getElementById('realtimePreview');
            if (oldPreview) {
                oldPreview.remove();
            }

            // Reset pause state
            isPaused = false;
            document.getElementById('btnPause').style.display = '';
            document.getElementById('btnResume').style.display = 'none';

            // Reset stats
            updateStats();
            // ====== 問題 4 修復結束 ======

            try {
                updateStatus('connecting', '連線中...');
                document.getElementById('btnStartListening').disabled = true;

                // Step 1: Capture microphone
                log('Requesting microphone access...');
                const audioStream = await audioCapture.captureMicrophone();
                log('Microphone access granted', 'success');

                // Step 1.5: Start Web Speech IMMEDIATELY after mic access
                // This prevents missing the first few words while waiting for token/WebRTC
                if (webSpeech && webSpeech.isSupported()) {
                    // 🔧 使用「對方口音」設定啟動
                    webSpeech.setLanguage(accentThem, false);  // false = 不重啟（還沒開始）
                    webSpeech.start();
                    log(`WebSpeech started early (${accentThem})`, 'success');
                }

                // Start Smart Segmenter early too
                if (smartSegmenter) {
                    smartSegmenter.start();
                    log('SmartSegmenter started early', 'success');
                }

                // Step 2: Try to get ephemeral token for WebRTC (optional)
                // WebRTC is optional - the app works with Web Speech + Translation API alone
                let webrtcConnected = false;
                const userApiKey = getApiKey();

                if (userApiKey) {
                    try {
                        log('Getting ephemeral token...');
                        const tokenHeaders = {
                            'Content-Type': 'application/json',
                            'X-API-Key': userApiKey
                        };
                        const tokenResponse = await fetch('/api/token', {
                            method: 'POST',
                            headers: tokenHeaders,
                            body: JSON.stringify({ voice: 'marin' })
                        });

                        if (tokenResponse.ok) {
                            const tokenData = await tokenResponse.json();
                            log('Token received', 'success');

                            // Step 3: Setup WebRTC (optional)
                            await setupWebRTC(audioStream, tokenData.client_secret);
                            webrtcConnected = true;
                            log('WebRTC connected', 'success');
                        } else {
                            log('Token request failed, continuing without WebRTC', 'warn');
                        }
                    } catch (webrtcError) {
                        log(`WebRTC setup failed: ${webrtcError.message}, continuing without it`, 'warn');
                    }
                } else {
                    log('No API Key set, skipping WebRTC', 'warn');
                }

                // UI updates: switch to call mode (regardless of WebRTC status)
                // Core functionality (Web Speech + Translation API) works without WebRTC
                isConnected = true;
                console.log('[startTest] isConnected set to true');
                transcriptEmpty.style.display = 'flex';
                switchToCallMode();
                console.log('[startTest] switchToCallMode completed');

                if (!webrtcConnected) {
                    log('Running in Web Speech + Translation API mode', 'info');
                }

            } catch (error) {
                log(`Start failed: ${error.message}`, 'error');
                resetUI();
                document.getElementById('btnStartListening').disabled = false;
            }
        }

        async function setupWebRTC(audioStream, clientSecret) {
            const rtcConfig = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(rtcConfig);

            // Add audio track
            const audioTrack = audioStream.getAudioTracks()[0];
            peerConnection.addTrack(audioTrack, audioStream);
            log('Audio track added');

            // Handle remote audio (not needed for translation, but required by API)
            peerConnection.ontrack = (event) => {
                log('Remote track received', 'event');
            };

            // Create data channel
            dataChannel = peerConnection.createDataChannel('oai-events');
            setupDataChannel();

            // ICE state handling
            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE state: ${peerConnection.iceConnectionState}`, 'event');
                if (peerConnection.iceConnectionState === 'connected') {
                    // 連線成功，但還要等 Web Speech 準備好才能開始說話
                    updateStatus('connecting', '準備中...');
                } else if (peerConnection.iceConnectionState === 'failed') {
                    stopTest();
                }
            };

            // Create and send offer
            await peerConnection.setLocalDescription();
            log('SDP offer created');

            const sdpResponse = await fetch('https://api.openai.com/v1/realtime/calls', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${clientSecret}`,
                    'Content-Type': 'application/sdp'
                },
                body: peerConnection.localDescription.sdp
            });

            if (!sdpResponse.ok) {
                throw new Error(`SDP exchange failed: ${sdpResponse.status}`);
            }

            const answerSdp = await sdpResponse.text();
            await peerConnection.setRemoteDescription({
                type: 'answer',
                sdp: answerSdp
            });

            log('WebRTC connected', 'success');
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                log('Data channel opened', 'success');
                sendSessionUpdate();
            };

            dataChannel.onclose = () => {
                log('Data channel closed', 'warn');
            };

            dataChannel.onerror = (error) => {
                log(`Data channel error: ${error}`, 'error');
            };

            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                // Route to new event handler
                eventHandler.handle(data);
            };
        }

        function sendSessionUpdate() {
            // Translation mode session configuration
            // Uses GA API format (2025)
            //
            // 🔧 Smart Segmentation Strategy (2026-02-02):
            // - create_response: false → 禁用 OpenAI 的自動分段（2-3s 延遲）
            // - 前端 SmartSegmenter 控制分段（600ms 閾值）
            // - 見 spec/research/speech_segmentation.md
            //
            // 🔧 Fix Test 21 Issues (2026-02-02):
            // - 2.2a 簡體→繁體：明確指定 "Traditional Chinese (Hong Kong)" + 負面範例
            // - 2.2b Q&A→翻譯：採用 Twilio 風格 prompt "translation machine"
            // - Reference: https://github.com/twilio-samples/live-translation-openai-realtime-api
            const sessionConfig = {
                type: 'session.update',
                session: {
                    type: 'realtime',
                    // 🔧 Twilio-style translation prompt (Test 21 fix)
                    // Key elements:
                    // 1. "translation machine" identity - prevents dialogue mode
                    // 2. Explicit "Traditional Chinese (Hong Kong)" - prevents simplified Chinese
                    // 3. Negative examples - prevents common errors
                    instructions: `You are a translation machine. Your sole function is to translate English audio to Traditional Chinese (Hong Kong style, 繁體中文).

CRITICAL RULES:
- Do NOT respond to the audio content. Do NOT have a dialogue.
- Do NOT say "我明白", "好的", "請問", or any conversational phrases.
- Output ONLY the Chinese translation, nothing else.
- Use Traditional Chinese characters (繁體字), NOT Simplified Chinese (简体字).
  ✓ Correct: 說話、學習、電話、經濟
  ✗ Wrong: 说话、学习、电话、经济

FORMAT:
- Proper nouns: HK-style with English in brackets, e.g., "曼德爾森 (Peter Mandelson)"
- Numbers: Keep as digits, e.g., "$75,000", "2019年"
- Output: Pure translation text only`,
                    output_modalities: ['text'],
                    audio: {
                        input: {
                            format: { type: 'audio/pcm', rate: 24000 },
                            transcription: {
                                model: 'gpt-4o-mini-transcribe',
                                language: 'en'  // 🔧 強制英文轉錄，避免誤識別為其他語言
                            },
                            turn_detection: {
                                type: 'semantic_vad',
                                eagerness: 'high',
                                // 🔧 Disable auto response - SmartSegmenter controls segmentation
                                create_response: false,
                                interrupt_response: false
                            }
                        }
                    }
                }
            };

            sendEvent(sessionConfig);
            log('Session configured: Twilio-style translation prompt + SmartSegmenter (600ms)');

            // ⚠️ 移除 few-shot priming - 經測試發現會讓模型進入對話模式
            // 原因：TEXT 範例與 AUDIO 輸入不同，模型會認為在對話
            // 改用更強的 session instructions + response.create instructions
        }

        function sendEvent(event) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(event));
            }
        }

        /**
         * Force translation by sending response.create event
         * This bypasses OpenAI's 2-3s semantic_vad delay
         *
         * See: src/skills/openai-realtime-mini-voice/SKILL.md
         *
         * 🐛 Bug fix (2026-02-02):
         * - response.create 格式應該是 { conversation: "auto" }，不是 { modalities: ["text"] }
         * - 添加防抖機制，避免頻繁觸發
         * - 添加最小間隔檢查
         */
        let lastForceTranslationTime = 0;
        const MIN_TRANSLATION_INTERVAL = 500;  // 最少 500ms 間隔

        function forceTranslation() {
            if (!dataChannel || dataChannel.readyState !== 'open') {
                log('Cannot force translation: data channel not open', 'warn');
                return;
            }

            // 防抖：確保最少 500ms 間隔
            const now = Date.now();
            if (now - lastForceTranslationTime < MIN_TRANSLATION_INTERVAL) {
                // 太頻繁，跳過
                return;
            }
            lastForceTranslationTime = now;

            // Commit current audio buffer and create response
            // This tells OpenAI: "I've finished speaking this segment, process it now"
            const commitEvent = {
                type: 'input_audio_buffer.commit'
            };
            sendEvent(commitEvent);

            // Create response (translation)
            // 🔧 Test 21 fix: 強化翻譯行為
            // 1. 明確指定繁體中文
            // 2. 禁止對話模式
            const responseEvent = {
                type: 'response.create',
                response: {
                    conversation: 'auto',
                    // 🔧 Twilio-style: 強化翻譯指令
                    instructions: 'Translate to Traditional Chinese (繁體中文). Output ONLY the translation. No dialogue, no "我明白", no "好的", no questions. Use Traditional characters (說話 not 说话).'
                }
            };
            sendEvent(responseEvent);

            log('Force translation triggered (Traditional Chinese)', 'event');
        }

        // ============================================
        // 方案 A: 串流翻譯 API (gpt-4.1-nano + SSE)
        // 首字回應約 0.3 秒
        // ============================================

        let segmentCounter = 0;

        /**
         * 透過串流 API 翻譯英文段落
         * 方案 A: 兩階段架構 + 串流回應
         * - Web Speech API → 英文 STT
         * - gpt-4.1-nano → 文字翻譯（串流）
         *
         * 優點：首字回應約 0.3 秒，用戶可以邊看邊讀
         */
        async function translateViaBackend(englishText, speaker = 'them') {
            if (!englishText || englishText.trim().length === 0) {
                return;
            }

            // 創建 segment 用於 UI 顯示（包含說話者標記）
            const segmentId = `seg-${++segmentCounter}`;
            const segment = {
                id: segmentId,
                englishText: englishText.trim(),
                chineseTranslation: '',
                status: 'translating',
                speaker: speaker,  // 'them' 或 'me'
                createdAt: Date.now(),
                completedAt: null,
                error: null
            };

            // 立即顯示英文（狀態：翻譯中）
            renderSegment(segment);
            updateStats();

            const startTime = Date.now();
            log(`[串流] 開始翻譯: "${englishText.substring(0, 30)}..."`, 'event');

            // 檢查 API Key
            const apiKey = getApiKey();
            if (!apiKey) {
                log('[翻譯] 未設定 API Key，請在設定頁輸入', 'error');
                segment.status = 'error';
                segment.chineseTranslation = t('apiKeyRequired');
                renderSegment(segment);
                return;
            }
            log(`[翻譯] 使用 API Key: ${apiKey.substring(0, 8)}...`, 'info');

            try {
                // 使用串流 API（帶場景詞庫支援 + 用戶 API Key）
                const response = await fetch('/api/translate/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': apiKey  // 用戶提供的 API Key
                    },
                    body: JSON.stringify({
                        text: englishText.trim(),
                        scenario: selectedScenario  // 傳遞場景以啟用詞庫
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    log(`[翻譯] API 錯誤: ${response.status} - ${errorText}`, 'error');
                    throw new Error(`API error: ${response.status} - ${errorText}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let firstChunkTime = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        log(`[串流] Stream ended, translation so far: "${segment.chineseTranslation}"`, 'info');
                        break;
                    }

                    const text = decoder.decode(value, { stream: true });
                    log(`[串流] Raw chunk: ${text.substring(0, 100)}...`, 'debug');
                    const lines = text.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            let data;
                            try {
                                data = JSON.parse(line.slice(6));
                            } catch (parseErr) {
                                // JSON parse error, skip this line
                                continue;
                            }

                            log(`[串流] Parsed data: ${JSON.stringify(data)}`, 'debug');

                            // 🐛 修復：API 錯誤要正確處理，不是靜默忽略
                            if (data.error) {
                                log(`[串流] API 返回錯誤: ${data.error}`, 'error');
                                segment.status = 'error';
                                segment.error = data.error;
                                segment.chineseTranslation = `[翻譯失敗] ${data.error}`;
                                renderSegment(segment);
                                updateStats();
                                return;  // 終止翻譯
                            }

                            if (data.text) {
                                // 記錄首字時間
                                if (!firstChunkTime) {
                                    firstChunkTime = Date.now() - startTime;
                                    log(`[串流] 首字回應: ${firstChunkTime}ms`, 'success');
                                }

                                // 累加翻譯文字
                                segment.chineseTranslation += data.text;
                                // 即時更新 UI
                                renderSegment(segment);
                            }

                            if (data.done) {
                                // 完成
                                segment.status = 'done';
                                segment.completedAt = Date.now();

                                // 驗證翻譯品質
                                if (window.TranslationValidator) {
                                    const validator = new TranslationValidator();
                                    segment.validation = validator.validate(
                                        segment.englishText,
                                        segment.chineseTranslation,
                                        selectedScenario
                                    );
                                    if (segment.validation.showWarning) {
                                        log(`[驗證] 警告: ${segment.validation.warnings.map(w => w.message).join(', ')}`, 'warning');
                                    }
                                }

                                renderSegment(segment);
                                updateStats();

                                const totalTime = Date.now() - startTime;
                                log(`[串流] 完成: ${totalTime}ms, "${segment.chineseTranslation.substring(0, 30)}..."`, 'success');
                            }
                        }
                    }
                }

                // 確保標記為完成（只有成功時才標記，錯誤情況已在上面處理）
                if (segment.status === 'translating') {
                    segment.status = 'done';
                    segment.completedAt = Date.now();
                    renderSegment(segment);
                    updateStats();
                }

            } catch (error) {
                // 錯誤處理
                segment.status = 'error';
                segment.error = error.message;
                segment.chineseTranslation = `[翻譯失敗] ${error.message}`;

                renderSegment(segment);
                updateStats();

                log(`[串流] 翻譯錯誤: ${error.message}`, 'error');
            }
        }

        /**
         * 渲染單個 segment 到 UI
         * 簡化版：直接操作 DOM，不依賴 SegmentRenderer
         * 支援說話者標記（speaker: 'them' | 'me'）
         */
        function renderSegment(segment) {
            // 隱藏空狀態
            transcriptEmpty.style.display = 'none';

            // Enable suggest buttons (desktop + mobile) when segments exist
            const suggestBtn = document.getElementById('suggestBtn');
            if (suggestBtn && !suggestBtn.classList.contains('loading')) {
                suggestBtn.disabled = false;
            }
            const suggestBtnM = document.getElementById('suggestBtnMobile');
            if (suggestBtnM && !suggestBtnM.classList.contains('loading')) {
                suggestBtnM.disabled = false;
            }

            let segmentEl = document.getElementById(segment.id);

            // 說話者樣式
            const isMe = segment.speaker === 'me';
            const speakerLabel = isMe ? '🙋 我' : '👤 對方';
            const speakerColor = isMe ? 'var(--accent-blue)' : 'var(--accent-green)';
            const borderColor = isMe ? 'var(--accent-blue)' : 'var(--accent-green)';
            const bgTint = isMe ? 'rgba(0, 212, 255, 0.08)' : 'rgba(0, 255, 136, 0.08)';

            if (!segmentEl) {
                // 創建新的 segment 元素
                segmentEl = document.createElement('div');
                segmentEl.id = segment.id;
                segmentEl.className = 'segment-item';
                transcriptContent.insertBefore(segmentEl, transcriptContent.firstChild);
            }

            // 應用說話者樣式
            segmentEl.style.cssText = `
                background: ${bgTint};
                border-radius: 8px;
                padding: 12px 16px;
                margin-bottom: 12px;
                border-left: 3px solid ${borderColor};
            `;

            // 狀態顏色
            const statusColors = {
                'translating': 'var(--accent-yellow)',
                'done': 'var(--accent-green)',
                'error': 'var(--accent-red)'
            };
            const statusIcons = {
                'translating': '⏳',
                'done': '✅',
                'error': '❌'
            };
            const statusTexts = {
                'translating': '翻譯中...',
                'done': '完成',
                'error': '錯誤'
            };

            // 如果有驗證警告，改變邊框顏色（覆蓋說話者顏色）
            if (segment.validation && segment.validation.showWarning) {
                segmentEl.style.borderLeftColor = 'var(--accent-yellow)';
            }

            // 時間格式
            const time = new Date(segment.createdAt).toLocaleTimeString('zh-TW');

            // 構建警告 HTML（如果有的話）
            let warningHtml = '';
            if (segment.validation && segment.validation.showWarning && segment.validation.warnings.length > 0) {
                const warningMessages = segment.validation.warnings
                    .filter(w => w.severity === 'high')
                    .map(w => w.message)
                    .slice(0, 2)  // 最多顯示 2 條警告
                    .join('；');

                if (warningMessages) {
                    warningHtml = `
                        <div style="
                            display: flex;
                            align-items: center;
                            gap: 6px;
                            padding: 6px 10px;
                            background: rgba(255, 170, 0, 0.1);
                            border-radius: 4px;
                            font-size: 12px;
                            color: var(--accent-yellow);
                            margin-top: 8px;
                        ">
                            <span>⚠️</span>
                            <span>${warningMessages}，請對照英文原文</span>
                        </div>
                    `;
                }
            }

            segmentEl.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                    <span style="font-size: 12px; color: ${speakerColor}; font-weight: 600;">${speakerLabel}</span>
                    <span style="font-size: 11px; color: var(--text-secondary);">${time}</span>
                </div>
                <div style="font-size: 18px; color: var(--text-primary); margin-bottom: 8px;">${highlightKeyInfo(segment.englishText)}</div>
                <div style="font-size: 16px; color: var(--accent-blue); margin-bottom: 8px;">
                    ${segment.chineseTranslation ? highlightKeyInfo(segment.chineseTranslation) : '<span style="color: var(--text-secondary);">翻譯中...</span>'}
                </div>
                ${warningHtml}
                <div style="display: flex; justify-content: flex-end; font-size: 12px; color: var(--text-secondary);">
                    <span style="color: ${statusColors[segment.status]}">${statusIcons[segment.status]} ${statusTexts[segment.status]}</span>
                </div>
            `;
        }

        /**
         * 更新統計數據（方案 A 版本）
         */
        function updateStats() {
            const segments = document.querySelectorAll('.segment-item');
            const total = segments.length;
            let done = 0;
            let active = 0;

            segments.forEach(el => {
                const html = el.innerHTML;
                if (html.includes('✅') || html.includes('完成')) {
                    done++;
                } else if (html.includes('⏳') || html.includes('翻譯中')) {
                    active++;
                }
            });

            segmentCountEl.textContent = total;
            activeCountEl.textContent = active;
            doneCountEl.textContent = done;
            queueCountEl.textContent = '0';  // 方案 A 沒有隊列
        }

        // ============================================
        // Stop Test
        // ============================================

        function stopTest() {
            log('Stopping...');

            // Stop Smart Segmenter
            if (smartSegmenter) {
                smartSegmenter.stop();
                const stats = smartSegmenter.getStats();
                log(`SmartSegmenter stats: ${stats.segmentCount} segments, avg ${stats.avgWordsPerSegment} words/segment`, 'info');
            }

            // Stop Web Speech
            if (webSpeech) {
                webSpeech.isRunning = false;  // Prevent auto-restart
                webSpeech.stop();
                webSpeech.reset();
                log('WebSpeech stopped', 'info');
            }

            // 🔧 v7: 取消所有活躍的 segment（更新 UI 狀態）
            if (eventHandler && eventHandler.getStore()) {
                const cancelledCount = eventHandler.getStore().cancelAllActive();
                log(`Cancelled ${cancelledCount} active segments`, 'info');
            }

            // 🐛 Bug fix: 標記實時英文預覽為已停止
            clearRealtimePreview();

            if (audioCapture) {
                audioCapture.cleanup();
            }

            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            isConnected = false;
            currentRealtimeEnglish = '';  // 重置變數
            isPaused = false;  // 重置暫停狀態
            currentSpeaker = 'them';  // 重置說話者
            resetUI();
            updateStatus('disconnected', '已停止');
            hideSpeakerIndicator();  // 隱藏說話者指示器
            switchToPreparationMode();
            log('Stopped', 'success');
        }

        /**
         * 標記實時英文預覽為已停止（保留內容供對照）
         */
        function clearRealtimePreview() {
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                // 不移除，改為標記 stopped 狀態（變灰色）
                previewEl.classList.add('stopped');
                // 更新標籤文字
                const labelEl = previewEl.querySelector('.preview-label span:last-child');
                if (labelEl) {
                    labelEl.textContent = '英文原文（已停止）';
                }
            }
        }

        function resetUI() {
            document.getElementById('btnStartListening').disabled = false;
        }

        function clearAll() {
            // Clear renderer
            if (renderer) {
                renderer.clear();
            }

            // Reset event handler
            if (eventHandler) {
                eventHandler.reset();
            }

            // 完全移除英文原文框
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.remove();
            }

            // Clear segment items from transcript
            const segmentItems = document.querySelectorAll('.segment-item');
            segmentItems.forEach(el => el.remove());

            // Show empty state
            transcriptEmpty.style.display = 'flex';

            // Clear log
            logPanel.innerHTML = '<div style="color:var(--text-secondary);">已清除</div>';

            // Reset stats
            updateStats();

            log('All cleared');
        }

        // ============================================
        // iOS PWA Standalone Detection
        // ============================================

        /**
         * Detect if running in iOS PWA standalone mode (Add to Home Screen).
         * Web Speech API is not supported in WKWebView standalone mode.
         */
        function detectPwaStandalone() {
            const isStandalone = window.navigator.standalone === true ||
                                 window.matchMedia('(display-mode: standalone)').matches;
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

            if (isStandalone && isIOS) {
                // Check if user previously dismissed (session-only)
                if (sessionStorage.getItem('pwa_warning_dismissed')) return;

                const banner = document.getElementById('pwaWarning');
                if (banner) {
                    banner.classList.add('visible');
                    console.warn('[ECA] iOS PWA standalone mode detected — Web Speech API may not work');
                }
            }
        }

        /**
         * Dismiss the PWA warning banner (session-only)
         */
        function dismissPwaWarning() {
            const banner = document.getElementById('pwaWarning');
            if (banner) {
                banner.classList.remove('visible');
                sessionStorage.setItem('pwa_warning_dismissed', '1');
            }
        }

        /**
         * Copy current URL to clipboard so user can paste in Safari
         */
        async function copyCurrentUrl() {
            try {
                await navigator.clipboard.writeText(window.location.href);
                const link = document.getElementById('pwaWarningCopyLink');
                const originalText = link.textContent;
                link.textContent = '✅ 已複製！請貼到 Safari';
                setTimeout(() => { link.textContent = originalText; }, 2000);
            } catch (e) {
                // Fallback for older browsers
                const input = document.createElement('input');
                input.value = window.location.href;
                document.body.appendChild(input);
                input.select();
                document.execCommand('copy');
                document.body.removeChild(input);
                const link = document.getElementById('pwaWarningCopyLink');
                link.textContent = '✅ 已複製！';
                setTimeout(() => { location.reload(); }, 1500);
            }
        }

        // ============================================
        // Initialize
        // ============================================

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize language preference first (before rendering UI)
            loadLanguagePreference();
            updateUILanguage();

            // Initialize API Key from localStorage
            loadApiKey();

            // Initialize AudioCapture
            if (typeof AudioCapture !== 'undefined') {
                audioCapture = new AudioCapture();
                audioCapture.onError = (error) => {
                    log(`Audio error: ${error}`, 'error');
                    stopTest();
                };
                log('AudioCapture initialized', 'success');
            } else {
                log('AudioCapture not loaded - check if audio_capture.js exists', 'error');
            }

            // Initialize new modules
            if (!initModules()) {
                log('Module initialization failed - some features may not work', 'error');
            }

            // Initialize preset selector buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyPreset(btn.dataset.preset);
                });
            });

            // Initialize accent settings from localStorage
            loadAccentSettings();

            // Phase 1: Initialize scenario grid, quick prompts, and saved scripts
            renderScenarioGrid();
            renderQuickPrompts(selectedScenario);
            renderSavedScripts();

            // Update initial placeholder based on selected scenario
            const initialScenario = SCENARIOS[selectedScenario];
            if (initialScenario && initialScenario.placeholder) {
                document.getElementById('scriptInput').placeholder = initialScenario.placeholder;
            }

            // Ensure we start in preparation mode
            switchToPreparationMode();

            // Detect iOS PWA standalone mode (Add to Home Screen)
            detectPwaStandalone();

            log('ECA Parallel Translation Test ready');
        });
    </script>

    <!-- Footer Credit -->
    <footer class="footer-credit">
        Designed by Adam Chan & Claude Code (2026)
    </footer>
</body>
</html>
