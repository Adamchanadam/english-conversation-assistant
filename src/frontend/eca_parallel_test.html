<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECA ä¸¦è¡Œç¿»è­¯æ¸¬è©¦ - Parallel Translation Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        :root {
            --bg-primary: #0f0f1a;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #16213e;
            --text-primary: #f0f0f0;
            --text-secondary: #a0a0a0;
            --accent-blue: #00d4ff;
            --accent-green: #00ff88;
            --accent-red: #ff4444;
            --accent-yellow: #ffaa00;
            --border-color: #333;
        }

        body {
            font-family: 'Noto Sans TC', 'Microsoft JhengHei', -apple-system, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .header-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: 500;
        }

        .header-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            background: var(--bg-tertiary);
        }

        .status-badge.connected {
            background: rgba(0, 255, 136, 0.15);
            color: var(--accent-green);
        }

        .status-badge.disconnected {
            background: rgba(255, 68, 68, 0.15);
            color: var(--accent-red);
        }

        .status-badge.connecting {
            background: rgba(255, 170, 0, 0.15);
            color: var(--accent-yellow);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        /* Stats Bar */
        .stats-bar {
            display: flex;
            gap: 20px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            font-size: 14px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            font-weight: 500;
            color: var(--accent-blue);
        }

        /* Transcript Panel */
        .transcript-panel {
            flex: 1;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            min-height: 400px;
        }

        .transcript-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .transcript-header h3 {
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .transcript-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .transcript-empty {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            text-align: center;
            gap: 12px;
        }

        /* Control Bar */
        .control-bar {
            display: flex;
            justify-content: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
        }

        .control-btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* Realtime Preview (Web Speech) */
        .realtime-preview {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(0, 255, 136, 0.1));
            border: 2px solid var(--accent-blue);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .preview-label {
            font-size: 12px;
            color: var(--accent-blue);
            margin-bottom: 8px;
            font-weight: 500;
        }

        .preview-text {
            font-size: 20px;
            color: var(--text-primary);
            min-height: 32px;
            line-height: 1.5;
        }

        .preview-text .interim {
            color: var(--accent-yellow);
            border-bottom: 2px solid var(--accent-yellow);
        }

        /* Toggle button for realtime preview */
        .preview-toggle {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .preview-toggle:hover {
            opacity: 0.8;
        }

        .preview-toggle .toggle-icon {
            transition: transform 0.2s;
        }

        .realtime-preview.collapsed .preview-toggle .toggle-icon {
            transform: rotate(-90deg);
        }

        .realtime-preview.collapsed .preview-text {
            display: none;
        }

        .realtime-preview.stopped {
            border-color: var(--text-secondary);
            background: rgba(160, 160, 160, 0.1);
        }

        .realtime-preview.stopped .preview-label {
            color: var(--text-secondary);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-start {
            background: var(--accent-blue);
            color: #000;
        }

        .btn-stop {
            background: var(--accent-red);
            color: #fff;
        }

        .btn-clear {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Log Panel */
        .log-panel {
            max-height: 200px;
            overflow-y: auto;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
        }

        .log-entry {
            padding: 2px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .log-entry.event { color: var(--accent-blue); }
        .log-entry.success { color: var(--accent-green); }
        .log-entry.warn { color: var(--accent-yellow); }
        .log-entry.error { color: var(--accent-red); }

        /* Preset Selector */
        .preset-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .preset-label {
            font-size: 14px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .preset-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .preset-btn {
            padding: 6px 12px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .preset-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-blue);
        }

        .preset-btn.active {
            background: var(--accent-blue);
            color: #000;
            border-color: var(--accent-blue);
            font-weight: 500;
        }

        .preset-info {
            font-size: 12px;
            color: var(--text-secondary);
            font-family: monospace;
            margin-left: auto;
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header class="header">
        <div class="header-title">
            <span>ğŸ§ª</span>
            <span>ECA ä¸¦è¡Œç¿»è­¯æ¸¬è©¦</span>
        </div>
        <div class="header-status">
            <div class="status-badge disconnected" id="statusBadge">
                <span class="status-dot"></span>
                <span id="statusText">æœªé€£ç·š</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
        <!-- Preset Selector -->
        <div class="preset-selector">
            <span class="preset-label">âš™ï¸ åˆ†æ®µæ¨¡å¼:</span>
            <div class="preset-buttons" id="presetButtons">
                <button class="preset-btn" data-preset="ultra-fast" title="æš«åœ:400ms ç©©å®š:80ms&#10;æœ€å¿«åæ‡‰ï¼Œå¯èƒ½åˆ‡æ–·å–®è©">
                    ğŸš€ æ¥µé€Ÿ
                </button>
                <button class="preset-btn active" data-preset="fast" title="æš«åœ:500ms ç©©å®š:100ms&#10;å¿«é€Ÿåæ‡‰ï¼ˆé è¨­ï¼‰">
                    âš¡ å¿«é€Ÿ
                </button>
                <button class="preset-btn" data-preset="balanced" title="æš«åœ:600ms ç©©å®š:150ms&#10;å¹³è¡¡é€Ÿåº¦èˆ‡ç©©å®šæ€§">
                    âš–ï¸ å¹³è¡¡
                </button>
                <button class="preset-btn" data-preset="stable" title="æš«åœ:750ms ç©©å®š:200ms&#10;æ›´ç©©å®šï¼Œè¼ƒæ…¢">
                    ğŸ›¡ï¸ ç©©å®š
                </button>
                <button class="preset-btn" data-preset="conservative" title="æš«åœ:900ms ç©©å®š:250ms&#10;æœ€ç©©å®šï¼Œæœ€æ…¢">
                    ğŸ”’ ä¿å®ˆ
                </button>
            </div>
            <span class="preset-info" id="presetInfo">æš«åœ:500ms ç©©å®š:100ms</span>
        </div>

        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat-item">
                <span class="stat-label">æ®µè½æ•¸:</span>
                <span class="stat-value" id="segmentCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">æ´»èºä¸­:</span>
                <span class="stat-value" id="activeCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">å·²å®Œæˆ:</span>
                <span class="stat-value" id="doneCount">0</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">ç­‰å¾…éšŠåˆ—:</span>
                <span class="stat-value" id="queueCount">0</span>
            </div>
        </div>

        <!-- Transcript Panel -->
        <div class="transcript-panel">
            <div class="transcript-header">
                <h3>
                    <span>ğŸ”Š</span>
                    <span>å³æ™‚ç¿»è­¯ï¼ˆSegment-based ä¸¦è¡Œè™•ç†ï¼‰</span>
                </h3>
            </div>
            <div class="transcript-content" id="transcriptContent">
                <div class="transcript-empty" id="transcriptEmpty">
                    <div style="font-size:48px;opacity:0.5;">ğŸ§</div>
                    <div>æº–å‚™å¥½å¾Œé»æ“Šã€Œé–‹å§‹æ¸¬è©¦ã€</div>
                    <div style="font-size:13px;">æ¸¬è©¦æ–°çš„ Segment-based ä¸¦è¡Œç¿»è­¯æ¶æ§‹</div>
                </div>
            </div>
        </div>

        <!-- Log Panel -->
        <div class="log-panel" id="logPanel">
            <div style="color:var(--text-secondary);">ç­‰å¾…æ—¥èªŒ...</div>
        </div>
    </main>

    <!-- Control Bar -->
    <div class="control-bar">
        <button class="control-btn btn-start" id="btnStart" onclick="startTest()">
            <span>â–¶ï¸</span>
            <span>é–‹å§‹æ¸¬è©¦</span>
        </button>
        <button class="control-btn btn-stop" id="btnStop" onclick="stopTest()" disabled>
            <span>â¹ï¸</span>
            <span>åœæ­¢</span>
        </button>
        <button class="control-btn btn-clear" onclick="clearAll()">
            <span>ğŸ—‘ï¸</span>
            <span>æ¸…é™¤</span>
        </button>
    </div>

    <!-- Load modules -->
    <script src="/static/segment_store.js"></script>
    <script src="/static/realtime_event_handler.js"></script>
    <script src="/static/segment_renderer.js"></script>
    <script src="/static/audio_capture.js"></script>
    <script src="/static/webspeech_realtime.js"></script>
    <script src="/static/smart_segmenter.js"></script>

    <script>
        // ============================================
        // ECA Parallel Translation Test
        // Tests: segment_store.js, realtime_event_handler.js, segment_renderer.js
        // ============================================

        // State
        let audioCapture = null;
        let peerConnection = null;
        let dataChannel = null;
        let isConnected = false;

        // New modules
        let eventHandler = null;
        let renderer = null;

        // Web Speech for real-time English subtitles (é›™è»Œç­–ç•¥)
        let webSpeech = null;
        let currentRealtimeEnglish = '';  // ç•¶å‰å¯¦æ™‚è‹±æ–‡é è¦½

        // Smart Segmenter for intelligent segmentation (600ms vs 2-3s)
        let smartSegmenter = null;

        // ============================================
        // Segmenter Presets Configuration
        // ============================================

        const SEGMENTER_PRESETS = {
            'ultra-fast': {
                name: 'æ¥µé€Ÿ',
                pauseThreshold: 400,    // æ›´çŸ­çš„æš«åœåµæ¸¬
                stabilityDelay: 80,     // æ›´çŸ­çš„ç©©å®šç­‰å¾…
                softLimit: 12,          // æ›´çŸ­çš„è»Ÿæ€§é™åˆ¶
                hardLimit: 20,          // æ›´çŸ­çš„ç¡¬æ€§é™åˆ¶
                minSegmentWords: 2,     // æ›´å°‘çš„æœ€å°å­—æ•¸
                description: 'æœ€å¿«åæ‡‰ï¼Œå¯èƒ½åˆ‡æ–·å–®è©'
            },
            'fast': {
                name: 'å¿«é€Ÿ',
                pauseThreshold: 500,
                stabilityDelay: 100,
                softLimit: 14,
                hardLimit: 22,
                minSegmentWords: 3,
                description: 'å¿«é€Ÿåæ‡‰ï¼Œè¼•å¾®é¢¨éšª'
            },
            'balanced': {
                name: 'å¹³è¡¡',
                pauseThreshold: 600,
                stabilityDelay: 150,
                softLimit: 15,
                hardLimit: 25,
                minSegmentWords: 3,
                description: 'å¹³è¡¡é€Ÿåº¦èˆ‡ç©©å®šæ€§ï¼ˆé è¨­ï¼‰'
            },
            'stable': {
                name: 'ç©©å®š',
                pauseThreshold: 750,
                stabilityDelay: 200,
                softLimit: 18,
                hardLimit: 28,
                minSegmentWords: 4,
                description: 'æ›´ç©©å®šï¼Œè¼ƒæ…¢'
            },
            'conservative': {
                name: 'ä¿å®ˆ',
                pauseThreshold: 900,
                stabilityDelay: 250,
                softLimit: 20,
                hardLimit: 30,
                minSegmentWords: 4,
                description: 'æœ€ç©©å®šï¼Œæœ€æ…¢'
            }
        };

        let currentPreset = 'fast';

        function applyPreset(presetKey) {
            const preset = SEGMENTER_PRESETS[presetKey];
            if (!preset) {
                log(`Unknown preset: ${presetKey}`, 'error');
                return;
            }

            currentPreset = presetKey;

            // Update UI
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.preset === presetKey);
            });
            document.getElementById('presetInfo').textContent =
                `æš«åœ:${preset.pauseThreshold}ms ç©©å®š:${preset.stabilityDelay}ms`;

            // Apply to SmartSegmenter if it exists
            if (smartSegmenter) {
                smartSegmenter.pauseThreshold = preset.pauseThreshold;
                smartSegmenter.stabilityDelay = preset.stabilityDelay;
                smartSegmenter.softLimit = preset.softLimit;
                smartSegmenter.hardLimit = preset.hardLimit;
                smartSegmenter.minSegmentWords = preset.minSegmentWords;
                log(`Preset applied: ${preset.name} (æš«åœ:${preset.pauseThreshold}ms, ç©©å®š:${preset.stabilityDelay}ms)`, 'success');
            }
        }

        // DOM Elements
        const statusBadge = document.getElementById('statusBadge');
        const statusText = document.getElementById('statusText');
        const transcriptContent = document.getElementById('transcriptContent');
        const transcriptEmpty = document.getElementById('transcriptEmpty');
        const btnStart = document.getElementById('btnStart');
        const btnStop = document.getElementById('btnStop');
        const logPanel = document.getElementById('logPanel');

        // Stats
        const segmentCountEl = document.getElementById('segmentCount');
        const activeCountEl = document.getElementById('activeCount');
        const doneCountEl = document.getElementById('doneCount');
        const queueCountEl = document.getElementById('queueCount');

        // ============================================
        // Logging
        // ============================================

        function log(msg, level = 'info') {
            const time = new Date().toLocaleTimeString('zh-TW');
            const entry = document.createElement('div');
            entry.className = `log-entry ${level}`;
            entry.textContent = `[${time}] ${msg}`;
            logPanel.appendChild(entry);
            logPanel.scrollTop = logPanel.scrollHeight;
            console.log(`[${level}] ${msg}`);
        }

        // ============================================
        // Status Updates
        // ============================================

        function updateStatus(status, text) {
            statusBadge.className = `status-badge ${status}`;
            statusText.textContent = text;
        }

        function updateStats() {
            if (!eventHandler) return;
            const store = eventHandler.getStore();

            const all = store.getAll();
            const active = store.getActiveSegments();
            const done = all.filter(s => s.status === 'done');
            const queue = store.pendingForResponse?.length || 0;

            segmentCountEl.textContent = all.length;
            activeCountEl.textContent = active.length;
            doneCountEl.textContent = done.length;
            queueCountEl.textContent = queue;
        }

        // ============================================
        // Initialize Modules
        // ============================================

        function initModules() {
            // Check if modules are loaded
            if (typeof EnhancedSegmentStore === 'undefined') {
                log('ERROR: segment_store.js not loaded!', 'error');
                return false;
            }
            if (typeof RealtimeEventHandler === 'undefined') {
                log('ERROR: realtime_event_handler.js not loaded!', 'error');
                return false;
            }
            if (typeof SegmentRenderer === 'undefined') {
                log('ERROR: segment_renderer.js not loaded!', 'error');
                return false;
            }

            // Initialize event handler (creates EnhancedSegmentStore internally)
            eventHandler = new RealtimeEventHandler();

            // Initialize renderer
            renderer = new SegmentRenderer(transcriptContent);

            // Inject styles
            if (typeof injectSegmentRendererStyles === 'function') {
                injectSegmentRendererStyles();
            }

            // Connect event handler to renderer
            eventHandler.onSegmentUpdate = (segment) => {
                renderer.queueUpdate(segment);
                updateStats();
            };

            // Connect logging
            eventHandler.onLog = (msg, level) => {
                log(msg, level);
            };

            // Error handling
            eventHandler.onError = (error) => {
                log(`API Error: ${error.message || error.code}`, 'error');
            };

            // Initialize Smart Segmenter with current preset
            if (typeof SmartSegmenter !== 'undefined') {
                const preset = SEGMENTER_PRESETS[currentPreset];

                // Use AdaptiveSegmenter for dynamic WPM adjustment
                smartSegmenter = new AdaptiveSegmenter({
                    pauseThreshold: preset.pauseThreshold,
                    stabilityDelay: preset.stabilityDelay,
                    softLimit: preset.softLimit,
                    hardLimit: preset.hardLimit,
                    minSegmentWords: preset.minSegmentWords
                });

                // When segment detected, translate via backend API (æ–¹æ¡ˆ A)
                smartSegmenter.onSegment = (segment, info) => {
                    log(`SmartSegmenter: "${segment.substring(0, 40)}..." (${info.wordCount}w, ${info.reason})`, 'event');

                    // ğŸ”§ æ–¹æ¡ˆ A: å…©éšæ®µæ¶æ§‹
                    // ä¸å†ä½¿ç”¨ OpenAI Realtime API ç¿»è­¯ï¼ˆæœƒè®Šæˆ Q&A å°è©±ï¼‰
                    // æ”¹ç”¨ gpt-4.1-nano æ–‡å­— API ç¿»è­¯
                    translateViaBackend(segment);
                };

                log(`SmartSegmenter initialized (preset: ${preset.name}, æš«åœ:${preset.pauseThreshold}ms)`, 'success');
            } else {
                log('smart_segmenter.js not loaded - using OpenAI default (2-3s)', 'warn');
            }

            // Initialize Web Speech for real-time English subtitles
            if (typeof WebSpeechRealtime !== 'undefined') {
                webSpeech = new WebSpeechRealtime();

                if (webSpeech.isSupported()) {
                    // å¯¦æ™‚è‹±æ–‡å›èª¿ - é‚Šèªªé‚Šé¡¯ç¤º + æ™ºèƒ½åˆ†æ®µ
                    webSpeech.onInterimResult = (fullText, interim) => {
                        currentRealtimeEnglish = fullText;
                        updateRealtimePreview(fullText, interim);

                        // Feed to SmartSegmenter
                        if (smartSegmenter) {
                            smartSegmenter.process(fullText, false);
                        }
                    };

                    // Web Speech final result
                    // æ³¨æ„ï¼šä¸éœ€è¦åœ¨é€™è£¡å†æ¬¡èª¿ç”¨ SmartSegmenter.process()
                    // å› ç‚º onInterimResult å·²ç¶“åŒ…å«äº†æœ€çµ‚æ–‡å­—ï¼Œè€Œä¸” SmartSegmenter
                    // æœ‰è‡ªå·±çš„åœé “åµæ¸¬æ©Ÿåˆ¶ï¼ˆ600msï¼‰ä¾†æ±ºå®šä½•æ™‚åˆ†æ®µã€‚
                    // Web Speech çš„ "final" åªè¡¨ç¤ºã€Œç¢ºèªé€™æ®µæ–‡å­—ã€ï¼Œä¸æ˜¯ã€Œç”¨æˆ¶åœæ­¢èªªè©±ã€ã€‚
                    webSpeech.onFinalResult = (finalText) => {
                        // åƒ…è¨˜éŒ„ï¼Œä¸èª¿ç”¨ SmartSegmenter
                        // SmartSegmenter å·²å¾ onInterimResult ç²å¾—ç´¯ç©æ–‡å­—
                        console.log('[WebSpeech] Final result received:', finalText.substring(0, 40));
                    };

                    webSpeech.onError = (error, message) => {
                        log(`WebSpeech error: ${error}`, 'warn');
                    };

                    log('WebSpeech initialized for real-time English subtitles', 'success');
                } else {
                    log('WebSpeech not supported in this browser', 'warn');
                }
            } else {
                log('webspeech_realtime.js not loaded', 'warn');
            }

            log('Modules initialized: EnhancedSegmentStore, RealtimeEventHandler, SegmentRenderer', 'success');
            return true;
        }

        // æ›´æ–°å¯¦æ™‚è‹±æ–‡é è¦½ï¼ˆé‚Šèªªé‚Šé¡¯ç¤ºï¼‰
        function updateRealtimePreview(fullText, interim) {
            let previewEl = document.getElementById('realtimePreview');
            if (!previewEl) {
                // å‰µå»ºå¯¦æ™‚é è¦½å€åŸŸ
                previewEl = document.createElement('div');
                previewEl.id = 'realtimePreview';
                previewEl.className = 'realtime-preview';
                previewEl.innerHTML = `
                    <div class="preview-label preview-toggle" onclick="toggleRealtimePreview()">
                        <span class="toggle-icon">â–¼</span>
                        <span>ğŸ¤ å¯¦æ™‚è‹±æ–‡ï¼ˆWeb Speechï¼‰</span>
                    </div>
                    <div class="preview-text" id="previewText"></div>
                `;
                transcriptContent.parentNode.insertBefore(previewEl, transcriptContent);
            }

            // ç§»é™¤ stopped ç‹€æ…‹ï¼ˆå¦‚æœæœ‰ï¼‰
            previewEl.classList.remove('stopped');

            const textEl = document.getElementById('previewText');
            if (textEl) {
                // é¡¯ç¤ºå®Œæ•´æ–‡å­—ï¼Œinterim éƒ¨åˆ†åŠ åº•ç·š
                if (interim) {
                    const finalPart = fullText.slice(0, fullText.length - interim.length);
                    textEl.innerHTML = finalPart + '<span class="interim">' + interim + '</span>';
                } else {
                    textEl.textContent = fullText || 'ç­‰å¾…èªéŸ³...';
                }
            }
        }

        // Toggle å¯¦æ™‚é è¦½çš„å±•é–‹/æ”¶åˆ
        function toggleRealtimePreview() {
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.classList.toggle('collapsed');
            }
        }

        // ============================================
        // Start Test
        // ============================================

        async function startTest() {
            // Initialize modules if not done
            if (!eventHandler) {
                if (!initModules()) {
                    return;
                }
            }

            // Check AudioCapture
            if (!audioCapture) {
                log('ERROR: AudioCapture not loaded!', 'error');
                return;
            }

            try {
                updateStatus('connecting', 'é€£ç·šä¸­...');
                btnStart.disabled = true;

                // Step 1: Capture microphone
                log('Requesting microphone access...');
                const audioStream = await audioCapture.captureMicrophone();
                log('Microphone access granted', 'success');

                // Step 2: Get ephemeral token
                log('Getting ephemeral token...');
                const tokenResponse = await fetch('/api/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ voice: 'marin' })
                });

                if (!tokenResponse.ok) {
                    throw new Error('Failed to get token');
                }

                const tokenData = await tokenResponse.json();
                log('Token received', 'success');

                // Step 3: Setup WebRTC
                await setupWebRTC(audioStream, tokenData.client_secret);

                // Start Web Speech for real-time English subtitles
                if (webSpeech && webSpeech.isSupported()) {
                    webSpeech.start();
                    log('WebSpeech started for real-time English', 'success');
                }

                // Start Smart Segmenter (600ms threshold)
                if (smartSegmenter) {
                    smartSegmenter.start();
                    log('SmartSegmenter started (600ms threshold)', 'success');
                }

                // UI updates
                btnStop.disabled = false;
                isConnected = true;
                transcriptEmpty.style.display = 'none';

            } catch (error) {
                log(`Start failed: ${error.message}`, 'error');
                resetUI();
            }
        }

        async function setupWebRTC(audioStream, clientSecret) {
            const rtcConfig = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };

            peerConnection = new RTCPeerConnection(rtcConfig);

            // Add audio track
            const audioTrack = audioStream.getAudioTracks()[0];
            peerConnection.addTrack(audioTrack, audioStream);
            log('Audio track added');

            // Handle remote audio (not needed for translation, but required by API)
            peerConnection.ontrack = (event) => {
                log('Remote track received', 'event');
            };

            // Create data channel
            dataChannel = peerConnection.createDataChannel('oai-events');
            setupDataChannel();

            // ICE state handling
            peerConnection.oniceconnectionstatechange = () => {
                log(`ICE state: ${peerConnection.iceConnectionState}`, 'event');
                if (peerConnection.iceConnectionState === 'connected') {
                    updateStatus('connected', 'ç¿»è­¯ä¸­');
                } else if (peerConnection.iceConnectionState === 'failed') {
                    stopTest();
                }
            };

            // Create and send offer
            await peerConnection.setLocalDescription();
            log('SDP offer created');

            const sdpResponse = await fetch('https://api.openai.com/v1/realtime/calls', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${clientSecret}`,
                    'Content-Type': 'application/sdp'
                },
                body: peerConnection.localDescription.sdp
            });

            if (!sdpResponse.ok) {
                throw new Error(`SDP exchange failed: ${sdpResponse.status}`);
            }

            const answerSdp = await sdpResponse.text();
            await peerConnection.setRemoteDescription({
                type: 'answer',
                sdp: answerSdp
            });

            log('WebRTC connected', 'success');
        }

        function setupDataChannel() {
            dataChannel.onopen = () => {
                log('Data channel opened', 'success');
                sendSessionUpdate();
            };

            dataChannel.onclose = () => {
                log('Data channel closed', 'warn');
            };

            dataChannel.onerror = (error) => {
                log(`Data channel error: ${error}`, 'error');
            };

            dataChannel.onmessage = (event) => {
                const data = JSON.parse(event.data);
                // Route to new event handler
                eventHandler.handle(data);
            };
        }

        function sendSessionUpdate() {
            // Translation mode session configuration
            // Uses GA API format (2025)
            //
            // ğŸ”§ Smart Segmentation Strategy (2026-02-02):
            // - create_response: false â†’ ç¦ç”¨ OpenAI çš„è‡ªå‹•åˆ†æ®µï¼ˆ2-3s å»¶é²ï¼‰
            // - å‰ç«¯ SmartSegmenter æ§åˆ¶åˆ†æ®µï¼ˆ600ms é–¾å€¼ï¼‰
            // - è¦‹ spec/research/speech_segmentation.md
            //
            // ğŸ”§ Fix Test 21 Issues (2026-02-02):
            // - 2.2a ç°¡é«”â†’ç¹é«”ï¼šæ˜ç¢ºæŒ‡å®š "Traditional Chinese (Hong Kong)" + è² é¢ç¯„ä¾‹
            // - 2.2b Q&Aâ†’ç¿»è­¯ï¼šæ¡ç”¨ Twilio é¢¨æ ¼ prompt "translation machine"
            // - Reference: https://github.com/twilio-samples/live-translation-openai-realtime-api
            const sessionConfig = {
                type: 'session.update',
                session: {
                    type: 'realtime',
                    // ğŸ”§ Twilio-style translation prompt (Test 21 fix)
                    // Key elements:
                    // 1. "translation machine" identity - prevents dialogue mode
                    // 2. Explicit "Traditional Chinese (Hong Kong)" - prevents simplified Chinese
                    // 3. Negative examples - prevents common errors
                    instructions: `You are a translation machine. Your sole function is to translate English audio to Traditional Chinese (Hong Kong style, ç¹é«”ä¸­æ–‡).

CRITICAL RULES:
- Do NOT respond to the audio content. Do NOT have a dialogue.
- Do NOT say "æˆ‘æ˜ç™½", "å¥½çš„", "è«‹å•", or any conversational phrases.
- Output ONLY the Chinese translation, nothing else.
- Use Traditional Chinese characters (ç¹é«”å­—), NOT Simplified Chinese (ç®€ä½“å­—).
  âœ“ Correct: èªªè©±ã€å­¸ç¿’ã€é›»è©±ã€ç¶“æ¿Ÿ
  âœ— Wrong: è¯´è¯ã€å­¦ä¹ ã€ç”µè¯ã€ç»æµ

FORMAT:
- Proper nouns: HK-style with English in brackets, e.g., "æ›¼å¾·çˆ¾æ£® (Peter Mandelson)"
- Numbers: Keep as digits, e.g., "$75,000", "2019å¹´"
- Output: Pure translation text only`,
                    output_modalities: ['text'],
                    audio: {
                        input: {
                            format: { type: 'audio/pcm', rate: 24000 },
                            transcription: {
                                model: 'gpt-4o-mini-transcribe',
                                language: 'en'  // ğŸ”§ å¼·åˆ¶è‹±æ–‡è½‰éŒ„ï¼Œé¿å…èª¤è­˜åˆ¥ç‚ºå…¶ä»–èªè¨€
                            },
                            turn_detection: {
                                type: 'semantic_vad',
                                eagerness: 'high',
                                // ğŸ”§ Disable auto response - SmartSegmenter controls segmentation
                                create_response: false,
                                interrupt_response: false
                            }
                        }
                    }
                }
            };

            sendEvent(sessionConfig);
            log('Session configured: Twilio-style translation prompt + SmartSegmenter (600ms)');

            // âš ï¸ ç§»é™¤ few-shot priming - ç¶“æ¸¬è©¦ç™¼ç¾æœƒè®“æ¨¡å‹é€²å…¥å°è©±æ¨¡å¼
            // åŸå› ï¼šTEXT ç¯„ä¾‹èˆ‡ AUDIO è¼¸å…¥ä¸åŒï¼Œæ¨¡å‹æœƒèªç‚ºåœ¨å°è©±
            // æ”¹ç”¨æ›´å¼·çš„ session instructions + response.create instructions
        }

        function sendEvent(event) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify(event));
            }
        }

        /**
         * Force translation by sending response.create event
         * This bypasses OpenAI's 2-3s semantic_vad delay
         *
         * See: src/skills/openai-realtime-mini-voice/SKILL.md
         *
         * ğŸ› Bug fix (2026-02-02):
         * - response.create æ ¼å¼æ‡‰è©²æ˜¯ { conversation: "auto" }ï¼Œä¸æ˜¯ { modalities: ["text"] }
         * - æ·»åŠ é˜²æŠ–æ©Ÿåˆ¶ï¼Œé¿å…é »ç¹è§¸ç™¼
         * - æ·»åŠ æœ€å°é–“éš”æª¢æŸ¥
         */
        let lastForceTranslationTime = 0;
        const MIN_TRANSLATION_INTERVAL = 500;  // æœ€å°‘ 500ms é–“éš”

        function forceTranslation() {
            if (!dataChannel || dataChannel.readyState !== 'open') {
                log('Cannot force translation: data channel not open', 'warn');
                return;
            }

            // é˜²æŠ–ï¼šç¢ºä¿æœ€å°‘ 500ms é–“éš”
            const now = Date.now();
            if (now - lastForceTranslationTime < MIN_TRANSLATION_INTERVAL) {
                // å¤ªé »ç¹ï¼Œè·³é
                return;
            }
            lastForceTranslationTime = now;

            // Commit current audio buffer and create response
            // This tells OpenAI: "I've finished speaking this segment, process it now"
            const commitEvent = {
                type: 'input_audio_buffer.commit'
            };
            sendEvent(commitEvent);

            // Create response (translation)
            // ğŸ”§ Test 21 fix: å¼·åŒ–ç¿»è­¯è¡Œç‚º
            // 1. æ˜ç¢ºæŒ‡å®šç¹é«”ä¸­æ–‡
            // 2. ç¦æ­¢å°è©±æ¨¡å¼
            const responseEvent = {
                type: 'response.create',
                response: {
                    conversation: 'auto',
                    // ğŸ”§ Twilio-style: å¼·åŒ–ç¿»è­¯æŒ‡ä»¤
                    instructions: 'Translate to Traditional Chinese (ç¹é«”ä¸­æ–‡). Output ONLY the translation. No dialogue, no "æˆ‘æ˜ç™½", no "å¥½çš„", no questions. Use Traditional characters (èªªè©± not è¯´è¯).'
                }
            };
            sendEvent(responseEvent);

            log('Force translation triggered (Traditional Chinese)', 'event');
        }

        // ============================================
        // æ–¹æ¡ˆ A: ä¸²æµç¿»è­¯ API (gpt-4o-mini + SSE)
        // é¦–å­—å›æ‡‰ç´„ 0.3 ç§’
        // ============================================

        let segmentCounter = 0;

        /**
         * é€éä¸²æµ API ç¿»è­¯è‹±æ–‡æ®µè½
         * æ–¹æ¡ˆ A: å…©éšæ®µæ¶æ§‹ + ä¸²æµå›æ‡‰
         * - Web Speech API â†’ è‹±æ–‡ STT
         * - gpt-4o-mini â†’ æ–‡å­—ç¿»è­¯ï¼ˆä¸²æµï¼‰
         *
         * å„ªé»ï¼šé¦–å­—å›æ‡‰ç´„ 0.3 ç§’ï¼Œç”¨æˆ¶å¯ä»¥é‚Šçœ‹é‚Šè®€
         */
        async function translateViaBackend(englishText) {
            if (!englishText || englishText.trim().length === 0) {
                return;
            }

            // å‰µå»º segment ç”¨æ–¼ UI é¡¯ç¤º
            const segmentId = `seg-${++segmentCounter}`;
            const segment = {
                id: segmentId,
                englishText: englishText.trim(),
                chineseTranslation: '',
                status: 'translating',
                createdAt: Date.now(),
                completedAt: null,
                error: null
            };

            // ç«‹å³é¡¯ç¤ºè‹±æ–‡ï¼ˆç‹€æ…‹ï¼šç¿»è­¯ä¸­ï¼‰
            renderSegment(segment);
            updateStats();

            const startTime = Date.now();
            log(`[ä¸²æµ] é–‹å§‹ç¿»è­¯: "${englishText.substring(0, 30)}..."`, 'event');

            try {
                // ä½¿ç”¨ä¸²æµ API
                const response = await fetch('/api/translate/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: englishText.trim() })
                });

                if (!response.ok) {
                    throw new Error(`API error: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let firstChunkTime = null;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const text = decoder.decode(value, { stream: true });
                    const lines = text.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));

                                if (data.text) {
                                    // è¨˜éŒ„é¦–å­—æ™‚é–“
                                    if (!firstChunkTime) {
                                        firstChunkTime = Date.now() - startTime;
                                        log(`[ä¸²æµ] é¦–å­—å›æ‡‰: ${firstChunkTime}ms`, 'success');
                                    }

                                    // ç´¯åŠ ç¿»è­¯æ–‡å­—
                                    segment.chineseTranslation += data.text;
                                    // å³æ™‚æ›´æ–° UI
                                    renderSegment(segment);
                                }

                                if (data.done) {
                                    // å®Œæˆ
                                    segment.status = 'done';
                                    segment.completedAt = Date.now();
                                    renderSegment(segment);
                                    updateStats();

                                    const totalTime = Date.now() - startTime;
                                    log(`[ä¸²æµ] å®Œæˆ: ${totalTime}ms, "${segment.chineseTranslation.substring(0, 30)}..."`, 'success');
                                }

                                if (data.error) {
                                    throw new Error(data.error);
                                }
                            } catch (e) {
                                // JSON parse error, skip
                            }
                        }
                    }
                }

                // ç¢ºä¿æ¨™è¨˜ç‚ºå®Œæˆ
                if (segment.status !== 'done') {
                    segment.status = 'done';
                    segment.completedAt = Date.now();
                    renderSegment(segment);
                    updateStats();
                }

            } catch (error) {
                // éŒ¯èª¤è™•ç†
                segment.status = 'error';
                segment.error = error.message;
                segment.chineseTranslation = `[ç¿»è­¯å¤±æ•—] ${error.message}`;

                renderSegment(segment);
                updateStats();

                log(`[ä¸²æµ] ç¿»è­¯éŒ¯èª¤: ${error.message}`, 'error');
            }
        }

        /**
         * æ¸²æŸ“å–®å€‹ segment åˆ° UI
         * ç°¡åŒ–ç‰ˆï¼šç›´æ¥æ“ä½œ DOMï¼Œä¸ä¾è³´ SegmentRenderer
         */
        function renderSegment(segment) {
            // éš±è—ç©ºç‹€æ…‹
            transcriptEmpty.style.display = 'none';

            let segmentEl = document.getElementById(segment.id);

            if (!segmentEl) {
                // å‰µå»ºæ–°çš„ segment å…ƒç´ 
                segmentEl = document.createElement('div');
                segmentEl.id = segment.id;
                segmentEl.className = 'segment-item';
                segmentEl.style.cssText = `
                    background: var(--bg-tertiary);
                    border-radius: 8px;
                    padding: 12px 16px;
                    margin-bottom: 12px;
                    border-left: 3px solid var(--accent-blue);
                `;
                transcriptContent.insertBefore(segmentEl, transcriptContent.firstChild);
            }

            // ç‹€æ…‹é¡è‰²
            const statusColors = {
                'translating': 'var(--accent-yellow)',
                'done': 'var(--accent-green)',
                'error': 'var(--accent-red)'
            };
            const statusIcons = {
                'translating': 'â³',
                'done': 'âœ…',
                'error': 'âŒ'
            };
            const statusTexts = {
                'translating': 'ç¿»è­¯ä¸­...',
                'done': 'å®Œæˆ',
                'error': 'éŒ¯èª¤'
            };

            segmentEl.style.borderLeftColor = statusColors[segment.status] || 'var(--accent-blue)';

            // æ™‚é–“æ ¼å¼
            const time = new Date(segment.createdAt).toLocaleTimeString('zh-TW');

            segmentEl.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <div style="font-size: 18px; color: var(--text-primary);">${segment.englishText}</div>
                </div>
                <div style="font-size: 16px; color: var(--accent-blue); margin-bottom: 8px;">
                    ${segment.chineseTranslation || '<span style="color: var(--text-secondary);">ç¿»è­¯ä¸­...</span>'}
                </div>
                <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-secondary);">
                    <span>${time}</span>
                    <span style="color: ${statusColors[segment.status]}">${statusIcons[segment.status]} ${statusTexts[segment.status]}</span>
                </div>
            `;
        }

        /**
         * æ›´æ–°çµ±è¨ˆæ•¸æ“šï¼ˆæ–¹æ¡ˆ A ç‰ˆæœ¬ï¼‰
         */
        function updateStats() {
            const segments = document.querySelectorAll('.segment-item');
            const total = segments.length;
            let done = 0;
            let active = 0;

            segments.forEach(el => {
                const html = el.innerHTML;
                if (html.includes('âœ…') || html.includes('å®Œæˆ')) {
                    done++;
                } else if (html.includes('â³') || html.includes('ç¿»è­¯ä¸­')) {
                    active++;
                }
            });

            segmentCountEl.textContent = total;
            activeCountEl.textContent = active;
            doneCountEl.textContent = done;
            queueCountEl.textContent = '0';  // æ–¹æ¡ˆ A æ²’æœ‰éšŠåˆ—
        }

        // ============================================
        // Stop Test
        // ============================================

        function stopTest() {
            log('Stopping...');

            // Stop Smart Segmenter
            if (smartSegmenter) {
                smartSegmenter.stop();
                const stats = smartSegmenter.getStats();
                log(`SmartSegmenter stats: ${stats.segmentCount} segments, avg ${stats.avgWordsPerSegment} words/segment`, 'info');
            }

            // Stop Web Speech
            if (webSpeech) {
                webSpeech.isRunning = false;  // Prevent auto-restart
                webSpeech.stop();
                webSpeech.reset();
                log('WebSpeech stopped', 'info');
            }

            // ğŸ”§ v7: å–æ¶ˆæ‰€æœ‰æ´»èºçš„ segmentï¼ˆæ›´æ–° UI ç‹€æ…‹ï¼‰
            if (eventHandler && eventHandler.getStore()) {
                const cancelledCount = eventHandler.getStore().cancelAllActive();
                log(`Cancelled ${cancelledCount} active segments`, 'info');
            }

            // ğŸ› Bug fix: æ¨™è¨˜å¯¦æ™‚è‹±æ–‡é è¦½ç‚ºå·²åœæ­¢
            clearRealtimePreview();

            if (audioCapture) {
                audioCapture.cleanup();
            }

            if (dataChannel) {
                dataChannel.close();
                dataChannel = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            isConnected = false;
            currentRealtimeEnglish = '';  // é‡ç½®è®Šæ•¸
            resetUI();
            updateStatus('disconnected', 'å·²åœæ­¢');
            log('Stopped', 'success');
        }

        /**
         * æ¨™è¨˜å¯¦æ™‚è‹±æ–‡é è¦½ç‚ºå·²åœæ­¢ï¼ˆä¿ç•™å…§å®¹ä¾›å°ç…§ï¼‰
         */
        function clearRealtimePreview() {
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                // ä¸ç§»é™¤ï¼Œæ”¹ç‚ºæ¨™è¨˜ stopped ç‹€æ…‹ï¼ˆè®Šç°è‰²ï¼‰
                previewEl.classList.add('stopped');
                // æ›´æ–°æ¨™ç±¤æ–‡å­—
                const labelEl = previewEl.querySelector('.preview-label span:last-child');
                if (labelEl) {
                    labelEl.textContent = 'ğŸ¤ è‹±æ–‡åŸæ–‡ï¼ˆå·²åœæ­¢ï¼‰- é»æ“Šå±•é–‹/æ”¶åˆ';
                }
            }
        }

        function resetUI() {
            btnStart.disabled = false;
            btnStop.disabled = true;
        }

        function clearAll() {
            // Clear renderer
            if (renderer) {
                renderer.clear();
            }

            // Reset event handler
            if (eventHandler) {
                eventHandler.reset();
            }

            // å®Œå…¨ç§»é™¤è‹±æ–‡åŸæ–‡æ¡†
            const previewEl = document.getElementById('realtimePreview');
            if (previewEl) {
                previewEl.remove();
            }

            // Show empty state
            transcriptEmpty.style.display = 'flex';

            // Clear log
            logPanel.innerHTML = '<div style="color:var(--text-secondary);">å·²æ¸…é™¤</div>';

            // Reset stats
            updateStats();

            log('All cleared');
        }

        // ============================================
        // Initialize
        // ============================================

        document.addEventListener('DOMContentLoaded', function() {
            // Initialize AudioCapture
            if (typeof AudioCapture !== 'undefined') {
                audioCapture = new AudioCapture();
                audioCapture.onError = (error) => {
                    log(`Audio error: ${error}`, 'error');
                    stopTest();
                };
                log('AudioCapture initialized', 'success');
            } else {
                log('AudioCapture not loaded - check if audio_capture.js exists', 'error');
            }

            // Initialize new modules
            if (!initModules()) {
                log('Module initialization failed - some features may not work', 'error');
            }

            // Initialize preset selector buttons
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    applyPreset(btn.dataset.preset);
                });
            });

            log('ECA Parallel Translation Test ready');
        });
    </script>
</body>
</html>
